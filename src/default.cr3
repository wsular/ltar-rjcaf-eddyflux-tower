'Online Corrections Flux Program version 1.x

'Copyright (c) 2017 Washington State University. Adapted with permission.
'Copyright (c), 2014, 2015 Campbell Scientific, Inc. All rights reserved.
'This program is intended for use with Campbell Scientific open-path eddy-covariance systems manufactured after Fall 2010 that use an EC150 with CSAT3A or an IRGASON.
'The most common or “best practice” corrections are applied to fluxes in this program.  Consult the manual for details on these corrections.  It is the responsibility
'of the user to determine appropriateness of the corrections used. Campbell Scientific always recommends saving raw time series data
'in case reprocessing of raw data is warranted. Furthermore, it is the responsibility of the user and associated researchers to determine the quality and fitness of
'any and all data for a publication, regardless of whether said data were processed by this program or another tool.

'Versions numbers less than 1.00 of this program are not fully tested or officially released. Campbell Scientific is not responsible for any errors in data collected
'using program versions prior to 1.00.

'Abbreviations in comments and variables
'CR3K   CR3000
'CSAT   CSAT3A or sonic anemometer in IRGASON
'sonic  CSAT3A or sonic anemometer in IRGASON
'CS6XX  CS616, CS650, or CS655
'CS65X  CS650 or CS655
'cumul  cumulative
'dia    diameter
'diag   dignosis
'dir    direction
'dist   distance
'flg    flag
'FP     footprint
'Freq   frequency
'FW     FW05, FW1, or FW3. FW is an abbreviation for fine wire thermocouple
'intrst interest
'IRGA   EC150 or IRGASON InfraRed Gas Analyzer
'nmbr   number
'pct    percent
'Pyran  pyranometer
'RH     relative humidity
'rng    range
'QC     quality control or quality classification
'shf    soil heat flux
'shfp   soil heat flux plate
'sig    signal
'strgth strength
'within win
'wnd    wind
'wtr    water
'hfp01xx HFP01 or HFP01SC soil heat flux plate sensor

'*** SIGN CONVENTION
' Positive fluxes away from the ground surface and negative towards the ground surface.

'*** SITE AND CALIBRATION CONSTANTS
' Search for the text string "Unique" in this code to find the lines below in this program where unique site constants and sensor calibration values are entered.

'*** LAGS
' Instrument scan lag: Before computing online fluxes and writing to the time series data table, an instrument scan lag for each variable is introduced
' to account for the fixed instrument delays so that any pair of variables for covariance are aligned at the time resolution of the scan rate. Scan lags
' depend on instrument settings and/or the datalogger scan interval. In the case of the IRGASON or EC150 with CSAT3A, the instrument delay is determined
' by the bandwidth setting in the EC100 electronics (see appendix A of IRGASON manual, Revision 6/14).  For analog measurements such as FW sensors,
' the measurements are assumed to have no scan delay. After instrument scan lags are applied, the data are recorded in the time series output table.

' Sensing time lag: After the instrument scan lag is applied, an additional lag called the sensing time lag is applied to account for covariance attenuation
' at high frequency due to spatial separation between the scalar sensor (e.g. FW or IRGA) and sonic anemometer. The sensing lag is positive if wind passed the sonic volume first
' followed by the scalar sensor; otherwise, the sensing lag is negative. Sensing time lags depend on the wind speed and sensor separation.  An algorithm
' in the program selects a lag that maximizes covariances and is physically possible. The final outputs in the flux output table have sensing time lags applied.

'*** Unit Definitions ***
'SYMBOL      UNIT
'C           Celsius
'degrees     angle degrees
'frac_v_wtr  Fraction volumetric water content
'g           grams
'J           Joules
'Hz          Hertz
'kg          kilograms
'kPa         kilopascals
'm           meters
'mg          milligrams
'mmol        millimole
'mol         mole
'ms          millisecond
's           seconds
'umol        micromoles
'usecond     microsecond
'V           volts
'W           Watts

PipeLineMode
AngleDegrees  'Angles are in degrees throughout the program

'*** SENSORS ****
Const SENSOR_IRGASON     = TRUE                   'Unique: IRGASON, if TRUE, SENSOR_CSAT3AEC150 must be set to FALSE
Const SENSOR_CSAT3AEC150 = FALSE                  'Unique: CSAT3A + EC150, if TRUE, SENSOR_IRGASON must be set to FALSE.
Const SENSOR_FW          = FALSE                  'Unique: FW05, FW1, FW3, or other fine wire thermocouple

'Select at most 1 temperature/RH probe:
Const SENSOR_HMP155A     = TRUE                   'Unique: Vaisala HMP155A
Const SENSOR_HC2S3       = FALSE                  'Unique: Campbellsci HC2S3
Const SENSOR_HMP45C      = FALSE                  'Unique: Vaisala HMP45C

Const SENSOR_NR_LITE     = FALSE                  'Unique: NR Lite2: net radiometer, if true, SENSOR_NR01 and SENSOR_CNR4 must be set to FALSE
Const SENSOR_CS300       = FALSE                  'Unique: CS300: pyranometer, if true, SENSOR_NR01 and SENSOR_CNR4 must be set to FALSE
Const SENSOR_LI200X      = FALSE                  'Unique: LI200X: pyranometer, if true, SENSOR_NR01 and SENSOR_CNR4 must be set to FALSE
Const SENSOR_LI190SB     = FALSE                  'Unique: LI190SB: Quantum, if true, SENSOR_NR01 and SENSOR_CNR4 must be set to FALSE
Const SENSOR_SI111       = FALSE                  'Unique: SI111: Infrared radiometer, if true, SENSOR_NR01 and SENSOR_CNR4 must be set to FALSE
Const SENSOR_NR01        = FALSE                   'Unique: NR01: 4-way net radiometer, if true, SENSOR_NR_LITE and SENSOR_CNR4 must be set to FALSE
Const SENSOR_CNR4        = FALSE                  'Unique: CNR4: 4-way net radiometer, if true, SENSOR_NR_LITE and SENSOR_NR01 must be set to FALSE

'Select at most 1 rain sensor:
Const SENSOR_TE525       = FALSE    'Unique: TE525 (6") rain gage
Const SENSOR_TE525WS     = TRUE     'Unique: TE525WS (8") rain gage
Const SENSOR_TE525MM     = FALSE    'Unique: TE525MM (metric) rain gage
Const SENSOR_TE525_wf    = FALSE    'Unique: TE525 or TE525MM rain gage with 8in funnel

Const SENSOR_TCAV        = FALSE                   'Unique: TCAV: type E thermocouple averaging soil temperature probes
Const SENSOR_CS616       = FALSE                   'Unique: CS616: water content reflectometers for volumetric soil moisture, if true, SENSOR_CS65X must be set to FALSE
Const SENSOR_CS65X       = FALSE                  'Unique: CS650 or CS655: water content reflectometers for volumetric soil moisture, if true, SENSOR_CS616 must be set to FALSE
Const SENSOR_HFP01       = FALSE                  'Unique: HFP01: soil heat flux plates, if true, SENSOR_HFP01SC must be set to FALSE
Const SENSOR_HFP01SC     = FALSE                   'Unique: HFP01SC: self-calibrated soil heat flux plates, if true, SENSOR_HFP01 must be set to FALSE

'Composite boolean variables for variables above
Const SENSOR_TMPR_RH     = ((SENSOR_HMP155A) OR (SENSOR_HC2S3) OR (SENSOR_HMP45C))
Const SENSOR_Rn          = ((SENSOR_CNR4) OR (SENSOR_NR01) OR (SENSOR_NR_LITE))
Const SENSOR_TE525x      = ((SENSOR_TE525) OR (SENSOR_TE525WS) OR (SENSOR_TE525MM) OR (SENSOR_TE525_wf))
Const SENSOR_HFP         = ((SENSOR_HFP01) OR (SENSOR_HFP01SC))
Const SENSOR_CS6XX       = ((SENSOR_CS616) OR (SENSOR_CS65X))

'***** Wiring Instruction ******
'*** Beginning of EC100 (IRGASON or EC150 w/ or w/o CSAT3A sonic head) wiring ***
'SDM-C1  SDM Data (green)
'SDM-C2  SDM Clock (white)
'SDM-C3  SDM Enable (brown)
'G       SDM reference (black)
'        SDM shield (clear)

'+12V    power (red)
'G       power reference (black)
'        power shield (clear)
'*** End of EC100 (IRGASON or EC150 w/ or w/o CSAT3A sonic head) wiring ***

#If (SENSOR_HFP) Then
'Soil heat flux plates
Const SHF_ANALOG_INPUT = 1  'Starting differential analog input channel.
Const NMBR_SHFP = 4         'Unique: number of HFP01 or HFP01SC sensors to measure (Maximum is 4) .

Data 1000/62                'Unique: multiplier for HFP01xx #1 (1000/sensitivity).
#If (NMBR_SHFP >1) Then     'This conditional statement can avoid the confliction with Data statements for the numerical wTs transfer function from Dijk (2002)) if NMBR_SHFP < 2

Data 1000/62                'Unique: multiplier for HFP01xx #2 (1000/sensitivity).
#EndIf
#If (NMBR_SHFP >2) Then     'This conditional statement can avoid the confliction with Data statements for the numerical wTs transfer function from Dijk (2002)) if NMBR_SHFP < 3

Data 1000/62
#EndIf                      'Unique: multiplier for HFP01xx #3 (1000/sensitivity).
#If (NMBR_SHFP >3) Then     'This conditional statement can avoid the confliction with Data statements for the numerical wTs transfer function from Dijk (2002)) if NMBR_SHFP < 4

Data 1000/62                'Unique: multiplier for HFP01xx #4 (1000/sensitivity).
#EndIf

#If (SENSOR_HFP01) Then
'*** Beginning of HFP01 wiring ***
'1H      Signal #1 (white)
'1L      Signal reference #1 (green)
'gnd     Shield #1 (clear)

'2H     Signal #2 (white)
'2L     Signal reference #2 (green)
'gnd    Shield #2 (clear)

'3H     Signal #3 (white)
'3L     Signal reference #3 (green)
'gnd    Shield #3 (clear)

'4H     Signal #4 (white)
'4L     Signal reference #4 (green)
'gnd    Shield #4 (clear)
'*** End of HFP01 wiring ***
#EndIf
#If ( SENSOR_HFP01SC = TRUE ) Then

Const SHF_HEATER_ANALOG_INPUT = 5     'Starting single-ended analog input channel to measure the heater of HFP01SC #1.

'*** Beginning of HFP01SC wiring ***
'1H      Signal #1 (white)
'gnd     Signal reference #1 (green)
'gnd     Shield #1 (clear)

'1L      Signal #2 (white)
'gnd     Signal reference #2 (green)
'gnd     Shield #2 (clear)

'2H      Signal #3 (white)
'gnd     Signal reference #3 (green)
'gnd     Shield #3 (clear)

'2L      Signal #4 (white)
'gnd     Signal reference #4 (green)
'gnd     Shield #4 (clear)

'3H      Heater resistor signal #1 (yellow)
'gnd     Heater resistor signal reference #1 (purple)
'        Heater shield #1 (clear)

'3L      Heater resistor signal #2 (yellow)
'gnd     Heater resistor signal reference #2 (purple)
'        Heater shield #2 (clear)

'4H      Heater resistor signal #3 (yellow)
'gnd     Heater resistor signal reference #3 (purple)
'        Heater shield #3 (clear)

'4L      Heater resistor signal #4 (yellow)
'gnd     Heater resistor signal reference #4 (purple)
'        Heater shield #4 (clear)

'SW12-1  Heater power #1 (red)
'        Heater power #2 (red)
'        Heater power #3 (red)
'        Heater power #4 (red)
'G       Heater reference #1 (black)
'        Heater reference #2 (black)
'        Heater reference #3 (black)
'        Heater reference #4 (black)
'*** End of HFP01SC wiring ***
#EndIf
#EndIf

#If (SENSOR_FW) Then

Const FW_ANALOG_INPUT  = 5          'Differential analog input channel for FW (Input channel 5 or 11 is recommended)

'*** Beginning of FW wiring ***
'5H      FW signal (purple)
'5L      FW signal reference (red)
'gnd     FW shield (clear)
'*** End of FW wiring ***

#EndIf
#If (SENSOR_Rn) Then
' Net radiations sensors
Const NR_ANALOG_INPUT = 6           'Starting differential analog input channel for a net radiation sensor.

#EndIf
#If (SENSOR_NR_LITE) Then

Const NRLITE_CAL = 1000/16          'Unique: multiplier for NR Lite (1000/sensitivity).
'*** Beginning of NR Lite wiring ***
'6H      Signal (white/red)
'6L      Signal reference (green/blue)
'gnd     short jumper wire to 6L
'        Shield (clear)
'*** End of NR Lite wiring ***

#EndIf
#If (SENSOR_NR01) OR (SENSOR_CNR4) Then

Const T_NR_ANALOG_INPUT = 10            'Differential analog input channel to measure body temperature of 4-way radiation sensor. For a single-end analog input channel (2*T_NR_ANALOG_INPUT-1)

#EndIf
#If (SENSOR_NR01) Then

Const T_NR_CURRENT_EXCITATION = Ix1     'Current excitation channel.
Const NR01_SW_IN_CAL  = 1000/15         'Unique: multiplier for NR01 shortwave downwelling radiation (1000/sensitivity).
Const NR01_SW_OUT_CAL = 1000/15         'Unique: multiplier for NR01 shortware upwelling radiation (1000/sensitivity).
Const NR01_LW_IN_CAL  = 1000/8          'Unique: multiplier for NR01 longwave downwelling radiation (1000/sensitivity).
Const NR01_LW_OUT_CAL = 1000/8          'Unique: multiplier for NR01 longwave upwelling radiation (1000/sensitivity).

'*** Beginning of NR01 wiring ***
'6H      Downwelling (incoming) shortwave radiation signal (red)
'6L      Downwelling (incoming) shortwave radiation signal reference (blue)
'gnd     Shield (clear)

'7H      Upwelling (outgoing) shortwave radiation signal (white)
'7L      Upwelling (outgoing) shortwave radiation signal reference (green/black)

'8H      Downwelling (incoming) longwave radiation signal (brown/gray or orange)
'8L      Downwelling (incoming) longwave radiation signal reference (yellow)

'9H      Upwelling (outgoing) longwave radiation signal (purple or pink/brown)
'9L      Upwelling (outgoing) longwave radiation signal reference (gray/green)

'10H     Pt100 signal (white/yellow)
'10L     Pt100 signal reference (green)
'gnd     Pt100 shield (silver/bare)

'IX1     Pt100 current excitation (red)
'IXR     Pt100 current excitation reference (blue/blue)
'*** End of NR01 wiring ***
#EndIf
#If (SENSOR_CNR4) Then

Const T_NR_VOLTAGE_EXCITATION = Vx1     'Voltage excitation channel.
Const CNR4_SW_IN_CAL    = 1000/15       'Unique: multiplier for CNR4 shortwave downwelling radiation (1000/sensitivity).
Const CNR4_SW_OUT_CAL   = 1000/15       'Unique: multiplier for CNR4 shortware upwelling radiation (1000/sensitivity).
Const CNR4_LW_IN_CAL    = 1000/8        'Unique: multiplier for CNR4 longwave downwelling radiation (1000/sensitivity).
Const CNR4_LW_OUT_CAL   = 1000/8        'Unique: multiplier for CNR4 longwave upwelling radiation (1000/sensitivity).

'*** Beginning of CNR4 wiring ***
'6H      Downwelling shortwave radiation signal (red)
'6L      Downwelling shortwave radiation signal reference (blue)
'gnd     Shield (clear)
'        short jumper wire to 6L

'7H      Upwelling shortwave radiation signal (white)
'7L      Upwelling shortwave radiation signal reference (black)
'gnd     short jumper wire to 7L

'8H      Downwelling longwave radiation signal (gray)
'8L      Downwelling longwave radiation signal reference (yellow)
'gnd     short jumper wire to 8L

'9H      Upwelling longwave radiation signal (brown)
'9L      Upwelling longwave radiation signal reference (green)
'gnd     short jumper wire to 9L

'10H     Thermistor signal (white)
'gnd     Thermistor signal reference (black)
'        Shield (clear)

'VX1     Thermistor excitation (red)
'*** End of CNR4 wiring ***

#EndIf
#If (SENSOR_LI200X) OR (SENSOR_CS300) Then

Const PYRAN_ANALOG_INPUT  = 7     'Differential analog input channel for LI200X or CS300 Pyranometer
Const PYRAN_VOLTAGE_RANG  = mV20  'Unique: measurement range of voltage mV20 for LI200 and mV250 for CS300 pyranometer
Const PYRAN_MULT          = 200   'Unique: multiplier for LI200X [200 W/(m^2 * mV)] or CS300 [5 W/(m^2 * mV)] pyranometer .
Const PYRAN_OFFSET        = 0     'Unique: offset for LI200X [0 W/m^2] or CS300 (0 W/m^2) pyranometer.

'*** Beginning of Pyranometer wiring ***
'7H      Pyranometer signal (red)
'7L      Pyranometer signal reference (black)
'gnd     Shield (clear)

#If (SENSOR_LI200X) Then
'gnd     Pyranometer current return (white)
#EndIf

'***     End of pyranometer wiring   ***
#EndIf
#If (SENSOR_LI190SB) Then

Const QUANTUM_ANALOG_INPUT  = 8     'Differential analog input channel for quantum PAR sensor
Const QUANTUM_VOLTAGE_RANGE = mV20  'Unique: measurement range of voltage
Const QUANTUM_MULT          = 256   'Unique: multiplier (1000 C) for quantum PAR sensor.
Const QUANTUM_OFFSET        = 0     'Unique: offset for for quantum PAR sensor.

'*** Beginning of quantum wiring ***
'8H      Quantum signal (red)
'8L      Quantum signal reference Jump to gnd (black)
'gnd     Shield (clear)
'***     End of quantum wiring   ***
#EndIf
#If (SENSOR_SI111) Then
Const SI111_ANALOG_INPUT  = 9     'Differential analog input channel for SI-111 sensor
Const SI111_EXCITATION    = Vx2   'Voltage excitation channel for SI-111 sensor

Const m0_SI111 =  1.41970e9       'Unique: calbration m0
Const m1_SI111 =  7.84100e6       'Unique: calbration m1
Const m2_SI111 =  82213           'Unique: calbration m2
Const b0_SI111 = -1.72150e7       'Unique: calbration b0
Const b1_SI111 =  1.85020e5       'Unique: calbration b1
Const b2_SI111 =  13114           'Unique: calbration b2

'*** Beginning of SI-111 precision infrared radiometer wiring***
'9H      SI111 target signal (red)
'9L      SI111 target signal reference. Jump to gnd (black)
'gnd     Shield (clear)

'10H     SI111 body temperature signal (green)
'gnd     SI111 body temperature signal reference (blue)
'VX2     SI111 voltage excitation (white)
'***     Beginning of SI-111 precision infrared radiometer   ***
#EndIf
#If (SENSOR_TCAV) Then

Const TCAV_ANALOG_INPUT = 11         'Staring differential analog input channel for TCAV.
Const NMBR_TCAV         = 2          'Unique: number of TCAV (Maximum is 2)

'*** Beginning of TCAV wiring ***
'11H     Signal #1 (purple)
'11L     Signal reference #1 (red)
'gnd     Shield #1 (clear)

'12H     Signal #2 (purple)
'12L     Signal reference #2 (red)
'gnd     Shield #2 (clear)
'*** End of TCAV wiring ***
#EndIf
#If (SENSOR_CS6XX) Then

Const NMBR_CS6xx = 2                'Unique: number of CS616, CS650, or CS655 sensors (Maximum is 2)

#If (SENSOR_CS616) Then

Const CS616_ANALOG_INPUT = 25       'Starting single-ended analog input channel.
Const CS616_POWER_CTRL   = 4        'Unique: control port for CS616.
'*** Beginning of CS616 wiring ***
'13H     Signal #1 (green)
'13L     Signal #2 (green)
'C4      Power control #1 (orange)
'        Power control #2 (orange)
'G       Shield #1 (clear)
'        Shield #2 (clear)

'12V     Power #1 (red)
'        Power #2 (red)
'G       Signal reference #1 (black)
'        Signal reference #2 (black)
'*** End of CS616 wiring ***
#EndIf
#If (SENSOR_CS65X) Then

Const CS65X_SDI12_PORT      = 5        'Control port.
Const CS65X_SDI12_Address_1 = 1        'Unique: SDI address for CS655 #1
#If (NMBR_CS6xx = 2) Then
Const CS65X_SDI12_Address_2 = 2        'Unique: SDI address for CS655 #2
#EndIf
'*** Beginning of CS65X wiring ***
'C5      SDI-12 data #1 (green)
'        SDI-12 data #2 (green)
'G       RS-232 Rx #1 (orange)
'        RS-232 Rx #2 (orange)

'12V     SDI-12 power #1 (red)
'        SDI-12 power #2 (red)
'G       SDI-12 data/power reference #1 (black)
'        Shield #1 (clear)
'        SDI-12 data/power reference #2 (black)
'        Shield #2 (clear)
'*** End of CS65X wiring ***
#EndIf
#EndIf
#If (SENSOR_TMPR_RH) Then

Const TMPR_RH_ANALOG_INPUT = 27     'Single-end analog input channel for temperature and humidity probe.
Const TMPR_RH_MULT = (100-0)/1000   'Unique: RH multiplier, all models = 0.1
Const TMPR_RH_OFFSET = 0            'Unique: RH offset, all models = 0

#If (SENSOR_HMP155A) Then
Const TMPR_RH_T_MULT   = (60 - -80)/1000  'Unique: temperature multiplier HMP155A = 0.14
Const TMPR_RH_T_OFFSET = -80              'Unique: temperature offset HC2S3 = -40, HMP155A = -80, or HMP45C = -40.
#EndIf
#If (SENSOR_HC2S3 OR SENSOR_HMP45C) Then
Const TMPR_RH_T_MULT   = (60 - -40)/1000  'Unique: temperature multiplier HC2S3 = 0.1
Const TMPR_RH_T_OFFSET = -40              'Unique: temperature offset HC2S3 = -40
#EndIf

'*** Beginning of HC2S3 or HMP wiring ***
'14H     Temperature signal (brown/yellow)
'gnd     Signal reference (yellow/white)

'14L     Relative humidity signal (white/blue)
'gng     jumper wire to 14L
'gnd     Shield (clear/clear)

'12V     Power (green/red)
'G       Power reference (gray/black)
'*** End of HC2S3 or HMP wiring ***
#EndIf
#If (SENSOR_TE525x) Then

Const TE525_PULSE_INPUT = 1          'Pulse input channel rain gauge.

#If (SENSOR_TE525MM) Then
Const TE525_MULT = 0.1        'Unique: multiplier for TE525MM
#EndIf
#If (SENSOR_TE525 OR SENSOR_TE525WS) Then
Const TE525_MULT = 0.254      'Unique: multiplier for TE525 & TE525WS
#EndIf
#If (SENSOR_TE525_wf) Then
Const TE525_MULT = 0.1459     'Unique: multipler for TE525 or TE525MM w/ 8in funnel
#EndIf

'*** Beginning of TE525x wiring ***
'P1      Precipitation (black)
'gnd     Signal reference (white)
'gnd     Shield (clear/clear)
'*** End of TE525mm wiring ***
#EndIf

'POWER IN
'12V     datalogger (red)
'G       datalogger (black)

'EXTERNAL POWER SUPPLY
'+12V    datalogger (red)
'G       datalogger (black)
'***** End Wiring Instruction *****


'*** Beginning station constants and variables ***.
Const SCAN_INTERVAL              = 100           'Unique: measurement rate 100 ms (10 Hz), 200 ms (5 Hz), or 1000 ms (1 Hz) (For this CR3K program, the shortest scan interval is 100 ms)
Const SLOWSEQUENCE_SCAN_INTERVAL = 5000          'Unique: slow sequence measurement rate (ms) (For this CR3K program, the shortest scan interval is 2000 ms)
Const OUTPUT_INTERVAL            = 30            'Unique: online flux data output interval (minutes).
Const NMBR_DAY_CPU               = 7             'Number of days for flux data to store on the CPU.
Const NMBR_DAY_FLUX_CRD          = 30            'Unique: number of days of Flux and Flux_Notes table data to store in each file on the card.  Number of files stored depends on card size.
Const NMBR_DAY_TIMESERIES_CRD    = 1             'Unique: number of days of Time_Series table data to store in each file on the card (days). Number of files stored depends on card size.
Const SDM_PER                    = 30            'Unique: default SDM clock speed (uS).
Const EC100_SDM_ADDR             = 1             'Unique: SDM address for EC100.

Const ANALOG_INTEGRATION         = _60Hz         'Unique: slowsequence analog measurement integration time, _60Hz (e.g. in US, Canada, etc.) or _50Hz (e.g. in Europe, China, etc.)

Const NMBR_STN_VAR               = (16 - 3*SENSOR_FW -3*((SENSOR_HFP) AND  (SENSOR_CS6XX) AND ((SENSOR_TCAV) OR (SENSOR_CS65X))))            'Number of station variables below

Public stn_conf_array(NMBR_STN_VAR)              'These station parameters are entered using the datalogger keypad after program has compiled and is running.
Alias stn_conf_array(1)  = sonic_azimuth         'Azimuth angle (degrees) (see Section 3.2.1 CSAT3A Azimuth in the OPEC manual).
Alias stn_conf_array(2)  = latitude              'Latitude (degrees)
Alias stn_conf_array(3)  = hemisphere_NS         '"1" for north and "-1" for south, following GPS convention
Alias stn_conf_array(4)  = longitude             'Longitude (degrees)
Alias stn_conf_array(5)  = hemisphere_EW         '"1" for east and "-1" for west, following GPS convention
Alias stn_conf_array(6)  = height_measurement    'Measurement height (m)
Alias stn_conf_array(7)  = displacement_user     'User-entered displacement height (m) [If 0 (default), then auto calculate]
Alias stn_conf_array(8)  = height_canopy         'canopy height (m).
Alias stn_conf_array(9)  = surface_type          'crop = 1, grass = 2, forest = 3, shrub = 4, bare land = 5, and water = 6
Alias stn_conf_array(10) = roughness_user        'User-entered roughness length (m) [If 0 (default), then auto calculate and continuously updated by recalculation when netrual stratification]
Alias stn_conf_array(11) = separation_x_irga     'x coordinate of IRGA optical path center along the sonic x-coordinate axis (m)
Alias stn_conf_array(12) = separation_y_irga     'y coordinate of IRGA optical path center along the sonic y-coordinate axis (m)
Alias stn_conf_array(13) = dist_intrst_60_300    'Distance of interest for wind directions 0~60 and 300~360 degrees in sonic coordinate system (m)
Alias stn_conf_array(14) = dist_intrst_60_170    'Distance of interest for wind directions >60 and <=170 degrees in sonic coordinate system (m)
Alias stn_conf_array(15) = dist_intrst_170_190   'Distance of interest for wind directions >170 and <190 degrees in sonic coordinate system (m)
Alias stn_conf_array(16) = dist_intrst_190_300   'Distance of interest for wind directions >=190 and <300 degree in sonic coordinate system (m)

Units sonic_azimuth       = degrees
Units latitude            = degrees
Units hemisphere_NS       = unitless
Units longitude           = degrees
Units hemisphere_EW       = unitless
Units height_measurement  = m
Units displacement_user   = m
Units height_canopy       = m
Units surface_type        = unitless
Units roughness_user      = m
Units separation_x_irga   = m
Units separation_y_irga   = m
Units dist_intrst_60_300  = m
Units dist_intrst_60_170  = m
Units dist_intrst_170_190 = m
Units dist_intrst_190_300 = m

#If (SENSOR_FW) Then
Alias stn_conf_array(17) = separation_x_FW      'Coordinate x of FW junction in the sonic coordinate system (m)
Alias stn_conf_array(18) = separation_y_FW      'Coordinate y of FW junction in the sonic coodinate system (m)
Alias stn_conf_array(19) = FW_diameter          'Diameter of fine wire (m)
Units separation_x_FW = m
Units separation_y_FW = m
Units FW_diameter     = m
#EndIf

#If ((SENSOR_HFP) AND  (SENSOR_CS6XX) AND ((SENSOR_TCAV) OR (SENSOR_CS65X))) Then
Alias stn_conf_array(17 - 3*SENSOR_FW) = soil_bulk_density   'Soil bulk density (kg/m^3)
Alias stn_conf_array(18 - 3*SENSOR_FW) = Cds                 'Specific heat of dry mineral soil [J/(kg K)] [Table 8.2 on page 118 in Campbell & Norman (1998)]
Alias stn_conf_array(19 - 3*SENSOR_FW) = thick_abv_SHFP      'Thickness of soil above soil heat flux plate (m)
Units soil_bulk_density  = kg/m^3
Units Cds               = J/(kg k)
Units thick_abv_SHFP     = m
#EndIf

Dim stn_conf_array_prev(NMBR_STN_VAR)            'Hold previous station parameters to check for new user-entered values

'After user input, used to assign a sign to latitude and longitude
Const Hemisphere_North =  1
Const Hemisphere_South = -1
Const Hemisphere_East  =  1
Const Hemisphere_West  = -1

'Used to assign a value for surface_type
Const CROP     = 1
Const GRASS    = 2
Const FOREST   = 3
Const SHRUB    = 4
Const BARELAND = 5
Const WATER    = 6

Dim surface_type_array(6)   As String * 9 = {"Crop", "Grass", "Forest", "Shrub", "Bare land", "Water"}
Dim surface_type_text As String * 9   'Used to record the surface type in data table

#If (SENSOR_FW) Then
Const FW05DIA  = 1.27e-5              'Diameter of FW05 fine wire that is selected for FW diameter(m)
Const FW1_DIA  = 2.54e-5              'Diameter of FW1 fine wire that is selected for FW diameter(m)
Const FW3_DIA  = 7.62e-5              'Diameter of FW3 fine wire that is selected for FW diameter(m)
#EndIf

Dim stn_var_check_count As Long       'Working variable to count loops to check one of the station variables every slow sequence scan for a change in value, initiated by the user from keypad or loggerNet connection.
'*** End of station constants and variables ***.

'*** Beginning general constants for CR3K ***
Const OFFSET           = 17                           'An offset delay (instrument scan lags) that will be introduced to the eddy covariance data used to compute online fluxes.
Const SCAN_BUFFER_SIZE = 290*INT (1000/SCAN_INTERVAL) 'Compute a 290-second scan buffer (The buffer less than 5 minutes is required because of 5-minute interval for data tables used in QC.

Const FLUX_SIZE_CPU    = Ceiling ((NMBR_DAY_CPU*1440)/OUTPUT_INTERVAL) 'Size of flux data table on CPU [(days*1440 minutes/day)/(minutes/record)] = records].
'***  End of general constants for CR3K ***

'*** Beginning constants and variables for atmospheric physics [Unless noted, see page 467 in Wallace and Hobbs (2006)] ***
Const Cpd     = 1004               'specific heat of dry air at constant pressure [J/(kg K)]
Const Cpw     = 1952               'specific heat of water vapor at constant pressure [J/(kg K)]
Const Cw      = 4218               'specific heat of liquid water at 0 C [J/(kg K)]
Const epsilon = 18.016/28.97       'molecular mass ratio of water vapor to dry air
Const g0      = 9.81               'acceleration due to gravity at sea level (m/s^2)
Const k       = 0.41               'von Karman constant (Dyer & hicker 1970, Webb 1970)
Const MU_WPL  = 28.97/18.016       'molecular mass ratio of dry air to water vapor (used in WPL correction)
Const Omega   = 7.292e-5           'Angular velocity of the earth for calculation of Coriolis Force (2PI/sidreal_day, where sidereal day = 23 hr 56 min. [rad/s]
Const R       = 8.3143e-3          'Universal gas constant [kPa m^3/(K mol)]
Const Rd      = R/28.97            'Gas constant for dry air [kPa m^3/(K g)]
Const Rv      = R/18.016           'Gas constant for water vapor [kPa m^3/(K g)]
Const PI      = 3.1415926          'Pi (just use the seven digits after decimal, commonly used)
Const T_0C_K  = 273.15             'Temperature in K when it is zero in C

Public Cp                          'specific heat of moist air at constant pressure, calculated using measurements from EC100 data [J/(kg C)]
Units  Cp = J/(kg C)

Public Lv                          'Latent heat of vaporization, calculated using air temperature [J/g].
Units  Lv     = J/g
'*** End of constants and variables for atmospheric physics ***

'*** Beginning program working variables ***
Dim scan_count                As Long        'Number scans executed. Working variable used to judge the scan loop, from which data processing starts.

Dim slowsequence_finished_flg As Boolean     'Flag used to indicate that the slowSequence has finished its scan.
Dim slowsequence_disable_flg  As Boolean     'Flag used to decimate statistics in main scan.

Dim sys_conf_var_file         As Long        'Filehandle for the file that contains the system configuration variables in the CPU.

Dim i, i_slow                 As Long        'Index variables for the outmost loop. "i" in main scan and "i_slow" in slow scan sequence
Dim array_index               As Long        'Used for array index that must be calculated using loop index (to simplify expression and reduce computation for array index)

Dim n = 1                                    'Used for counting the number of samples
Units n = samples

Dim dly_data_out(7)                          'Array used to temporarily store the lagged record from the raw data table (hidden)

Dim x_tmp                                    'Temporary variable used in intermediate calculations

Dim process_time                             'Used to monitor processing time and reported in flux_notes table
Units process_time = ms                      'Converted from us to ms that is easy to read

Dim buff_depth                               'Used to monitor buffer depth and reported in flux_notes table
Units buff_depth = scans
'*** End program working variables ***

'*** Beginning datalogger self-measurement variables ***
Public panel_tmpr
Units  panel_tmpr = C

Public batt_volt
Units  batt_volt  = V
'*** End of datalogger self-measurement variables ***

'*** Beginning of correction constants and variables ***
' Rotation angles from the instrument to the natural flow coordinate system. Notation is consistent with Wilczak et al (2001)
Public alpha                                'Angle of counterclockwise rotation about y-axis (pich)
Public beta                                 'Angle of counterclockwise rotation about x-axis (roll)
Public gamma                                'Angle of counterclockwise rotation about z-axis (yaw)
Units  alpha = degrees
Units  beta  = degrees
Units  gamma = degrees

Public alpha_5min                            '5-minute data for data QC. Angle of counterclockwise rotation about y-axis (pich)
Public beta_5min                             '5-minute data for data QC. Angle of counterclockwise rotation about x-axis (roll)
Public gamma_5min                            '5-minute data for data QC. Angle of counterclockwise rotation about z-axis (yaw)
Units  alpha_5min = degrees
Units  beta_5min  = degrees
Units  gamma_5min = degrees

' Rotation angles for planar fit rotations
'1) Program chooses planar fit rotation of Wilczak et al. (2001) if one of the following eigtht angles is not zero.
'2) Program chooses conventional rotation of Tanner and Thurtell (1969) if the following eight angles are all zero.

Dim planar_fit_angle_array_prev(4,2)                   'Remembering variable: Hold previous angles for Planar Fit

Public planar_fit_angle_array(4,2)                     'Hold angles for Planar Fit
Units  planar_fit_angle_array      = degrees

' Alpha_PF_xxx_xxx angle between instrument and natural flow z-axis in the instrument x-z plane.
Alias planar_fit_angle_array (1,1) = alpha_PF_60_300   'for wind direction of 0~60  and 300~360 degrees in the sonic coordinate system [degrees]
Alias planar_fit_angle_array (2,1) = alpha_PF_60_170   'for wind direction of >60   and <=170 degrees in the sonic coordinate system [degrees]
Alias planar_fit_angle_array (3,1) = alpha_PF_170_190  'for wind direction of >170  and <190 degrees in the sonic coordinate system [degrees]
Alias planar_fit_angle_array (4,1) = alpha_PF_190_300  'for wind direction of >=190 and <300 degree in the sonic coordinate system [degrees]

' Betal_PF_xxx_xxx angle between instrument and natural flow z-axis in the instrument y-z plane.
Alias planar_fit_angle_array (1,2) = beta_PF_60_300    'for wind direction of 0~60  and 300~360 degrees in the sonic coordinate system [degrees]
Alias planar_fit_angle_array (2,2) = beta_PF_60_170    'for wind direction of >60   and <=170 degrees in the sonic coordinate system [degrees]
Alias planar_fit_angle_array (3,2) = beta_PF_170_190   'for wind direction of >170  and <190 degrees in the sonic coordinate system [degrees]
Alias planar_fit_angle_array (4,2) = beta_PF_190_300   'for wind direction of >=190 and <300 degree in the sonic coordinate system [degrees]

Public Planar_Fit_flg As Boolean                       'TRUE if Planar Fit is used (e.g. any element of planar_fit_angle_array() is not zero)

' Atmospheric stability
Public L                                               'Obukhov length (m)
Public d                                               'displacement height (m)
Public z0                                              'roughness length (m)
Public z                                               'aerodynamic height: z = measurement height - d  (m)
Public z_prev                                          'Used to judge whether or not the distance of interest needs to be re-evaluated after z is recalculated 
Public stability_zL                                    'atmospheric surface-layer stability (dimensionless)
Public stability_zL_prev                               'remembering variable: previous atmospheric Surface-layer stability to remember stability_zL (dimensionless)
Units  L  = m
Units  d  = m
Units  z0 = m
Units  z  = m
Units  stability_zL = unitless

' Frequency (freq) correction
Public iteration_FreqFactor As Long   'count iterations while correcting wu, wv, and wTs for accurate Obukhov length
Public FreqFactor_uw_vw                'freq correction factor for covariance of vertical with horizontal wind that are measured using sonic
Public FreqFactor_uw_vw_Prev           'Remembering variable: previous freq correction factor for covariance of vertical with horizontal wind that are measured using sonic
Public FreqFactor_wTs                  'freq correction factor for covariance of vertical wind with sonic temperature that are measured using sonic
Public FreqFactor_wTs_Prev             'remembeing variable: previous freq correction factor for covariance of vertical wind with sonic temperature that are measured using sonic
Public FreqFactor_wCO2_wH2O            'freq correction factor for covariance of vertical wind with IRGA h2o or co2 that are measured using CSI sonic
Units FreqFactor_uw_vw     = unitless
Units FreqFactor_wTs       = unitless
Units FreqFactor_wCO2_wH2O = unitless

#If (SENSOR_FW) Then
Public FreqFactor_wFW                  'freq correction factor for covariance of vertical wind with temperature that are measured using sonic and FW
Units  FreqFactor_wFW = unitless
#EndIf

' Constants used for numerical integration in calculating the freq correction factors
Const START_FREQ           = 10e-6     'Starting cyclic freq for numerical integration of cospectrum times transfer function
Const END_FREQ             = 10000     'Ending cyclic freq for numerical integration of cospectrum times transfer function
Const FREQ_BIN             = 100       'The number of bins for cyclic freq
Const STEP_BASE_FREQ       = EXP((LN(END_FREQ)- LN(START_FREQ))/FREQ_BIN)   'freq interval base for numerical integration of cospectra and transfer functions (e.g. 100 bins from 0.000001 to 10000 Hz).
Const ACCURACY_FREQ_FACTOR = 0.0001    'The accuracy target of freq factor to approach the "true" value (|current freq factor - previous freq factor|) [page 106: Foken et al. (2012)]
Const MAX_LAG              = 2         'Maximum number of lags in scans that is used to maximizing the covariance. This number of 2 is believed to be adequate for sonic with EC150 and/or FW

' ------ Numerical wTs transfer function Dijk (2002): alternatively kl and transfer function value where k is wavenumber and l is path length ------
Dim tran_func_LA_data_Dijk(2,35) 'Hold following numerical values of transfer function of line averaging for wTs of CSAT3 measurements from Table 1 in Dijk (2012)
Data 0.00, 1.00000, 0.01, 1.00000, 0.10, 0.99920, 0.20, 0.99760, 0.50, 0.99000, 1.00, 0.96700, 1.20, 0.95500, 1.40, 0.94170, 1.60, 0.92740
Data 1.80, 0.91220, 2.00, 0.89620, 2.20, 0.87970, 2.40, 0.86260, 2.60, 0.84520, 2.80, 0.82740, 3.00, 0.80960, 4.00, 0.72010, 5.00, 0.63530
Data 6.00, 0.55880, 7.00, 0.49220, 8.00, 0.43550, 9.00, 0.38790, 10.0, 0.34810, 14.0, 0.24450, 20.0, 0.17000, 30.0, 0.11340, 40.0, 0.08503
Data 50.0, 0.06802, 60.0, 0.05668, 70.0, 0.04859, 80.0, 0.04251, 90.0, 0.03779, 100,  0.03401
Data 300, 1.16e-4, 10000, 1.16e-4 ' The data points were extended to kl= 300 and 10000 according to the numerical derivative of transfer function with respect to kl from kl= 70 to 100.
' ----------------------------------------- End of numerical wTs transfer function values from Dijk (2002) ------------------------------------------
'*** End of correction constants and variables ***

'*** Beginning of EC100 configure, zero, and span constants and variables, and subroutine ***
Const BANDWIDTH             = 20  'Unique: in Hz. For spectral analysis, set to 1/2 sampling freq. Options: 5, 10, 12.5, 20, or 25 Hz. For flux only, set 20 Hz (default)
Const DIFFERENTIAL_PRESSURE = 0   'Unique: 0 = disabled. Not applicable to an OPEC system. Should be disabled
Const TEMPERATURE_SOURCE    = 0   'Unique: 0 = defaut EC100 temperature probe
Const BB                    = 0   'Unique: BB = 0 for EC100 built-in basic pressure transducer
Const EB                    = 2   'Unique: EB = 2 for EC100 added enhanced pressure transducer
Const HEATER                = -2  'Unique: -1--> heater off, -2--> heater auto
Public press_source         = BB  'Unique: Defaut pressure transducer (EC100 built-in basic pressure transducer)

Public CO2_span_gas               'CO2 standard gas for CO2 span (umol/mol, read from the CO2 gas cilinder bottle)
Public Td_span_gas                'Dew point temperaure for H2O span (C, read from the Dew Point generator)

Dim config_array       (4, 2) = {0, BANDWIDTH, 3, DIFFERENTIAL_PRESSURE, 7, TEMPERATURE_SOURCE, 18, HEATER}
Dim press_source_array (1, 2) = {2, BB}         '1st col 2--> barometer set commend, 2nd col  pressure source, BB=0--> EC100 built-in basic pressure transducer, EB=2 enhanced pressure transducer.
Dim zero_array         (1, 2) = {11, 1}         'Used for zeroing operation: 1st col 11--> Zero/Span command, 2nd col 0--> Inactive, 1--> Zero, 2--> SpanCO2, 3--> SpanH2O .
Dim span_CO2_array     (2, 2) = {12, 0, 11, 2}  'Used for CO2 span operation: 1st col 12->CO2 span concentration, 2nd col CO2 span value (0 as default). 3rd and 4th cols are zero_array above.
Dim span_H2O_array     (2, 2) = {13, 0, 11, 3}  'Used for H2O span operation: 1st col 13->H2O span dew point temperature,2nd col dew point temperature (0 as default). 3rd and 4th cols are zero_array above.
Dim heater_option_array(1, 2) = {18, HEATER}    '1st col 18 control heaters for lenses of gas analyzer, 2nd col HEATER = -1 off, HEATER = -2 auto to set 0 ~ 4.5375 V
Dim EC150_power_array  (1, 2) = {21, 0}         'Used for power off IRGA (not for EC100): 1st col 21 control power commend and 2nd col 0 --> power off IRGA

Dim    configure_ec100_flg  As Boolean = TRUE   'Default: Configure EC100 as soon as this program starts
Public set_press_source_flg As Boolean
Public do_zero_flg          As Boolean
Public do_CO2_span_flg      As Boolean
Public do_H2O_span_flg      As Boolean
Public set_heater_flg       As Boolean
Dim    EC150_power_flg      As Boolean
Dim    NAN_cnt              As Long

Sub Config (cmd_array(4, 2), num_cmd As Long, retry_config_flg As Boolean)
  Dim kk             As Long
  Dim config_result  As Long
  Dim save_flash_flg As Boolean

  For kk = 1 To num_cmd
    EC100Configure (config_result, EC100_SDM_ADDR, cmd_array(kk,1), cmd_array(kk,2))
    If (config_result = NAN) Then ExitFor
    If (cmd_array(kk,1) = 2) OR (cmd_array(kk,1) = 11) Then save_flash_flg = TRUE            ' Save the setting for pressure transducer, zero/span
  Next kk

  If (kk = num_cmd + 1) Then
    If (save_flash_flg) Then EC100Configure (config_result, EC100_SDM_ADDR, 99, 2718)
    If (config_result <> NAN) Then retry_config_flg = FALSE
  EndIf

  SetStatus ("SkippedScan", 0)
  save_flash_flg = FALSE
EndSub
'*** End of EC100 configure, zero, and span constants and variables, and subroutine ***

'*** Beginning of sonic head constants, variables, and working data table ***
Const PATH_LENGTH_CSAT = 0.1154701       'sonic path length = 10 cm/sin(2pi/3) (m)

Public sonic(5)                          'Hold sonic data aligned in scan with data from IRGA and/or
Alias  sonic(1) = Ts
Alias  sonic(2) = Ux
Alias  sonic(3) = Uy
Alias  sonic(4) = Uz
Alias  sonic(5) = diag_sonic
Units  Ts = C
Units  Ux = m/s
Units  Uy = m/s
Units  Uz = m/s
Units  diag_sonic = unitless

Dim   diag_bits_sonic(6) As Boolean        'Sonic warning flags
Alias diag_bits_sonic(1) = sonic_amp_l_f   'Amplitude low warning flag
Alias diag_bits_sonic(2) = sonic_amp_h_f   'Amplitude high warning flag
Alias diag_bits_sonic(3) = sonic_sig_lck_f 'Poor signal lock warning flag
Alias diag_bits_sonic(4) = sonic_del_T_f   'Delta temperature warning flag
Alias diag_bits_sonic(5) = sonic_aq_sig_f  'Sonic acquiring signals warning flag
Alias diag_bits_sonic(6) = sonic_cal_err_f 'Signature error in reading sonic head calibration data
Units diag_bits_sonic    = unitless

Dim sonic_irga_raw(12)                     'Hold the first 12 data of EC100 from sonic, IRGA, temperature sensor, and barometer (raw data before applying instrument scan lag).

Dim diag_sonic_tmp  As Long                'Working variable used to break out the sonic head diagnostic bits.
Dim sonic_disable_f As Boolean             'TRUE when any sonic diagnostic warning flag is on, sonic has not sent data, or an SDM signature error is reported.
Dim mask            As Long                'Masking the diagnosis code.
Dim Ts_K                                   'Sonic temperature in K.

Dim cov_out_sonic(19)                      'sonic statistics.
Alias cov_out_sonic(1)  = Ux_Avg
Alias cov_out_sonic(2)  = Ux_Std
Alias cov_out_sonic(3)  = UxUy_Cov
Alias cov_out_sonic(4)  = UxUz_Cov
Alias cov_out_sonic(5)  = Uy_Avg
Alias cov_out_sonic(6)  = Uy_Std
Alias cov_out_sonic(7)  = UyUz_Cov
Alias cov_out_sonic(8)  = Uz_Avg
Alias cov_out_sonic(9)  = Uz_Std
Alias cov_out_sonic(10) = Ts_Avg
Alias cov_out_sonic(11) = Ts_Std          'Ts standard deviation is stored here. Unlike standard deviation of momentum variable, it is not related to coordinate rotation
Alias cov_out_sonic(12) = TsUx_Cov
Alias cov_out_sonic(13) = TsUy_Cov
Alias cov_out_sonic(14) = TsUz_Cov
Alias cov_out_sonic(15) = wnd_spd
Alias cov_out_sonic(16) = rslt_wnd_spd
Alias cov_out_sonic(17) = wnd_dir_sonic   'wind direction of 0 to 360 degree in the sonic coordinate system, equal to Gamma in coordination rotation.
Alias cov_out_sonic(18) = std_wnd_dir
Alias cov_out_sonic(19) = wnd_dir_compass 'wind direction in compass convention
Units Ux_Avg          = m/s
Units Ux_Std          = m/s
Units UxUy_Cov        = (m/s)^2
Units UxUz_Cov        = (m/s)^2
Units Uy_Avg          = m/s
Units Uy_Std          = m/s
Units UyUz_Cov        = (m/s)^2
Units Uz_Avg          = m/s
Units Uz_Std          = m/s
Units Ts_Avg          = C
Units Ts_Std          = C
Units TsUx_Cov        = C m/s
Units TsUy_Cov        = C m/s
Units TsUz_Cov        = C m/s
Units wnd_spd         = m/s
Units rslt_wnd_spd    = m/s
Units wnd_dir_sonic   = degrees
Units std_wnd_dir     = degrees
Units wnd_dir_compass = degrees

' Variables after coordinate rotations as indicated by the last letter of "R"
' 3D wind components before coordinate roations are Ux, Uy, and Uz, and afterwards they are referred to as u, v, and w, respectively.

Dim u_star_R            'Friction velocity after coordinate rotations
Dim u_Avg_R
Dim u_Std_R
Dim uv_Cov_R
Dim uw_Cov_R
Dim v_Avg_R
Dim v_Std_R
Dim vw_Cov_R
Dim w_Avg_R
Dim w_Std_R
Dim uTs_Cov_R
Dim vTs_Cov_R
Dim wTs_Cov_R

Units u_star_R  = m/s
Units u_Avg_R   = m/s
Units u_Std_R   = m/s
Units uv_Cov_R  = (m/s)^2
Units uw_Cov_R  = (m/s)^2
Units v_Avg_R   = m/s
Units v_Std_R   = m/s
Units vw_Cov_R  = (m/s)^2
Units w_Avg_R   = m/s
Units w_Std_R   = m/s
Units uTs_Cov_R = C m/s
Units vTs_Cov_R = C m/s
Units wTs_Cov_R = C m/s

Public TKE                           'specific turbulence kinetic energy
Units  TKE = m^2/s^2                 '[kg (m/s)^2]/kg

' Variables after coordinate rotations (R) and freq corrections (F) as indicated by last two letters of "R_F"
Dim tau                              'Drag force (stress) at surface (momentum flux) after coordinate rotations and freq corrections.
Dim u_star                           'Friction velocity after coordinate rotations and freq corrections.
Dim wTs_Cov_R_F
Dim uw_Cov_R_F
Dim vw_Cov_R_F

Units tau         = (kg m/s)/(m^2 s)  'Equivalent to kg m^-3/(m/s)^2
Units u_star      = m/s
Units wTs_Cov_R_F = C m/s
Units uw_Cov_R_F  = (m/s)^2
Units vw_Cov_R_F  = (m/s)^2

Public wTs_Cov_R_F_SND             'Covariance of sonic temperature with vertical velocity after rotation, freq, and SND corrections
Public T_star                      'Scaling temperature
Public H                           'Sensible heat flux: Derived from covariance of sonic temperatur after rotation, freq, and SND corrections
Units  wTs_Cov_R_F_SND = C m/s
Units  T_star  = C
Units  H      = W/m^2

'*** Data quality classification: Constant and variables
Const OUTPUT_INTERVAL_SST = 5      'Sub-interval to calculate the statistics for Steady State Test (SST) [minutes]

' Steady State Test (SST)
Public RN_uw_vw_cov_R              'Relative Non-Stationarity (RN) for momentum covariance (uw_cov_R and vw_cov_R)
Public RN_uw_cov_R                 'Relative non-Stationarity for uw_cov_R. It is also used for the sum of uw_cov_SST from 5-min sub-intervals
Public RN_vw_cov_R                 'Relative non-Stationarity for vw_cov_R. It is also used for the sum of vw_cov_SST from 5-min sub-intervals
Public RN_wTs_cov_R                'Relative non-Stationarity for wTs_cov_R. It is also used for the sum of wTs_cov_SST from 5-min sub-intervals
Public nmbr_interval_qc_csat       'Number of sub-intervals = (OUTPUT_INTERVAL in min)/(5 min) if not a 1st interval or CR3K starts before 5 min after an individual interval

Dim cov_out_sonic_SST(17)          'sonic head statistics for Steady State Test (SST)
Alias cov_out_sonic_SST(1)  = u_Avg_SST
Alias cov_out_sonic_SST(2)  = uu_Cov_SST
Alias cov_out_sonic_SST(3)  = uv_Cov_SST
Alias cov_out_sonic_SST(4)  = uw_Cov_SST
Alias cov_out_sonic_SST(5)  = v_Avg_SST
Alias cov_out_sonic_SST(6)  = vv_Cov_SST
Alias cov_out_sonic_SST(7)  = vw_Cov_SST
Alias cov_out_sonic_SST(8)  = w_Avg_SST
Alias cov_out_sonic_SST(9)  = ww_Cov_SST
Alias cov_out_sonic_SST(10) = TsTs_Cov_SST
Alias cov_out_sonic_SST(11) = uTs_Cov_SST
Alias cov_out_sonic_SST(12) = vTs_Cov_SST
Alias cov_out_sonic_SST(13) = wTs_Cov_SST
Alias cov_out_sonic_SST(14) = wnd_spd_SST
Alias cov_out_sonic_SST(15) = rslt_wnd_spd_SST
Alias cov_out_sonic_SST(16) = wnd_dir_sonic_SST  'wind direction in sonic coordinate system (0 to 360 degree)
Alias cov_out_sonic_SST(17) = std_wnd_dir_SST

' Steady State Test after coordinate rotations
Dim u_Avg_SST_R
Dim uu_Cov_SST_R
Dim uv_Cov_SST_R
Dim uw_Cov_SST_R
Dim v_Avg_SST_R
Dim vv_Cov_SST_R
Dim vw_Cov_SST_R
Dim w_Avg_SST_R
Dim ww_Cov_SST_R
Dim uTs_Cov_SST_R
Dim vTs_Cov_SST_R
Dim wTs_Cov_SST_R

' Data quality grading
Public tau_qc_grade                             'Overall grade of data QC for momentum flux (i.e. for variable: tau) [1 (highest) to 9 (lowest)]
Public H_qc_grade                               'Overall grade of data QC for sensible heat flux (i.e. for variable: H) [1 (highest) to 9 (lowest)]
Units tau_qc_grade = Grade
Units H_qc_grade   = Grade

'*** Footprint characteristics: Constant and variables ***
' Footprint characteristics
Const  NMBR_INT_INTERV_SEGMENT = 20            'Unique: Base number of numerical integration intervals for footprint characteristics in each integration segment

Public upwnd_dist_intrst                       'Upwind distant of interest
Public FP_dist_intrst                          'Cumulative footprint of measured scalar flux within upwind range of interest
Public FP_max                                  'Upwind location of source/sink that contributes most to the measured flux
Public FP_40                                   'Upwind range within which the source/sink contributes 40% to the measured flux
Public FP_55                                   'Upwind range within which the source/sink contributes 55% to the measured flux
Public FP_90                                   'Upwind range within which the source/sink contributes 90% to the measured flux
Units upwnd_dist_intrst = m
Units FP_dist_intrst    = %
Units FP_max = m
Units FP_40  = m
Units FP_55  = m
Units FP_90  = m

Public FP_Equation As String * 14               '"Kljun et al" or "KormannMeixner"
Units  FP_Equation = authors

'Raw data table
DataTable (delay_3d, TRUE, OFFSET)
  TableHide
  Sample (5, sonic_irga_raw(1), IEEE4)
EndTable

' 5-minute covariance of sonic data for steady state tests
DataTable (comp_cov_3d_5min, TRUE, 1)
  TableHide
  DataInterval (0, OUTPUT_INTERVAL_SST, Min, 1)

  'Compute Ux mean and covariance of Ux with Ux, Uy, and Uz from sonic data.
  Average    (1, Ux, IEEE4, sonic_disable_f)      'Using sonic(2)
  Covariance (3, Ux, IEEE4, sonic_disable_f, 3)   'Using sonic(2), sonic(3), and sonic(4)

  'Compute Uy mean and covariance of Uy with, Uy, Uz from sonic data.
  Average    (1, Uy, IEEE4, sonic_disable_f)      'Using sonic(3)
  Covariance (2, Uy, IEEE4, sonic_disable_f, 2)   'Using sonic(3) and sonic(4)

  'Compute Uz mean and covariance of Uz with Uz from sonic data.
  Average    (1,Uz, IEEE4, sonic_disable_f)       'Using sonic(4)
  Covariance (1,Uz, IEEE4, sonic_disable_f, 1)    'Using sonic(4)

  'Compute covariance of Ts with Ts, Ux, Uy, and Uz from sonic data.
  Covariance (4, Ts, IEEE4, sonic_disable_f, 4)   'Using sonic(1), sonic(2), sonic(3), sonic(4)

  WindVector (1, Uy, Ux, IEEE4, sonic_disable_f, 0, 1, 2)

EndTable

' 30-minute covariance of sonic data
DataTable (comp_cov_3d, TRUE, 1)
  TableHide
  DataInterval (0, OUTPUT_INTERVAL, Min, 1)

  'Compute Ux mean and covariance of Ux with Ux, Uy, and Uz from sonic data.
  Average    (1, Ux, IEEE4,sonic_disable_f)      'Using sonic(2)
  Covariance (3, Ux, IEEE4,sonic_disable_f, 3)   'Using sonic(2), sonic(3), and sonic(4)

  'Compute Uy mean and covariance of Uy with, Uy, Uz from sonic data.
  Average    (1, Uy, IEEE4,sonic_disable_f)      'Using sonic(3)
  Covariance (2, Uy, IEEE4,sonic_disable_f, 2)   'Using sonic(3) and sonic(4)

  'Compute Uz mean and covariance of Uz with Uz from sonic data.
  Average    (1, Uz, IEEE4,sonic_disable_f)      'Using sonic(4)
  Covariance (1, Uz, IEEE4,sonic_disable_f, 1)   'Using sonic(4)

  'Compute Ts mean and covariance of Ts with Ts, Ux, Uy, and Uz from sonic data.
  Average    (1, Ts, IEEE4,sonic_disable_f)      'Using sonic(1)
  Covariance (4, Ts, IEEE4,sonic_disable_f, 4)   'Using sonic(1), sonic(2), sonic(3), sonic(4)

  WindVector (1, Uy, Ux, IEEE4, sonic_disable_f, 0, 1, 2)

EndTable
'*** End of sonic head constants, variables, and working data tables ***

'*** Beginning of IRGA constants, variables, and working data table ***
Const DELAY_EC100               = INT ((4000/BANDWIDTH)/SCAN_INTERVAL) 'Automatically compute the electronic instrument lag of EC100 data in scan number
Const EC100_REC_BCK             = OFFSET - DELAY_EC100                 'Number of records back for aligning EC100 data with other sensor data in scan
Const PATH_LENGTH_IRGA          = 0.1531                               'IRGA path length (m).
Const CO2_SIG_STRGTH_THRESHOULD = 0.7                                  'Unique: CO2 signal strength threshold below which the CO2 data are not used in instructions of AVERAGE and COVARIANCE, but kept in time series data table
Const H2O_SIG_STRGTH_THRESHOULD = 0.7                                  'Unique: H2O signal strength threshold below which the CO2 data are not used in instructions of AVERAGE and COVARIANCE, but kept in time series data table
Const CO2_RNG_TOP_LIMIT         = 1527                                 'Unique: Maximum CO2 density (mg/m^3) to which the analyzer was calibrated (factory calibration range of 0 ~ 1000 ppm CO2 in dry air at lab T = 25 C and in Logan P = 86 kPa)
Const H2O_RNG_TOP_LIMIT         = 45.8                                 'Unique: Maximum H2O density (g/m^3) to which the analyzer was calibrated (factory calibration range 0f dew point temperature: 0 to 37 C at lab T = 25 C and in Logan P = 86 kPa)

' Variables for separation corrections
Public separation_lat_dist_irga    'Effective separation distance (m) in direction normal to wind direction. Used for separation correction
Public separation_lag_dist_irga    'Effective separation distance (m) along wind direction. Used for lag maximization of covariance
Public separation_lag_scan_irga    'Lag of wind passing over IRGA (scans) after (+ lag) or before (- lag) passing sonic volume. Its unit is a scan number, but not necessary to use an integer.

Units  separation_lat_dist_irga  =  m
Units  separation_lag_dist_irga  =  m
Units  separation_lag_scan_irga  =  scans

'Data from IRGA
Public irga(14)                     'Hold IRGA data
Alias irga(1)  = CO2
Alias irga(2)  = H2O
Alias irga(3)  = diag_irga
Alias irga(4)  = amb_tmpr           'Temperature measured by temperature probe connected to EC100
Alias irga(5)  = amb_press          'Pressure measured by a barometer connected to EC100
Alias irga(6)  = CO2_sig_strgth
Alias irga(7)  = H2O_sig_strgth

Alias irga(8)  = Tc                 'Air temperature (C), found from IRGASON' sonic temperature, water vapor density, or in case of the EC150/CSAT3A Tc=amb_tmpr from EC100 T probe
Alias irga(9)  = RH                 'Relative humidity (%): derived from Tc, H2O, and amb_press
Alias irga(10) = e_sat              'Saturation vapor pressure (kPa): derived from Tc, H2O, and amb_press
Alias irga(11) = e                  'Vapor pressure (kPa): derived from Tc, H2O. and amb_press
Alias irga(12) = Td                 'Dew point temperature (C): derived from Tc, H2O, and amb_press

Alias irga(13) = CO2_mixratio       'CO2 mixing ratio
Alias irga(14) = H2O_mixratio       'H2O mixing ratio

Units CO2            = mg/m^3
Units H2O            = g/m^3
Units diag_irga      = unitless
Units amb_tmpr       = C
Units amb_press      = kPa
Units CO2_sig_strgth = fraction
Units H2O_sig_strgth = fraction
Units Tc             = C
Units RH             = %
Units e_sat          = kPa
Units e              = kPa
Units Td             = C
Units CO2_mixratio   = umol/mol
Units H2O_mixratio   = mmol/mol

Dim diag_bits_irga(22) As Boolean                'Gas analyzer warning flags
Alias diag_bits_irga(1)  = irga_bad_data_f       'EC150 bad data warning flag
Alias diag_bits_irga(2)  = irga_gen_fault_f      'General fault warning flag
Alias diag_bits_irga(3)  = irga_startup_f        'Gas analyzer starting up warning flag
Alias diag_bits_irga(4)  = irga_motor_spd_f      'EC150 motor speed out of bounds warning flag
Alias diag_bits_irga(5)  = irga_tec_tmpr_f       'Thermoelectric cooler temperature out of bounds warning flag
Alias diag_bits_irga(6)  = irga_src_pwr_f        'Gas analyzer source power out of bounds warning flag
Alias diag_bits_irga(7)  = irga_src_tmpr_f       'Gas analyzer source temperature out of bounds warning flag
Alias diag_bits_irga(8)  = irga_src_curr_f       'Gas analyzer source current out of bounds warning flag
Alias diag_bits_irga(9)  = irga_off_f            'Gas analyzer head is powered down
Alias diag_bits_irga(10) = irga_sync_f           'Gas analyzer not synchronized with home pulse warning flag
Alias diag_bits_irga(11) = irga_amb_tmpr_f       'Invalid ambient temperature warning flag
Alias diag_bits_irga(12) = irga_amb_press_f      'Invalid ambient pressure warning flag
Alias diag_bits_irga(13) = irga_CO2_I_f          'CO2 I out of bounds warning flag
Alias diag_bits_irga(14) = irga_CO2_Io_f         'CO2 Io out of bounds warning flag
Alias diag_bits_irga(15) = irga_H2O_I_f          'H2O I out of bounds warning flag
Alias diag_bits_irga(16) = irga_H2O_Io_f         'H2O Io out of bounds warning flag
Alias diag_bits_irga(17) = irga_CO2_Io_var_f     'CO2 Io moving variation out of bounds warning flag
Alias diag_bits_irga(18) = irga_H2O_Io_var_f     'H2O Io moving variation out of bounds warning flag
Alias diag_bits_irga(19) = irga_CO2_sig_strgth_f 'CO2 signal strength warning flag
Alias diag_bits_irga(20) = irga_H2O_sig_strgth_f 'H2O signal strength warning flag
Alias diag_bits_irga(21) = irga_cal_err_f        'Gas analyzer calibration data signature error
Alias diag_bits_irga(22) = irga_htr_ctrl_off_f   'Gas analyzer heater control disabled by EC100
Units diag_bits_irga     = unitless

'Working variables
Dim divisor                                 'Temporary variable used to find molar mixing ratio.
Dim diag_irga_tmp  As Long                  'Temporary variable used to break out the EC150 diagnostic bits.
Dim irga_disable_f As Boolean               'TRUE when EC150 sends bad data.

Dim sigma_wpl                               'Webb et al. sigma = density of water vapor/density of dry air.
Dim Td_gu, Tc_K                             'Working variables: Dew point temperature for general use (gu) and Tc in K.
Dim Enhance_Factor1, Enhance_Factor2        'Enhancement factors, both used for calculations of dew point temperature
Dim rho_d, rho_a                            'Dry air density and moist air density

' CO2: Lag maximization
Dim cov_array_CO2(2* MAX_LAG+1, 4)          'Arrays used to hold the CO2 data with -2, -1, 0, 1, or 2 scan lags relative to sonic data in order to find
'the lag that maximizes the covariance of CO2 with w. Once the optimum lag is found, it is also applied to
'H2O to find the maximum covariance of H2O with w because CO2 and H2O are measured using the same IRGA.
'Data are held in an array for more convenient calculation of covariances.
'Row used for lag of -2, -1, 0, 1, 2 scans. Columns used for CO2, u, v, and w.

Dim irga_bad_data_flg_array (2* MAX_LAG + 1) As Boolean
Dim CO2_bad_rng_sig_array (2* MAX_LAG + 1)   As Boolean    'Set high if CO2 out of range or CO2 signal strength below the CO2 signal strength threshould
Dim H2O_bad_rng_sig_array (2* MAX_LAG + 1)   As Boolean    'Set high if H2O out of range or H2O signal strength below the H2O signal strength threshould

Dim Cov_out_CO2(5*(2*MAX_LAG + 1))          'CO2 variable and CO2-related covariance variables
Alias Cov_out_CO2(1)  = CO2_Avg_b2          'b2 indicates backward 2 scans
Alias Cov_out_CO2(2)  = CO2CO2_Cov_lag_b2
Alias Cov_out_CO2(3)  = uCO2_Cov_lag_b2
Alias Cov_out_CO2(4)  = vCO2_Cov_lag_b2
Alias Cov_out_CO2(5)  = wCO2_Cov_lag_b2
Alias Cov_out_CO2(6)  = CO2_Avg_b1          'b1 indicates backward 1 scan
Alias Cov_out_CO2(7)  = CO2CO2_Cov_lag_b1
Alias Cov_out_CO2(8)  = uCO2_Cov_lag_b1
Alias Cov_out_CO2(9)  = vCO2_Cov_lag_b1
Alias Cov_out_CO2(10) = wCO2_Cov_lag_b1
Alias Cov_out_CO2(11) = CO2_Avg_0           '0 indicates neither backward nor forward
Alias Cov_out_CO2(12) = CO2CO2_Cov_lag_0
Alias Cov_out_CO2(13) = uCO2_Cov_lag_0
Alias Cov_out_CO2(14) = vCO2_Cov_lag_0
Alias Cov_out_CO2(15) = wCO2_Cov_lag_0
Alias Cov_out_CO2(16) = CO2_Avg_f1          'f1 indicates forward 1 scan
Alias Cov_out_CO2(17) = CO2CO2_Cov_lag_f1
Alias Cov_out_CO2(18) = uCO2_Cov_lag_f1
Alias Cov_out_CO2(19) = vCO2_Cov_lag_f1
Alias Cov_out_CO2(20) = wCO2_Cov_lag_f1
Alias Cov_out_CO2(21) = CO2_Avg_f2          'f2 indicates forward 2 scans
Alias Cov_out_CO2(22) = CO2CO2_Cov_lag_f2
Alias Cov_out_CO2(23) = uCO2_Cov_lag_f2
Alias Cov_out_CO2(24) = vCO2_Cov_lag_f2
Alias Cov_out_CO2(25) = wCO2_Cov_lag_f2

' Variables after coordinate rotations as indicated by last letter "R"
Dim   wCO2_Cov_lag_R (2*MAX_LAG + 1)                  'Hold covariance of scan-lagged CO2 with w after coordinate rotation. Used for MaxSpa instruction
Alias wCO2_Cov_lag_R (1) = wCO2_Cov_lag_b2R           'b2R indicates backward 2 scans and after rotation
Alias wCO2_Cov_lag_R (2) = wCO2_Cov_lag_b1R           'b1R indicates backward 1 scans and after rotation
Alias wCO2_Cov_lag_R (3) = wCO2_Cov_lag_0R            '0R indicates 0 lag in scans and after rotation
Alias wCO2_Cov_lag_R (4) = wCO2_Cov_lag_f1R           'f1R indicates forward 1 scans and after rotation
Alias wCO2_Cov_lag_R (5) = wCO2_Cov_lag_f2R           'f2R indicates forward 2 scans and after rotation

Dim wCO2_Cov_major_sign                               'Summarize the direction of CO2 flux (positive: up and negative: down)

Dim   uCO2_vCO2_Cov_lag_R(2*MAX_LAG + 1, 2)           'Hold the covariance of scan-lagged CO2 with u or v after coordinate rotation
Alias uCO2_vCO2_Cov_lag_R(1, 1) = uCO2_Cov_lag_b2R    'b2R indicates backward 2 scans and after-rotation
Alias uCO2_vCO2_Cov_lag_R(1, 2) = vCO2_Cov_lag_b2R
Alias uCO2_vCO2_Cov_lag_R(2, 1) = uCO2_Cov_lag_b1R    'b1R indicates backward 1 scans and after-rotation
Alias uCO2_vCO2_Cov_lag_R(2, 2) = vCO2_Cov_lag_b1R
Alias uCO2_vCO2_Cov_lag_R(3, 1) = uCO2_Cov_lag_0R     '0R indicates 0 lag in scans and after-rotation
Alias uCO2_vCO2_Cov_lag_R(3, 2) = vCO2_Cov_lag_0R
Alias uCO2_vCO2_Cov_lag_R(4, 1) = uCO2_Cov_lag_f1R    'f1R indicates forward 1 scans and after-rotation
Alias uCO2_vCO2_Cov_lag_R(4, 2) = vCO2_Cov_lag_f1R
Alias uCO2_vCO2_Cov_lag_R(5, 1) = uCO2_Cov_lag_f2R    'f2R indicates forward 2 scans and after-rotation
Alias uCO2_vCO2_Cov_lag_R(5, 2) = vCO2_Cov_lag_f2R
Units uCO2_vCO2_Cov_lag_R       = mg /(m^2 s)

Dim   wCO2_Cov_lag_max (2)                  'Array used in MaxSpa instruction to hold the max covariance and the location of the max covariance in array: wCO2_Cov_lag_R()
Alias wCO2_Cov_lag_max (1) = wCO2_Cov_R     'Max covariance found from lagged covariance array [.i.e. wCO2_cov_lag_R()] and will be used for CO2 flux after freq correction
Alias wCO2_Cov_lag_max (2) = lag_irga       'Lag in number of scans, also used for sequential number in array index of lag wCO2_Cov_lag_R() and uCO2_vCO2_Cov_lag_R()
Units wCO2_Cov_R           = mg/(m^2 s)
Units lag_irga             = scans

' H2O: Lag maximization
Dim cov_array_H2O(2* MAX_LAG+1, 4)          'Arrays used to hold the H2O data with -2, -1, 0, 1, or 2 scan lags relative to sonic data. The optimum lag_irga found during maximization
'of covariance of CO2 with w is assumed to also be the optimum lag for H2O data since the same IRGA measures both CO2 and H2O.
'Data are held in an array for more convenient calculation of covariances.
'Row used for lag of -2, -1, 0, 1, 2 scans. Columns used for H2O, u, v, and w.

Dim Cov_out_H2O(5*(2*MAX_LAG + 1))          'H2O variables and H2O-related covariances
Alias Cov_out_H2O(1)  = H2O_Avg_b2          'b2 indicates backward 2 scans
Alias Cov_out_H2O(2)  = H2OH2O_Cov_lag_b2
Alias Cov_out_H2O(3)  = uH2O_Cov_lag_b2
Alias Cov_out_H2O(4)  = vH2O_Cov_lag_b2
Alias Cov_out_H2O(5)  = wH2O_Cov_lag_b2
Alias Cov_out_H2O(6)  = H2O_Avg_b1          'b1 indicates backward 1 scan
Alias Cov_out_H2O(7)  = H2OH2O_Cov_lag_b1
Alias Cov_out_H2O(8)  = uH2O_Cov_lag_b1
Alias Cov_out_H2O(9)  = vH2O_Cov_lag_b1
Alias Cov_out_H2O(10) = wH2O_Cov_lag_b1
Alias Cov_out_H2O(11) = H2O_Avg_b0          '0 indicates neither backward nor forward
Alias Cov_out_H2O(12) = H2OH2O_Cov_lag_0
Alias Cov_out_H2O(13) = uH2O_Cov_lag_0
Alias Cov_out_H2O(14) = vH2O_Cov_lag_0
Alias Cov_out_H2O(15) = wH2O_Cov_lag_0
Alias Cov_out_H2O(16) = H2O_Avg_f1          'f1 indicates forward 1 scan
Alias Cov_out_H2O(17) = H2OH2O_Cov_lag_f1
Alias Cov_out_H2O(18) = uH2O_Cov_lag_f1
Alias Cov_out_H2O(19) = vH2O_Cov_lag_f1
Alias Cov_out_H2O(20) = wH2O_Cov_lag_f1
Alias Cov_out_H2O(21) = H2O_Avg_f2          'f2 indicates forward 2 scans
Alias Cov_out_H2O(22) = H2OH2O_Cov_lag_f2
Alias Cov_out_H2O(23) = uH2O_Cov_lag_f2
Alias Cov_out_H2O(24) = vH2O_Cov_lag_f2
Alias Cov_out_H2O(25) = wH2O_Cov_lag_f2

' Before coordinate rotations. Lag due to separation was applied if measured by EC150 +CSAT3A
Dim Cov_out_cs(18)                     'IRGA statistics.
Alias Cov_out_cs(1)  = CO2_Avg
Alias Cov_out_cs(2)  = CO2_Std
Alias Cov_out_cs(3)  = UxCO2_Cov
Alias Cov_out_cs(4)  = UyCO2_Cov
Alias Cov_out_cs(5)  = UzCO2_Cov
Alias Cov_out_cs(6)  = H2O_Avg
Alias Cov_out_cs(7)  = H2O_Std
Alias Cov_out_cs(8)  = UxH2O_Cov
Alias Cov_out_cs(9)  = UyH2O_Cov
Alias Cov_out_cs(10) = UzH2O_Cov
Alias Cov_out_cs(11) = amb_tmpr_Avg    'from 107 temperature probe connected to EC100
Alias Cov_out_cs(12) = RH_Avg          'relative humidity (%): derived from Tc, H2O, and amb_press
Alias Cov_out_cs(13) = e_sat_Avg       'saturation vapor pressure (kPa): derived from Tc, H2O. and amb_press
Alias Cov_out_cs(14) = e_Avg           'vapor pressure (kPa): derived from Tc, H2O. and amb_press
Alias Cov_out_cs(15) = amb_press_Avg
Alias Cov_out_cs(16) = rho_d_Avg       'density of dry air (kg/m^3). calculated using Tc, H2O, and amb_press
Alias Cov_out_cs(17) = rho_a_Avg       'density of moist air (kg/m^3). calculated using Tc, H2O, and amb_press
Alias Cov_out_cs(18) = Tc_Avg          'air temperature (C), found from IRGASON' sonic temperature, H2O, and amb+press or in case of the EC150/CSAT3A Tc=amb_tmpr (temperature probe connected to EC100)
Units CO2_Avg        = mg/m^3
Units CO2_Std        = mg/m^3
Units UxCO2_Cov      = mg/(m^2 s)
Units UyCO2_Cov      = mg/(m^2 s)
Units UzCO2_Cov      = mg/(m^2 s)
Units H2O_Avg        = g/m^3
Units H2O_Std        = g/m^3
Units UxH2O_Cov      = g/(m^2 s)
Units UyH2O_Cov      = g/(m^2 s)
Units UzH2O_Cov      = g/(m^2 s)
Units amb_tmpr_Avg   = C
Units RH_Avg         = %
Units e_sat_Avg      = kPa
Units e_Avg          = kPa
Units amb_press_Avg  = kPa
Units rho_d_Avg      = kg/m^3
Units rho_a_Avg      = kg/m^3
Units Tc_Avg         = C

Public CO2_molfrac_Avg
Units  CO2_molfrac_Avg = umol/mol

Public H2O_molfrac_Avg
Units  H2O_molfrac_Avg = mmol/mol

Public VPD_air                            'ambient water vapor pressure deficit
Units  VPD_air = kpa

'After coordinate rotations as indicated by R
Dim uCO2_Cov_R
Dim vCO2_Cov_R
'For wCO2_Cov_R, see wCO2_Cov_lag_max (1)
Units uCO2_Cov_R  = mg/(m^2 s)
Units vCO2_Cov_R  = mg/(m^2 s)

Dim uH2O_Cov_R
Dim vH2O_Cov_R
Dim wH2O_Cov_R                             'found using lag_irga that was found while wCO2_cov_R was found
Units uH2O_Cov_R  = g/(m^2 s)
Units vH2O_Cov_R  = g/(m^2 s)
Units wH2O_Cov_R  = g/(m^2 s)

' After coordinate rotations and freq corrections as indicated by R_F
Dim wCO2_Cov_R_F
Dim wH2O_Cov_R_F
Units wCO2_Cov_R_F = mg/(m^2 s)
Units wH2O_Cov_R_F = g/(m^2 s)

' WPL correction terms after coordinate rotations and freq corrections as indicated R_F
Dim CO2_E_WPL_R_F                  'Carbon dioxide flux, WPL term due to water vapor flux (covariance of water vapor with vertical velocity)
Dim CO2_T_WPL_R_F                  'Carbon dioxide flux, WPL term due to temperature flux (covariance of temperature with vertical velocity)
Dim H2O_E_WPL_R_F                  'Water vapor flux, WPL term due to water vapor flux (covariance of water vapor with vertical velocity)
Dim H2O_T_WPL_R_F                  'Water vapor flux, WPL term due to temperature flux (covariance of temperature with vertical velocity)
Units CO2_E_WPL_R_F = mg/(m^2 s)
Units CO2_T_WPL_R_F = mg/(m^2 s)
Units H2O_E_WPL_R_F = g/(m^2 s)
Units H2O_T_WPL_R_F = g/(m^2 s)

' After coordinate rotations, freq corrections, and WPL correction
Public Fc_molar                      'Carbon dioxide flux after coordinate rotation, freq, and WPL corrections in umol/m^2 s
Public Fc_mass                       'Carbon dioxide flux after coordinate rotation, freq, and WPL corrections in mg/m^2 s
Public LE                            'Latent heat flux after coordinate rotation, freq, and  WPL corrections
Units Fc_molar = umol/(m^2 s)
Units Fc_mass  = mg/(m^2 s)
Units LE = W/m^2

Public Bowen_ratio
Units  Bowen_ratio = fraction

'*** Variables for data QC
' Steady State Test
Public RN_wCO2_Cov_R             'Relative Non-stationarity (RN) for wCO2_cov_R.
Public RN_wH2O_Cov_R             'Relative non-stationarity for wH2O_cov_R.
Public nmbr_interval_qc_irga     'Number of sub-intervals = (OUTPUT_INTERVAL in min)/(5 min) if not a 1st interval or CR3K starts before 5 min after an individual interval

Dim cov_out_irga_SST(8)          'IRGA statistics for Steady State Test (SST)
Alias cov_out_irga_SST(1) = CO2CO2_Cov_SST
Alias cov_out_irga_SST(2) = uCO2_Cov_SST
Alias cov_out_irga_SST(3) = vCO2_Cov_SST
Alias cov_out_irga_SST(4) = wCO2_Cov_SST
Alias cov_out_irga_SST(5) = H2OH2O_Cov_SST
Alias cov_out_irga_SST(6) = uH2O_Cov_SST
Alias cov_out_irga_SST(7) = vH2O_Cov_SST
Alias cov_out_irga_SST(8) = wH2O_Cov_SST

' After coordinate rotations
Dim uCO2_Cov_SST_R
Dim vCO2_Cov_SST_R
Dim wCO2_Cov_SST_R
Dim uH2O_Cov_SST_R
Dim vH2O_Cov_SST_R
Dim wH2O_Cov_SST_R

' Overall grade of data quality for CO2 and H2O fluxes
Public Fc_qc_grade              'Overall grade of data quality for CO2 flux (i.e. for variable: Fc_molar and Fc_mass) [1 (highest) to 9 (lowest)]
Public LE_qc_grade              'Overall grade of data quality for latent heat flux (i.e. for variable: LE) [1 (highest) to 9 (lowest)]
Units  Fc_qc_grade = Grade
Units  LE_qc_grade = Grade

'Data table for delayed data from IRGA
DataTable (delay_cs, TRUE, (OFFSET + MAX_LAG))
  TableHide
  Sample (7,sonic_irga_raw(6),IEEE4)
EndTable

' 5-minute statistics
DataTable (comp_cov_cs_5min, TRUE, 1)
  TableHide
  DataInterval (0, OUTPUT_INTERVAL_SST, Min, 1)

  Covariance (4, cov_array_CO2((MAX_LAG + 1), 1), IEEE4, (sonic_disable_f OR irga_bad_data_flg_array(MAX_LAG + 1) OR CO2_bad_rng_sig_array(MAX_LAG+1)),4)
  Covariance (4, cov_array_H2O((MAX_LAG + 1), 1), IEEE4, (sonic_disable_f OR irga_bad_data_flg_array(MAX_LAG + 1) OR H2O_bad_rng_sig_array(MAX_LAG+1)),4)

EndTable

'Compute covariance of CO2 against sonic wind data.
DataTable (comp_cov_CO2, TRUE, 1)
  TableHide
  DataInterval (0, OUTPUT_INTERVAL, Min, 1)

  Average    (1, cov_array_CO2(1, 1), IEEE4, (irga_bad_data_flg_array(1) OR CO2_bad_rng_sig_array(1)))
  Covariance (4, cov_array_CO2(1, 1), IEEE4, (sonic_disable_f OR irga_bad_data_flg_array(1) OR CO2_bad_rng_sig_array(1)),4)

  Average    (1, cov_array_CO2(2, 1), IEEE4, (irga_bad_data_flg_array(2) OR CO2_bad_rng_sig_array(2)))
  Covariance (4, cov_array_CO2(2, 1), IEEE4, (sonic_disable_f OR irga_bad_data_flg_array(2) OR CO2_bad_rng_sig_array(2)),4)

  Average    (1, cov_array_CO2(3, 1), IEEE4, (irga_bad_data_flg_array(3) OR CO2_bad_rng_sig_array(3)))
  Covariance (4, cov_array_CO2(3, 1), IEEE4, (sonic_disable_f OR irga_bad_data_flg_array(3) OR CO2_bad_rng_sig_array(3)),4)

  Average    (1, cov_array_CO2(4, 1), IEEE4, (irga_bad_data_flg_array(4) OR CO2_bad_rng_sig_array(4)))
  Covariance (4, cov_array_CO2(4, 1), IEEE4, (sonic_disable_f OR irga_bad_data_flg_array(4) OR CO2_bad_rng_sig_array(4)),4)

  Average    (1, cov_array_CO2(5, 1), IEEE4, (irga_bad_data_flg_array(5) OR CO2_bad_rng_sig_array(5)))
  Covariance (4, cov_array_CO2(5, 1), IEEE4, (sonic_disable_f OR irga_bad_data_flg_array(5) OR CO2_bad_rng_sig_array(5)),4)
EndTable

'Compute covariance of H2O against sonic wind data.
DataTable (comp_cov_H2O, TRUE, 1)
  TableHide
  DataInterval (0, OUTPUT_INTERVAL, Min, 1)

  Average    (1, cov_array_H2O(1, 1), IEEE4, (irga_bad_data_flg_array(1) OR H2O_bad_rng_sig_array(1)))
  Covariance (4, cov_array_H2O(1, 1), IEEE4, (sonic_disable_f OR irga_bad_data_flg_array(1) OR H2O_bad_rng_sig_array(1)),4)

  Average    (1, cov_array_H2O(2, 1), IEEE4, (irga_bad_data_flg_array(2) OR H2O_bad_rng_sig_array(2)))
  Covariance (4, cov_array_H2O(2, 1), IEEE4, (sonic_disable_f OR irga_bad_data_flg_array(2) OR H2O_bad_rng_sig_array(2)),4)

  Average    (1, cov_array_H2O(3, 1), IEEE4, (irga_bad_data_flg_array(3) OR H2O_bad_rng_sig_array(3)))
  Covariance (4, cov_array_H2O(3, 1), IEEE4, (sonic_disable_f OR irga_bad_data_flg_array(3) OR H2O_bad_rng_sig_array(3)),4)

  Average    (1, cov_array_H2O(4, 1), IEEE4, (irga_bad_data_flg_array(4) OR H2O_bad_rng_sig_array(4)))
  Covariance (4, cov_array_H2O(4, 1), IEEE4, (sonic_disable_f OR irga_bad_data_flg_array(4) OR H2O_bad_rng_sig_array(4)),4)

  Average    (1, cov_array_H2O(5, 1), IEEE4, (irga_bad_data_flg_array(5) OR H2O_bad_rng_sig_array(5)))
  Covariance (4, cov_array_H2O(5, 1), IEEE4, (sonic_disable_f OR irga_bad_data_flg_array(5) OR H2O_bad_rng_sig_array(5)),4)
EndTable

'Compute Tc-related data.
DataTable (comp_mean, TRUE, 1)
  TableHide
  DataInterval (0, OUTPUT_INTERVAL, Min, 1)
  Average (1, amb_tmpr,  IEEE4, irga_amb_tmpr_f)

  #If (SENSOR_IRGASON) Then
  Average (1, RH,        IEEE4, (irga_disable_f OR sonic_disable_f OR H2O_bad_rng_sig_array(MAX_LAG +1)))
  Average (1, e_sat,     IEEE4, (irga_disable_f OR sonic_disable_f OR H2O_bad_rng_sig_array(MAX_LAG +1)))
  Average (1, e,         IEEE4, (irga_disable_f OR sonic_disable_f OR H2O_bad_rng_sig_array(MAX_LAG +1)))
  #EndIf
  #If (NOT SENSOR_IRGASON) Then
  Average (1, RH,        IEEE4, (irga_disable_f OR irga_amb_tmpr_f OR H2O_bad_rng_sig_array(MAX_LAG +1)))
  Average (1, e_sat,     IEEE4, (irga_disable_f OR irga_amb_tmpr_f OR H2O_bad_rng_sig_array(MAX_LAG +1)))
  Average (1, e,         IEEE4, (irga_disable_f OR irga_amb_tmpr_f OR H2O_bad_rng_sig_array(MAX_LAG +1)))
  #EndIf
    
  Average (1, amb_press, IEEE4, irga_amb_press_f)
  
  #If (NOT SENSOR_IRGASON) Then
  Average (1, rho_d,     IEEE4, (irga_disable_f OR irga_amb_tmpr_f OR H2O_bad_rng_sig_array(MAX_LAG +1)))  'g/m^3
  Average (1, rho_a,     IEEE4, (irga_disable_f OR irga_amb_tmpr_f OR H2O_bad_rng_sig_array(MAX_LAG +1)))  'kg/m^3
  Average (1, Tc,        IEEE4, irga_amb_tmpr_f)
  #EndIf
  #If (SENSOR_IRGASON) Then
  Average (1, rho_d,     IEEE4, (irga_disable_f OR sonic_disable_f OR H2O_bad_rng_sig_array(MAX_LAG +1)))  'g/m^3
  Average (1, rho_a,     IEEE4, (irga_disable_f OR sonic_disable_f OR H2O_bad_rng_sig_array(MAX_LAG +1)))  'kg/m^3
  Average (1, Tc,        IEEE4, (irga_disable_f OR sonic_disable_f OR H2O_bad_rng_sig_array(MAX_LAG +1)))
  #EndIf

EndTable
'*** End of IRGA constants, variables, and working data table ***

#If (SENSOR_FW) Then
'*** Beginning of FW constants, variables, and working data table ***
Public time_const_FW =  0.001         'default value (seconds). It will be recalculated inside the program
Units  time_const_FW = s

Public FW
Units  FW = C

'Raw and not lagged FW data.
Dim FW_raw
Dim diag_FW_raw                         'Boolean type is not used because this variable is an element of numerical array: dly_data_out()

Public separation_lat_dist_FW           'effective separation distance in direction normal to wind direction. Used for separation correction.
Public separation_lag_dist_FW           'effective separation distance along wind direction. Used for time lag maximization.
Public separation_lag_scan_FW           'lag in scan number. Wind passing FW after (+) or before (-) passing sonic volume. Not necessary to use an integer.
Units  separation_lat_dist_FW = m
Units  separation_lag_dist_FW = m
Units  separation_lag_scan_FW = scans

Dim Cov_array_fw(2* MAX_LAG+1, 4)       'Arrays used to hold the FW data with -2, -1, 0, 1, 2 in sacn lags relative to sonic data in order
'to find the max covariance of FW with w using lag_FW found in maximuzation for covariance of FW with w
'In form of array for use in the COVARIANCE instructions.
'Row for lag -2, -1, 0, 1, 2 scans, column: FW, u, v, and w.

Dim FW_bad_data_flg (2* MAX_LAG + 1) As Boolean

Dim Cov_out_fw(5*(2*MAX_LAG + 1))       'FW statistics and FW-related covariance
Alias Cov_out_fw(1)  = FW_Avg_b2        'b2 indicates backward 2 scans
Alias Cov_out_fw(2)  = FWFW_Cov_lag_b2
Alias Cov_out_fw(3)  = uFW_Cov_lag_b2
Alias Cov_out_fw(4)  = vFW_Cov_lag_b2
Alias Cov_out_fw(5)  = wFW_Cov_lag_b2
Alias Cov_out_fw(6)  = FW_Avg_b1        'b1 indicates backward 1 scan
Alias Cov_out_fw(7)  = FWFW_Cov_lag_b1
Alias Cov_out_fw(8)  = uFW_Cov_lag_b1
Alias Cov_out_fw(9)  = vFW_Cov_lag_b1
Alias Cov_out_fw(10) = wFW_Cov_lag_b1
Alias Cov_out_fw(11) = FW_Avg_0         '0 indicates neither backward nor forward
Alias Cov_out_fw(12) = FWFW_Cov_lag_0
Alias Cov_out_fw(13) = uFW_Cov_lag_0
Alias Cov_out_fw(14) = vFW_Cov_lag_0
Alias Cov_out_fw(15) = wFW_Cov_lag_0
Alias Cov_out_fw(16) = FW_Avg_f1        'f1 indicates forward 1 scan
Alias Cov_out_fw(17) = FWFW_Cov_lag_f1
Alias Cov_out_fw(18) = uFW_Cov_lag_f1
Alias Cov_out_fw(19) = vFW_Cov_lag_f1
Alias Cov_out_fw(20) = wFW_cov_lag_f1
Alias Cov_out_fw(21) = FW_Avg_f2        'f2 indicates forward 2 scans
Alias Cov_out_fw(22) = FWFW_Cov_lag_f2
Alias Cov_out_fw(23) = uFW_Cov_lag_f2
Alias Cov_out_fw(24) = vFW_Cov_lag_f2
Alias Cov_out_fw(25) = wFW_Cov_lag_f2

'Variables after coordinate rotations as indicated by "R"
Dim   wFW_Cov_lag_R (2*MAX_LAG + 1)        'Used for instruction of MaxSpa
Alias wFW_Cov_lag_R (1) = wFW_Cov_lag_b2R  'b2R indicates backward 2 scans and after-rotation
Alias wFW_Cov_lag_R (2) = wFW_Cov_lag_b1R  'b1R indicates backward 1 scan and after-rotation
Alias wFW_Cov_lag_R (3) = wFW_Cov_lag_0R   '0R indicates neither backward nor forward and after-rotation
Alias wFW_Cov_lag_R (4) = wFW_Cov_lag_f1R  'f1R indicates forward 1 scan and after-rotation
Alias wFW_Cov_lag_R (5) = wFW_Cov_lag_f2R  'f2R indicates forward 2 scans and after-rotation
Units wFW_Cov_lag_R     = C m/s

Dim   wFW_cov_major_sign                           'Summarize the sign of wFW_cov: From above array, chose max if positive (up) and min if negative (down)

Dim   uFW_vFW_Cov_lag_R(2*MAX_LAG + 1, 2)          'Hold the covariance of lagged FW with u or v after coordinate rotation
Alias uFW_vFW_Cov_lag_R(1, 1) = uFW_Cov_lag_b2R    'b2R indicates backward 2 scans and after-rotation
Alias uFW_vFW_Cov_lag_R(1, 2) = vFW_Cov_lag_b2R
Alias uFW_vFW_Cov_lag_R(2, 1) = uFW_Cov_lag_b1R    'b1R indicates backward 1 scan and after-rotation
Alias uFW_vFW_Cov_lag_R(2, 2) = vFW_Cov_lag_b1R
Alias uFW_vFW_Cov_lag_R(3, 1) = uFW_Cov_lag_0R     '0R indicates neither backward nor forward and after-rotation
Alias uFW_vFW_Cov_lag_R(3, 2) = vFW_Cov_lag_0R
Alias uFW_vFW_Cov_lag_R(4, 1) = uFw_Cov_lag_f1R    'f1R indicates forward 1 scan and after-rotation
Alias uFW_vFW_Cov_lag_R(4, 2) = vFW_Cov_lag_f1R
Alias uFW_vFW_Cov_lag_R(5, 1) = uFw_Cov_lag_f2R    'f2R indicates forward 2 scans and after-rotation
Alias uFW_vFW_Cov_lag_R(5, 2) = vFW_Cov_lag_f2R
Units uFW_vFW_Cov_lag_R       = C m/s

Dim   wFW_Cov_lag_max (2)
Alias wFW_Cov_lag_max (1) = wFW_Cov_R             'Max covariance among lagged covariance values in array of wFW_Cov_lag_R() and will be used for sensible heat flux after freq correction
Alias wFW_Cov_lag_max (2) = lag_FW                'Lag in number of scans, also used for sequential number in an array index for lag wFW_Cov_lag_R() and uFW_vFW_cov_lag_R()
Units wFW_Cov_R           = C m/s
Units lag_FW              = scans

Dim   FW_Avg                                      'Selected from cov_out_FW() according to lag maximization using lag_FW
Dim   FW_Std                                      'Selected from cov_out_FW() according to lag maximization using lag_FW
Dim   UxFW_Cov                                    'Selected from cov_out_FW() according to lag maximization using lag_FW
Dim   UyFW_Cov                                    'Selected from cov_out_FW() according to lag maximization using lag_FW
Dim   UzFW_Cov                                    'Selected from cov_out_FW() according to lag maximization using lag_FW
Units FW_Avg   = C
Units FW_Std   = C
Units UxFW_Cov = C m/s
Units UyFW_Cov = C m/s
Units UzFW_Cov = C m/s

Dim   uFW_Cov_R                                   'Selected from uFW_vFW_cov_lag_R() according to lag maximization using lag_FW
Dim   vFW_Cov_R                                   'Selected from uFW_vFW_cov_lag_R() according to lag maximization using lag_FW
'For "wFW_cov_R", see "wFW_Cov_lag_max (1)"
Units uFW_Cov_R = C m/s
Units vFW_Cov_R = C m/s

' Variables after coordinate rotations and freq corrections as indicated by "R_F"
Dim   wFW_Cov_R_F
Units wFW_Cov_R_F = C m/s

' Sensible heat flux
Public H_FW                                      'After coordinate rotations and freq corrections
Units  H_FW = W/m^2

DataTable (delay_fw, TRUE, (OFFSET + MAX_LAG))   ' + MAX_LAG. Add more records of MAX_LAG for use in finding a lag for FW
  TableHide
  Sample (1, FW_raw,      IEEE4)
  Sample (1, diag_FW_raw, IEEE4)
EndTable

DataTable (comp_cov_fw, TRUE, 1)
  TableHide
  DataInterval (0, OUTPUT_INTERVAL, Min, 1)

  'Compute covariance of FW against sonic wind data.
  Average    (1, Cov_array_fw(1, 1), IEEE4, FW_bad_data_flg(1))
  Covariance (4, Cov_array_fw(1, 1), IEEE4,(sonic_disable_f OR FW_bad_data_flg(1)),4)
  Average    (1, Cov_array_fw(2, 1), IEEE4, FW_bad_data_flg(2))
  Covariance (4, Cov_array_fw(2, 1), IEEE4,(sonic_disable_f OR FW_bad_data_flg(2)),4)
  Average    (1, Cov_array_fw(3, 1), IEEE4, FW_bad_data_flg(3))
  Covariance (4, Cov_array_fw(3, 1), IEEE4,(sonic_disable_f OR FW_bad_data_flg(3)),4)
  Average    (1, Cov_array_fw(4, 1), IEEE4, FW_bad_data_flg(4))
  Covariance (4, Cov_array_fw(4, 1), IEEE4,(sonic_disable_f OR FW_bad_data_flg(4)),4)
  Average    (1, Cov_array_fw(5, 1), IEEE4, FW_bad_data_flg(5))
  Covariance (4, Cov_array_fw(5, 1), IEEE4,(sonic_disable_f OR FW_bad_data_flg(5)),4)
EndTable
#EndIf
#If (SENSOR_TMPR_RH) Then

'*** Beginning of temperature and humidity probe constants, variables, and working data table. ***
Public tmpr_rh(3)
Alias tmpr_rh(1) = T_probe                    'Temperature/humidity probe: temperature
Alias tmpr_rh(2) = RH_probe                   'Temperature/humidity probe: relative humidity
Alias tmpr_rh(3) = e_probe                    'Temperature/humidity probe: vapor pressure
Units T_probe  = C
Units RH_probe = percent
Units e_probe  = kPa

Dim e_sat_probe                               'Temperature/humidity probe: saturation vapor pressure
Public Td_probe
Units  Td_probe = C
Dim Enhance_factor1_probe                     'Temperature/humidity probe: Intermediate variable for calculation of dew point temperature
Dim Enhance_factor2_probe                     'Temperature/humidity probe: Intermediate variable for calculation of dew point temperature
Dim x_tmp_probe                               'Temperature/humidity probe: Intermediate variable for calculation of dew point temperature
Dim Td_gu_probe                               'Temperature/humidity probe: Intermediate variable for calculation of dew point temperature

Dim   rho_d_probe_Avg                         'Density of dry air calculated using the data from temperature and humidity probe
Units rho_d_probe_Avg = kg/m^3

Dim stats_out_tmpr_rh(6)                      'Temperature/humidity probe: statistics
Alias stats_out_tmpr_rh(1) = T_probe_Avg      'Average temperature from temperature/humidity probe
Alias stats_out_tmpr_rh(2) = e_probe_Avg      'Average vapor pressure from temperature/humidity probe
Alias stats_out_tmpr_rh(3) = e_sat_probe_Avg  'Average saturation vapor pressure from temperature/humidity probe
Alias stats_out_tmpr_rh(4) = H2O_probe_Avg    'Average vapor density temperature/humidity probe
Alias stats_out_tmpr_rh(5) = RH_probe_Avg     'Average relative humidity temperature/humidity probe
Alias stats_out_tmpr_rh(6) = rho_a_probe_Avg  'Average air density measured using Temperature/humidity probe
Units T_probe_Avg     = C
Units e_probe_Avg     = kPa
Units e_sat_probe_Avg = kPa
Units H2O_probe_Avg   = g/m^3
Units RH_probe_Avg    = %
Units rho_a_probe_Avg = kg/m^3

DataTable (stats_tmpr_rh,TRUE,1)
  TableHide
  DataInterval (0,OUTPUT_INTERVAL,Min,1)

  Average (1, T_probe,     IEEE4, slowsequence_disable_flg)
  Average (1, e_probe,     IEEE4, slowsequence_disable_flg)
  Average (1, e_sat_probe, IEEE4, slowsequence_disable_flg)
EndTable
'*** End of temperature and humidity probe constants, variables, and working data table ***
#EndIf
#If (SENSOR_TE525x) Then

'*** Beginning of TE525mm constants and variables ***
Public Precipitation
Units  Precipitation = mm
'*** End of TE525mm constants and variables ***
#EndIf
#If (SENSOR_Rn) Then

'*** Beginning of net radiometer constants and variables ***
Public Rn_raw                                 'Net radiation: Measured time series data

Public Rn                                     'Net radation: mean over an averaging interval
Units  Rn = W/m^2

#If (SENSOR_NR_LITE) Then

'*** Beginning of NR Lite constants and variables ***
Const NMBR_WND_SAMPLES = 3000/SCAN_INTERVAL   'Number of measurements to compute a three second mean of horizontal wind to correct measured Rn_meas as Rn
Public Rn_meas                                'Measured Rn that is not corrected by horizontal wind speed
Units  Rn_meas = W/m^2

Dim hor_wind_raw                              'Used for running average for hor_wind
Dim hor_wind                                  'Running average of hor_wind_raw over three seconds of hor_wind_raw
Dim hor_wind_diag                             'Diagnosis code: non-zero if any of recent sonic_irga_raw(5) last 30 second
'*** End of NR Lite constants and variables ***
#EndIf
#If ((SENSOR_NR01) OR (SENSOR_CNR4)) Then

'*** Beginning of 4-way net radiometer constants and variables ****
Public nr(8)                       'Radiation components measured from a 4-way net radiometer.
Alias nr(1) = albedo
Alias nr(2) = R_SW_in              'Incoming (downwelling) short wave radiation
Alias nr(3) = R_SW_out             'Outgoing (upwelling) short wave radiation
Alias nr(4) = R_LW_in              'Incoming (downwelling) long wave radiation
Alias nr(5) = R_LW_out             'Outgoing (upwelling) long wave radiation
Alias nr(6) = T_nr                 'Sensor body temperature
Alias nr(7) = R_LW_in_meas         'Measured signal of incoming (downwelling) long wave radiation
Alias nr(8) = R_LW_out_meas        'Measured signal of outgoing (upwelling) long wave radiation
Units albedo        = unitless
Units R_SW_in       = W/m^2
Units R_SW_out      = W/m^2
Units R_LW_in       = W/m^2
Units R_LW_out      = W/m^2
Units T_nr          = Klvin
Units R_LW_in_meas  = W/m^2
Units R_LW_out_meas = W/m^2
'*** End of NR01/CNR4 constants and variables ***

#If (SENSOR_CNR4) Then

'YSI 44031 Steinhart-Hart coefficients fit through -40 degrees C (239800 ohms), 20 degrees C (12260 ohms), and 80 degrees C (1458 ohms).
Const A_SHH = 1.0295e-3           'Steinhart-Hart A coefficient (from Kipp & Znen through email April 16 2015).
Const B_SHH = 2.3910e-4           'Steinhart-Hart B coefficient (from Kipp & Znen through email April 16 2015).
Const C_SHH = 1.5680e-7           'Steinhart-Hart C coefficient (from Kipp & Znen through email April 16 2015).
Dim X_cnr4
Dim ln_R
#EndIf

'*** End of 4-way net radiometer constants and variables ****
#EndIf

DataTable (stats_net_radiation, TRUE, 1)
  TableHide
  DataInterval (0, OUTPUT_INTERVAL, Min, 1)

  Average (1, Rn_raw, IEEE4, slowsequence_disable_flg)
EndTable
'*** End of net radiometer constants and variables ***
#EndIf
#If (SENSOR_HFP) Then

' ***  Beginning of HFP01 or HFP01SC constants and variables ***
Dim shf_plate_cal(NMBR_SHFP)           'Hold calibiration of soil heat flux plates

Public shf_plate(NMBR_SHFP)            'Soil heat flux through soil heat flux plates
Units shf_plate = W/m^2

Public shf_plate_avg(NMBR_SHFP)        'Mean soil heat flux through soil heat flux plates
Units shf_plate_avg = W/m^2

#If (SENSOR_HFP01SC) Then
'*** Beginning of HFP01SC constants and variables ***
Const CAL_INTERVAL = 1440                'Unique:  HFP01SC insitu calibration interval (minutes).
Const END_CAL      = OUTPUT_INTERVAL - 1 'End HFP01SC insitu calibration one minute before the next output.
Dim shf_mV(NMBR_SHFP)                    'Voltage measured from soil heat flux plates
Dim shf_mV_run(NMBR_SHFP)                'Running mean of shf_mV
Dim shf_mV_0(NMBR_SHFP)                  'Running mean of shf_mV at the beginning of calibration
Dim shf_mV_180(NMBR_SHFP)                'Running mean of shf_mV after 180 seconds since the beginning of calibration
Dim shf_mV_end(NMBR_SHFP)                'Running mean of shf_mV at the end of calibration
Dim V_Rf(NMBR_SHFP)                      'Reference voltage
Dim V_Rf_run(NMBR_SHFP)                  'Running mean of reference voltage
Dim V_Rf_180(NMBR_SHFP)                  'Running mean of reference voltage after 180 seconds since the beginning of calibration
Dim shf_cal_on_f As Boolean
Dim sw12_1_state As Boolean              'State of the switched 12Vdc port 1.
'*** End of HFP01SC constants and variables ***
#EndIf

DataTable (stats_SHF, TRUE, 1)
  TableHide
  DataInterval (0, OUTPUT_INTERVAL, Min, 1)

  #If (SENSOR_HFP01) Then
  Average (NMBR_SHFP, shf_plate(1), IEEE4, slowsequence_disable_flg)

  #EndIf
  #If (SENSOR_HFP01SC) Then

  Average (NMBR_SHFP, shf_plate(1), IEEE4, (shf_cal_on_f OR slowsequence_disable_flg))
  #EndIf

EndTable
' ***  End of HFP01 or HFP01SC constants and variables ***
#EndIf

#If (SENSOR_TCAV) Then

'*** Beginning of TCAV constants and variables ***
Public Tsoil(NMBR_TCAV)                                               'TCAV soil temperature.
Units Tsoil = C
'*** End of TCAV constants and variables ***
#EndIf
#If (SENSOR_CS616) Then

'*** Beginning of CS616 constants and variables ***
Public cs616_wcr(NMBR_CS6xx)            'Water content reflectometer period.
Units cs616_wcr = uSeconds

#If ((SENSOR_CS616) AND (NOT SENSOR_TCAV)) Then
Public soil_wtr(NMBR_CS6xx)             'Volumetric soil water content without temperature correction.
Units soil_wtr = frac_v_wtr
#EndIf

#If ((SENSOR_CS616) AND (SENSOR_TCAV)) Then
Dim Tsoil_for_CS616_correct(NMBR_CS6xx) 'Soil temperature used for CS616 temperature correction. This variable is defined in case: NMBR_TCAV <> NMBR_CS6xx
Dim cs616_T(NMBR_CS6xx)                 'Water content reflectometer period with temperature correction.

Public soil_wtr_T(NMBR_CS6xx)           'Volumetric soil water content with temperature correction.
Units soil_wtr_T = frac_v_wtr
#EndIf
'*** End of CS616 constants and variables ***
#EndIf
#If (SENSOR_CS65X) Then

'*** Beginning of CS65X constants and variables ***
Public cs65x_wc(NMBR_CS6xx)            'Volumetric soil water content.
Public cs65x_ec(NMBR_CS6xx)            'Electrical conductivity.
Public cs65x_tmpr(NMBR_CS6xx)          'CS65X probe temperature.
Dim cs65x_raw(3)                       'Hold CS65X raw variables
Units cs65x_wc = frac_v_wtr
Units cs65x_ec = dS/m
Units cs65x_tmpr = C
'*** End of CS65X constants and variables ***
#EndIf
#If ((SENSOR_HFP) AND  (SENSOR_CS6XX) AND ((SENSOR_TCAV) OR (SENSOR_CS65X))) Then

'*** Beginning of variables for calculation of soil heat flux at soil surface ***
Const NMBR_SOIL_T_WTR_DEL_SAMPLES = (60*1000)/SLOWSEQUENCE_SCAN_INTERVAL       'Unique: Number of measurements to compute a one-minute mean of soil temperature and water

Public G_surface                           'Soil heat flux at the ground surface
Units  G_surface = W/m^2

'Use to calculate the change in heat storage in soil
Public Tsoil_prev_Avg = NaN             'Tsoil mean of last one-minute measurements in the previous averaging interval

Dim Tsoil_current (2)                   'Indididual Tsoil means of last one-minute measurements in the current averaging interval
Public Tsoil_current_Avg

Public soil_wtr_prev_Avg = NaN          'soil_wtr_T mean of last one-minute measurements in the previous averaging interval
Dim soil_wtr_current (NMBR_CS6xx)       'soil_wtr_T mean of last one-minute measurements in the current averaging interval
Public soil_wtr_current_Avg
' Notes for NaN : After compiling, Tsoil_prev_avg and soil_wtr_prev_Avg will be NaN but will be replaced with the current measured
' values.  On subsequent averaging intervals, *_prev_Avg will be taken from the mean of the last minute of the previous averaging interval.

Public Delta_soil_ht_storage              'Increment in heat storage above soil heat flux plates over an averaging interval
Units  Delta_soil_ht_storage = W/m^2

' Variables used to calculate the number of seconds from the beginning of the program to the end of the first averaging interval (time interval offset)
Dim realtime_array(9)                      'Hold real time data
Dim Offset_intv_Delta_ht_storage           'time interval offset
'*** End of variables for calculation of soil heat flux at soil surface ***
#EndIf
#If ((SENSOR_Rn) AND (SENSOR_HFP) AND (SENSOR_CS6XX) AND ((SENSOR_TCAV) OR (SENSOR_CS65X))) Then

'*** Beginning of energy balance constants and variables ***
Public energy_closure                  '(LE + H)/(Rn-G_surface)
Units  energy_closure = Fraction
'*** End of energy balance constants and variables ***

#EndIf
#If (SENSOR_LI200X) OR (SENSOR_CS300) Then

'*** Beginning of Pyranometer constants and variables ***
Public R_pyran
Units  R_pyran = W/m^2
'*** End of pyranometer constants and variables ***
#EndIf
#If (SENSOR_LI190SB) Then

'*** Beginning of quntum constants and variables ***
Public PAR_density
Units  PAR_density = umol/(s m^2)
'*** End of quantum constants and variables ***
#EndIf
#If (SENSOR_SI111) Then

'*** Beginning of infrared radiometer constants and variables ***
Public T_SI111_targeted      'Temperature of surface that SI111 targets
Public T_SI111_body          'Temperature of SI111 sensor body
Units  T_SI111_targeted = C
Units  T_SI111_body     = C

Dim m_SI111, b_SI111         'Multipler and offset in equation to calculate temperature of targeted surface using measured voltage and SI111 body temperature
'*** End of infrared radiometer constants and variables ***
#EndIf

'*** Beginning display menu ***
DisplayMenu ("System Control", TRUE)
  SubMenu ("Station variables")
    MenuItem ("Surf type", surface_type)
  MenuPick (CROP, GRASS, FOREST, SHRUB, BARELAND, WATER)
    MenuItem ("d, 0 = auto",   displacement_user)                                'if 0, zero displacement is automatically calculated in the program
    MenuItem ("z0,0 = auto",   roughness_user)                                   'if 0, roughness length is automatically calculated in the program
    MenuItem ("Meas height",   height_measurement)
    MenuItem ("Canopy height", height_canopy)

    #If ((SENSOR_HFP) AND (SENSOR_CS6XX) AND ((SENSOR_TCAV) OR (SENSOR_CS65X))) Then
    MenuItem ("Bulk density", soil_bulk_density)
    MenuItem ("C_dry_soil",   Cds)
    MenuItem ("HFP depth",    thick_abv_SHFP)
    #EndIf

    MenuItem ("IRGA Coord x", separation_x_irga)
    MenuItem ("IRGA Coord y", separation_y_irga)

    #If (SENSOR_FW) Then
    MenuItem ("FW Coord x",  separation_x_FW)
    MenuItem ("FW Coord y",  separation_y_FW)
    MenuItem ("FW Dim",      FW_diameter)
  MenuPick (FW05DIA, FW1_DIA, FW3_DIA)
    #EndIf

    MenuItem ("Sonic Azmth", sonic_azimuth)
    MenuItem ("Latitude",    latitude)
    MenuItem ("Hemisph_Eq",  hemisphere_NS)
  MenuPick (Hemisphere_North, Hemisphere_South)
    MenuItem ("Longitude",   longitude)
    MenuItem ("Hemisph_Me",  hemisphere_EW)
  MenuPick (Hemisphere_East, Hemisphere_West)

    SubMenu ("Planar Fit Alpha")
      MenuItem ("<=60 or >=300",  alpha_PF_60_300)                               'Angle in sonic coordinate system
      MenuItem (">60 & <=170",  alpha_PF_60_170)
      MenuItem (">170 & <190",  alpha_PF_170_190)
      MenuItem (">=190 & <300", alpha_PF_190_300)
    EndSubMenu

    SubMenu ("Planar Fit Beta")
      MenuItem ("<=60 or >=300",  beta_PF_60_300)
      MenuItem (">60 & <=170",  beta_PF_60_170)
      MenuItem (">170 & <190",  beta_PF_170_190)
      MenuItem (">=190 & <300", beta_PF_190_300)
    EndSubMenu

    SubMenu ("Footprint Dis Intrst")
      MenuItem ("<=60 or >=300",  dist_intrst_60_300)
      MenuItem (">60 & <=170",  dist_intrst_60_170)
      MenuItem (">170 & <190",  dist_intrst_170_190)
      MenuItem (">=190 & <300", dist_intrst_190_300)
    EndSubMenu

    SubMenu ("Change Press Source")
      MenuItem ("Select Srce", press_source)
    MenuPick (BB, EB)
      MenuItem ("Set Source",  set_press_source_flg)
    MenuPick (TRUE, FALSE)
    EndSubMenu
  EndSubMenu

  SubMenu ("On-Site Zero & Span")
    SubMenu ("Span Concentrations")
      MenuItem ("CO2",CO2_span_gas)
      MenuItem ("Td", Td_span_gas)
    EndSubMenu

    MenuItem ("Do Zero", do_zero_flg)
  MenuPick (TRUE, FALSE)
    MenuItem ("Do CO2 Span", do_CO2_span_flg)
  MenuPick (TRUE, FALSE)
    MenuItem ("Do H2O Span", do_H2O_span_flg)
  MenuPick (TRUE, FALSE)
    DisplayValue ("CO2_mixratio", CO2_mixratio)
    DisplayValue ("H2O_mixratio", H2O_mixratio)
    DisplayValue ("Td deg C", Td)
    #If (SENSOR_TMPR_RH) Then
    DisplayValue ("Td_probe deg C", Td_probe)
    #EndIf

  EndSubMenu
EndMenu
'*** End of display menu ***

'**************************'
'*** OUTPUT DATA TABLES ***'
'**************************'

Const ONE_FULL_TABLE = FALSE         'Unique: TRUE if all hourly or half-hourly data are stored in one table
'        FALSE if hourly or half-hourly variables for direct use are stored in Flux table and the variables for later reference are stored in Flux_Notes

DataTable (Flux, TRUE, FLUX_SIZE_CPU)
  DataInterval (0, OUTPUT_INTERVAL, Min, 10)
  TableFile ("CRD:"&Status.SerialNumber(1,1)&".Flux_", 64, -1, 0, NMBR_DAY_FLUX_CRD, Day, 0, 0)

  '**** Beginning of flux and quality classification data ***
  Sample (1, Fc_molar,    IEEE4)    'Carbon dioxide flux in umol/(m^2 s) after coordinate rotations, freq corrections, and WPL correction
  Sample (1, Fc_mass,     IEEE4)    'Carbon dioxide flux in mg/(m^2 s) after coordinate rotations, freq corrections, and WPL correction
  Sample (1, Fc_qc_grade, UINT2)    'Overall grade of data quality for carbon dioxide flux (i.e. for variables: Fc_molar and Fc_mass)
  Totalize (1, n, IEEE4, (sonic_disable_f OR irga_disable_f OR CO2_bad_rng_sig_array(MAX_LAG +1)))    'Totalize the number of samples for CO2 flux
  FieldNames ("Fc_samples_Tot")
  Sample (1, LE,          IEEE4)    'Latent heat flux after coordinate rotations, freq corrections, and WPL correction
  Sample (1, LE_qc_grade, UINT2)    'Overall grade of data quality for latent heat flux (i.e. for variable: LE)
  Totalize (1, n, IEEE4, (sonic_disable_f OR irga_disable_f OR H2O_bad_rng_sig_array(MAX_LAG +1)))    'Totalize the number of samples for latent heat flux
  FieldNames ("LE_samples_Tot")
  Sample (1, H,           IEEE4)    'Sensible heat flux (derived from sonic heat flux with SND correction after coordinate rotations and freq corrections)
  Sample (1, H_qc_grade,  UINT2)    'Overall grade of data quality for for sensible heat flux (i.e. for variable: H)
  Totalize (1, n, IEEE4, (sonic_disable_f OR irga_disable_f OR H2O_bad_rng_sig_array(MAX_LAG +1)))  'Totalize the number of samples for sensible heat flux
  FieldNames ("H_samples_Tot")

  #If (SENSOR_FW) Then
  Sample  (1, H_FW,       IEEE4)    'Sensible heat flux measured using fine wire thermocouple (FW) after coordinate rotations and freq corrections
  Totalize   (1, n,  IEEE4, (sonic_disable_f OR FW_bad_data_flg))               'Totalize the number of samples for FW-measured sensible heat flux
  FieldNames ("H_FW_samples_Tot")
  #EndIf

  #If (SENSOR_Rn) Then

  '*** Beginning of net radiometer output data ***
  Sample (1, Rn, IEEE4)
  '*** End of net radiomete output data ***
  #EndIf
  #If ((SENSOR_HFP) AND  (SENSOR_CS6XX)) AND ((SENSOR_TCAV) OR (SENSOR_CS65X)))  Then

  Sample (1, G_surface, IEEE4)       'Soil heat flux at the ground surface
  #EndIf
  #If ((SENSOR_Rn) AND (SENSOR_HFP) AND (SENSOR_CS6XX) AND  ((SENSOR_TCAV) OR (SENSOR_CS65X)))   Then

  Sample (1, energy_closure,IEEE4)    'Energy closure
  #EndIf

  Sample (1, Bowen_ratio,   IEEE4)
  Sample (1, tau,           IEEE4)    'Momentum flux after coordinate rotations and freq corrections,
  Sample (1, tau_qc_grade,  UINT2)    'Overall grade of data quality for momentum flux (i.e. for variable: tau)

  '*** Turbulence characteristic variables ****
  Sample (1, u_star,        IEEE4)    'Friction velocity after coordinate rotations and freq corrections
  Sample (1, T_star,        IEEE4)    'Scaling temperature after coordinate rotations and freq corrections
  Sample (1, TKE,           IEEE4)    'Specific turbulence kinetic enegrgy after coordinate rotations
  Sample (1, amb_tmpr_Avg,  IEEE4)    'Air temperature from EC100 temperature probe
  #If (SENSOR_IRGASON) Then
  Sample (1, Tc_Avg,        IEEE4)    'air temperature calculated from IRASON measurements of sonic temperature, water vapor density, and pressure
  Average(1, Td,            IEEE4, (irga_disable_f OR sonic_disable_f OR H2O_bad_rng_sig_array(MAX_LAG +1)))
  #EndIf

  #If (NOT SENSOR_IRGASON) Then
  Average (1, Td,           IEEE4, (irga_disable_f OR irga_amb_tmpr_f OR H2O_bad_rng_sig_array(MAX_LAG +1)))
  #EndIf

  Sample (1, RH_Avg,        IEEE4)    'Calculated from Tc and H2O if IRGASON and from amb_tmpr_Avg and H2O if CSAT3A + EC150.
  Sample (3, e_sat_Avg,     IEEE4)    'e_sat_Avg, e_Avg, and amb_press_Avg
  Sample (1, VPD_air,       IEEE4)    'Air vapor pressure deficit

  '*** Beginning of sonic head output data ***
  '** Before coordinate rotation
  Sample (2, Ux_Avg,        IEEE4)    'Ux_avg and Ux_Std
  Sample (2, Uy_Avg,        IEEE4)    'Uy_avg and Uy_Std
  Sample (2, Uz_Avg,        IEEE4)    'Uz_avg and Uz_Std
  Sample (2, Ts_Avg,        IEEE4)    'Ts_avg and Ts_Std
  Sample (1, sonic_azimuth, IEEE4)    'Sonic_azimuth, (see Section 3.2.1 CSAT3A Azimuth in the OPEC manual).
  Sample (5, wnd_spd,       IEEE4)    'The last 5 elements in array of cov_out_sonic.
  Sample (1, CO2_molfrac_Avg, IEEE4)                                                                 'CO2 mole fraction

  #If (SENSOR_IRGASON) Then
  Average(1, CO2_mixratio, IEEE4, (irga_disable_f OR sonic_disable_f OR H2O_bad_rng_sig_array(MAX_LAG +1)))
  #EndIf

  #If (NOT SENSOR_IRGASON) Then
  Average(1, CO2_mixratio, IEEE4, (irga_disable_f))
  #EndIf
  Sample (2, CO2_Avg, IEEE4)                                                                          'CO2 mass density, CO2_Avg and CO2_Std
  Sample (1, H2O_molfrac_Avg, IEEE4)    'H2O mole fraction

  #If (SENSOR_IRGASON) Then
  Average(1, H2O_mixratio, IEEE4, (irga_disable_f OR sonic_disable_f OR H2O_bad_rng_sig_array(MAX_LAG +1)))
  #EndIf

  #If (NOT SENSOR_IRGASON) Then
  Average(1, H2O_mixratio, IEEE4, (irga_disable_f OR irga_amb_tmpr_f OR H2O_bad_rng_sig_array(MAX_LAG +1)))
  #EndIf
  Sample (2, H2O_Avg, IEEE4)          'H2O mass density: H2O_Avg and H2O_Std
  
  Minimum (1, CO2_sig_strgth, IEEE4, irga_disable_f, FALSE)
  FieldNames ("CO2_sig_strgth_Min")

  Minimum (1, H2O_sig_strgth, IEEE4, irga_disable_f, FALSE)
  FieldNames ("H2O_sig_strgth_Min")

  #If (SENSOR_FW) Then
  '*** Beginning of FW output data ***
  '** Before coordinate rotation
  Sample (1, FW_Avg, IEEE4)
  Sample (1, FW_Std, IEEE4)
  #EndIf
  #If (SENSOR_TMPR_RH) Then

  '*** Beginning of temperature and humidity probe output data ***
  Sample  (3, T_probe_Avg,     IEEE4)                                           'Measured from temperaure and humidity probe: T_probe_Avg, e_probe_Avg, and e_sat_probe_Avg
  Average (1, Td_probe,        IEEE4, slowsequence_disable_flg)                 'Measured from temperaure and humidity probe: dew point temperaure
  Sample  (3, H2O_probe_Avg,   IEEE4)                                           'Measured from temperaure and humidity probe: H2O_probe_Avg, RH_probe_Avg, and rho_a_probe_Avg
  Sample  (1, rho_d_probe_Avg, IEEE4)                                           'Measured from temperaure and humidity probe: dry air density in kg/m^3
  '*** End of temperature and humidity probe output data ***
  #EndIf
  #If (SENSOR_TE525x) Then

  '*** Beginning of rain gauge output data ***
  Totalize (1, Precipitation, FP2, 0)
  '*** End of rain gauge output data ***
  #EndIf
  #If (SENSOR_NR_LITE) Then

  Average (1, Rn_meas, IEEE4, slowsequence_disable_flg)
  #EndIf
  #If ((SENSOR_NR01) OR (SENSOR_CNR4)) Then

  '*** Beginning of 4-way radiometer output data ***
  Average (8, albedo, IEEE4, slowsequence_disable_flg)                          'albedo, R_SW_in, R_SW_out, R_SW_in, R_SW_out, T_nr, R_LW_in_meas, and R_LW_out_meas
  '*** End of 4-way radiometer output data ***

  #EndIf
  #If (SENSOR_LI200X) OR (SENSOR_CS300) Then

  '*** Beginning of LI200X output data ***
  Average  (1, R_pyran, IEEE4, slowsequence_disable_flg)
  '*** End of LI200X output data ***
  #EndIf
  #If (SENSOR_LI190SB) Then

  '*** Beginning of LI190SB output data ***
  Average  (1, PAR_density, IEEE4, slowsequence_disable_flg)
  '*** End of LI190SB output data ***
  #EndIf
  #If (SENSOR_SI111) Then

  '*** Beginning of SI111 output data ***
  Average  (1, T_SI111_targeted, IEEE4, slowsequence_disable_flg)
  Average  (1, T_SI111_body,     IEEE4, slowsequence_disable_flg)
  '*** End of SI111 output data ***
  #EndIf
  #If (SENSOR_TCAV) Then

  '*** Beginning of TCAV output data ***
  Average (NMBR_TCAV, Tsoil(1), IEEE4, slowsequence_disable_flg)
  '*** End of TCAV output data ***

  #EndIf
  #If (SENSOR_CS616) Then

  '*** Beginning of CS616 output data ***
  #If ((SENSOR_CS616) AND (SENSOR_TCAV)) Then
  Average (NMBR_CS6xx, soil_wtr_T(1), IEEE4, slowsequence_disable_flg)           'Volumetric soil water w/ temperature correction
  #EndIf

  #If ((SENSOR_CS616)) AND (NOT SENSOR_TCAV) Then
  Average (NMBR_CS6xx, soil_wtr(1), IEEE4, slowsequence_disable_flg)             'Volumetric soil water w/o temperature correction
  #EndIf

  Average (NMBR_CS6xx, cs616_wcr(1),  IEEE4, slowsequence_disable_flg)           'CS616 period.
  '*** End of CS616 output data ***

  #EndIf
  #If (SENSOR_CS65X) Then

  '*** Beginning of CS65X output data ***
  Average (NMBR_CS6xx, cs65x_wc(1),  IEEE4, slowsequence_disable_flg)            'Volumetric soil water content.
  Average (NMBR_CS6xx, cs65x_ec(1),  IEEE4, slowsequence_disable_flg)            'Electrical conductivity.
  Average (NMBR_CS6xx, cs65x_tmpr(1),IEEE4, slowsequence_disable_flg)            'CS65X probe temperature.
  '*** End of CS65X output data ***
  #EndIf
  #If (SENSOR_HFP) Then

  '*** Beginning of HFP01 output data ***
  Sample (NMBR_SHFP, shf_plate_avg(1), IEEE4)                                    'Heat flux through a soil heat flux plate
  '*** End of HFP01 output data ***
  #EndIf
  #If (SENSOR_HFP01SC) Then

  '*** Beginning of HFP01SC output data ***
  Sample (NMBR_SHFP, shf_plate_cal(1), IEEE4)                                    'Calibrations of self-calibrated soil heat flux plate
  '*** End of HFP01SC output data ***
  #EndIf

  '*** Footprint characteristics ****
  Sample (1, upwnd_dist_intrst, IEEE4)  'User-entered upwind distance of interest for the average upwind direction in this averaging interval
  Sample (1, FP_dist_intrst,    IEEE4)  'Percentage of measured scalar flux from upwind range of interest
  Sample (1, FP_max,            IEEE4)  'Upwind location of source/sink that contributes most to the measured flux
  Sample (1, FP_40,             IEEE4)  'Upwind range within which sources/sinks contributes 40% the measured flux
  Sample (1, FP_55,             IEEE4)  'Upwind range within which sources/sinks contributes 55% the measured flux
  Sample (1, FP_90,             IEEE4)  'Upwind range within which sources/sinks contributes 90% the measured flux
  Sample (1, FP_Equation,       String) 'Type of footprint equation: Kljun et al or KormannMeixner

  #If (NOT (ONE_FULL_TABLE)) Then
EndTable
'*** End of FLUX Table ****

'*** Beginning of FLUX_NOTES Table *****
DataTable (Flux_Notes, TRUE, FLUX_SIZE_CPU)
  DataInterval (0, OUTPUT_INTERVAL, Min, 10)
  TableFile ("CRD:"&Status.SerialNumber(1,1)&".Flux_NOTES_", 64, -1, 0,NMBR_DAY_FLUX_CRD, Day, 0, 0)
  #EndIf

  '*** Beginning of sonic head output data ***
  '** Before coordinate rotation
  Sample (2, UxUy_Cov,  IEEE4)    'UxUy_Cov and UxUz_Cov.
  Sample (1, UyUz_Cov,  IEEE4)
  Sample (3, TsUx_Cov,  IEEE4)    'TsUx_Cov, TsUy_Cov, and TsUz_Cov

  '** _R indicates after coordinate rotations
  Sample (1, u_star_R,  IEEE4)    'Friction velocity after coordinate rotations.
  Sample (1, u_Avg_R,   IEEE4)
  Sample (1, u_Std_R,   IEEE4)
  Sample (1, v_Avg_R,   IEEE4)
  Sample (1, v_Std_R,   IEEE4)
  Sample (1, w_Avg_R,   IEEE4)
  Sample (1, w_Std_R,   IEEE4)
  Sample (1, uv_Cov_R,  IEEE4)
  Sample (1, uw_Cov_R,  IEEE4)
  Sample (1, vw_Cov_R,  IEEE4)
  Sample (1, uTs_Cov_R, IEEE4)
  Sample (1, vTs_Cov_R, IEEE4)
  Sample (1, wTs_Cov_R, IEEE4)

  '*** _F indicates after frequency corrections
  Sample (1, uw_Cov_R_F,  IEEE4)
  Sample (1, vw_Cov_R_F,  IEEE4)
  Sample (1, wTs_Cov_R_F, IEEE4)

  '** After coordinate rotations, freq corrections, and SND correction as indicated by R_F_SND.
  Sample (1, wTs_Cov_R_F_SND, IEEE4)
  
  '** Summary of diagnosis flags of sonic
  Totalize (1, n, IEEE4, sonic_disable_f)  'Totalize the number of sonic samples without diagnostic flags
  FieldNames ("sonic_samples_Tot")
  Totalize (1, n, IEEE4, diag_sonic <> -1)
  FieldNames ("no_sonic_head_Tot")
  Totalize (1, n, IEEE4, diag_sonic <> NAN)
  FieldNames ("no_new_sonic_data_Tot")
  Totalize (1, n, IEEE4, sonic_amp_l_f   IMP (diag_sonic = NAN))
  FieldNames ("sonic_amp_l_f_Tot")
  Totalize (1, n, IEEE4, sonic_amp_h_f   IMP (diag_sonic = NAN))
  FieldNames ("sonic_amp_h_f_Tot")
  Totalize (1, n, IEEE4, sonic_sig_lck_f IMP (diag_sonic = NAN))
  FieldNames ("sonic_sig_lck_f_Tot")
  Totalize (1, n, IEEE4, sonic_del_T_f   IMP (diag_sonic = NAN))
  FieldNames ("sonic_del_T_f_Tot")
  Totalize (1, n, IEEE4, sonic_aq_sig_f  IMP (diag_sonic = NAN))
  FieldNames ("sonic_aq_sig_f_Tot")
  Totalize (1, n, IEEE4, sonic_cal_err_f IMP (diag_sonic = NAN))
  FieldNames ("sonic_cal_err_f_Tot")
  '*** End of sonic head output data ***

  '*** Beginning of IRGA output data ***
  '** Before coordinate rotation
  Sample  (3, UxCO2_Cov,  IEEE4)    'UxCO2_Cov, UyCO2_Cov, UzCO2_Cov
  Sample  (3, UxH2O_Cov,  IEEE4)    'UxH2O_Cov, UyH2O_Cov, UzH2O_Cov

  '** _R indicates after coordinate rotations
  Sample (1, uCO2_Cov_R,   IEEE4)
  Sample (1, vCO2_Cov_R,   IEEE4)
  Sample (1, wCO2_Cov_R,   IEEE4)

  Sample (1, uH2O_Cov_R,   IEEE4)
  Sample (1, vH2O_Cov_R,   IEEE4)
  Sample (1, wH2O_Cov_R,   IEEE4)

  '*** _R_F indicates after coordinate rotations and frequency corrections
  Sample (1, wCO2_Cov_R_F, IEEE4)
  Sample (1, wH2O_Cov_R_F, IEEE4)
  Sample (1, CO2_E_WPL_R_F, IEEE4)    'CO2 flux, WPL term due to water vapor flux (WPL here denots "WPL term for WPL correction" instead of WPL correction)
  Sample (1, CO2_T_WPL_R_F, IEEE4)    'CO2 flux, WPL term due to temperature flux (WPL here denots "WPL term for WPL correction" instead of WPL correction)
  Sample (1, H2O_E_WPL_R_F, IEEE4)    'H2O flux, WPL term due to water vapor flux (WPL here denots "WPL term for WPL correction" instead of WPL correction)
  Sample (1, H2O_T_WPL_R_F, IEEE4)    'H2O flux, WPL term due to temperature flux (WPL here denots "WPL term for WPL correction" instead of WPL correction)

  '** Summary of diagnosis flags of IRGA
  Totalize (1, n, IEEE4, (irga_disable_f OR CO2_bad_rng_sig_array(MAX_LAG +1)))
  FieldNames ("CO2_samples_Tot")
  Totalize (1, n, IEEE4, (irga_disable_f OR H2O_bad_rng_sig_array(MAX_LAG +1)))
  FieldNames ("H2O_samples_Tot")
  
  Totalize (1, n, IEEE4, diag_irga <> -1)
  FieldNames ("no_irga_head_Tot")
  Totalize (1, n, IEEE4, diag_irga <> NAN)
  FieldNames ("no_new_irga_data_Tot")
  Totalize (1, n, IEEE4, irga_bad_data_f       IMP (diag_irga = NAN))
  FieldNames ("irga_bad_data_f_Tot")
  Totalize (1, n, IEEE4, irga_gen_fault_f      IMP (diag_irga = NAN))
  FieldNames ("irga_gen_fault_f_Tot")
  Totalize (1, n, IEEE4, irga_startup_f        IMP (diag_irga = NAN))
  FieldNames ("irga_startup_f_Tot")
  Totalize (1, n, IEEE4, irga_motor_spd_f      IMP (diag_irga = NAN))
  FieldNames ("irga_motor_spd_f_Tot")
  Totalize (1, n, IEEE4, irga_tec_tmpr_f       IMP (diag_irga = NAN))
  FieldNames ("irga_tec_tmpr_f_Tot")
  Totalize (1, n, IEEE4, irga_src_pwr_f        IMP (diag_irga = NAN))
  FieldNames ("irga_src_pwr_f_Tot")
  Totalize (1, n, IEEE4, irga_src_tmpr_f       IMP (diag_irga = NAN))
  FieldNames ("irga_src_tmpr_f_Tot")
  Totalize (1, n, IEEE4, irga_src_curr_f       IMP (diag_irga = NAN))
  FieldNames ("irga_src_curr_f_Tot")
  Totalize (1, n, IEEE4, irga_off_f            IMP (diag_irga = NAN))
  FieldNames ("irga_off_f_Tot")
  Totalize (1, n, IEEE4, irga_sync_f           IMP (diag_irga = NAN))
  FieldNames ("irga_sync_f_Tot")
  Totalize (1, n, IEEE4, irga_amb_tmpr_f       IMP (diag_irga = NAN))
  FieldNames ("irga_amb_tmpr_f_Tot")
  Totalize (1, n, IEEE4, irga_amb_press_f      IMP (diag_irga = NAN))
  FieldNames ("irga_amb_press_f_Tot")
  Totalize (1, n, IEEE4, irga_CO2_I_f          IMP (diag_irga = NAN))
  FieldNames ("irga_CO2_I_f_Tot")
  Totalize (1, n, IEEE4, irga_CO2_Io_f         IMP (diag_irga = NAN))
  FieldNames ("irga_CO2_Io_f_Tot")
  Totalize (1, n, IEEE4, irga_H2O_I_f          IMP (diag_irga = NAN))
  FieldNames ("irga_H2O_I_f_Tot")
  Totalize (1, n, IEEE4, irga_H2O_Io_f         IMP (diag_irga = NAN))
  FieldNames ("irga_H2O_Io_f_Tot")
  Totalize (1, n, IEEE4, irga_CO2_Io_var_f     IMP (diag_irga = NAN))
  FieldNames ("irga_CO2_Io_var_f_Tot")
  Totalize (1, n, IEEE4, irga_H2O_Io_var_f     IMP (diag_irga = NAN))
  FieldNames ("irga_H2O_Io_var_f_Tot")
  Totalize (1, n, IEEE4, irga_CO2_sig_strgth_f IMP (diag_irga = NAN))
  FieldNames ("irga_CO2_sig_strgth_f_Tot")
  Totalize (1, n, IEEE4, irga_H2O_sig_strgth_f IMP (diag_irga = NAN))
  FieldNames ("irga_H2O_sig_strgth_f_Tot")
  Totalize (1, n, IEEE4, irga_cal_err_f        IMP (diag_irga = NAN))
  FieldNames ("irga_cal_err_f_Tot")
  Totalize (1, n, IEEE4, irga_htr_ctrl_off_f   IMP (diag_irga = NAN))
  FieldNames ("irga_htr_ctrl_off_f_Tot")

  '*** End of IRGA output data ***

  #If (SENSOR_FW) Then
  '*** Beginning of FW output data ***
  '** Before coordinate rotation
  Sample (1, UxFW_Cov, IEEE4)
  Sample (1, UyFW_Cov, IEEE4)
  Sample (1, UzFW_Cov, IEEE4)

  '** _R indocates after coordinate rotations
  Sample  (1, uFW_Cov_R, IEEE4)
  Sample  (1, vFW_Cov_R, IEEE4)
  Sample  (1, wFW_Cov_R, IEEE4)

  ' ** _R_F indicates after coordinate rotations and freq corrections
  Sample  (1, wFW_Cov_R_F, IEEE4)
  
  Totalize   (1, n,  IEEE4, FW_bad_data_flg)
  FieldNames ("FW_samples_Tot")
  '*** End of FW output data ***
  #EndIf

  ' *** Variables used for correction ***
  '** Rotation-related variables
  Sample (1, alpha, IEEE4)                   'Pitch angle
  Sample (1, beta,  IEEE4)                   'Roll angle
  Sample (1, gamma, IEEE4)                   'Yaw angle

  '** Stability-related variables
  Sample (1, height_measurement,    IEEE4)   'Measurement height (m)
  Sample (1, height_canopy,         IEEE4)   'Canopy height (m).
  Sample (1, surface_type_text,    String)   'Crop, Grass, Forest, Shrub, Bare Land, Water
  Sample (1, displacement_user,     IEEE4)   'Displacement height input by a user (0 is fefault and d is auto calculated and is used)
  Sample (1, d,                     IEEE4)   'Displacement height used by program d = displacement_user if displacement_user <> 0; otherwise, it is auto calculated
  Sample (1, roughness_user,        IEEE4)   'Roughness length input by a user (0 is fefault and z0 is auto calculated and is used)
  Sample (1, z0,                    IEEE4)   'Roughness length used by program z0 = displacement_user if roughness_user <> 0; otherwise, it is auto calculated
  Sample (1, z,                     IEEE4)   'Aerodynamic height
  Sample (1, L,                     IEEE4)   'Obukhov length
  Sample (1, stability_zL,          IEEE4)   'Atmospheric boundary-layer stability.
  Sample (1, iteration_FreqFactor,  UINT2)   'Iteration number in calculation of freq correction factor for u'w', v'w', and Ts'w'
  Sample (1, latitude,              IEEE4)
  Sample (1, longitude,             IEEE4)

  '** Freq correction related variables
  ' IRGA separation variables
  Sample (2, separation_x_irga,        IEEE4)  'The 11st to 12nd elements of stn_conf_array: separation_x_irga, separation_y_irga
  Sample (1, separation_lat_dist_irga, IEEE4)  'Separation distance in direction normal to wind direction. Used for separation correction
  Sample (1, separation_lag_dist_irga, IEEE4)  'Separation distance along wind direction. Used for lag maximization
  Sample (1, separation_lag_scan_irga, IEEE4)  'Lag in scan number as the wind passes IRGA after passing the sonic volume. Not neccessary to use integer.

  #If (SENSOR_FW) Then
  Sample (3, separation_x_FW,          IEEE4)  'The 17th, 18th, and 19th elements of stn_conf_array: separation_x_FW, separation_y_FW, and FW_diameter
  Sample (1, separation_lat_dist_FW,   IEEE4)  'Separation distance in direction normal to wind direction. Used for separation correction
  Sample (1, separation_lag_dist_FW,   IEEE4)  'Separation distance along wind direction. Used for lag maximization
  Sample (1, separation_lag_scan_FW,   IEEE4)  'Lag in scan number the wind passes FW after passing the sonic volume. Not neccessary to use integer.
  Sample (1, time_const_FW,            IEEE4)
  #EndIf

  Sample (1, MAX_LAG,  UINT2)
  FieldNames ("MAX_LAG")
  Sample (1, lag_irga, IEEE4)

  #If (SENSOR_FW) Then
  Sample (1, lag_FW,   IEEE4)
  #EndIf

  Sample (1, FreqFactor_uw_vw,     IEEE4)  'Frequency correction factor for wu and wv
  Sample (1, FreqFactor_wTs,       IEEE4)  'Frequency correction factor for wTs
  Sample (1, FreqFactor_wCO2_wH2O, IEEE4)  'Frequency correction factor for covariance of CSI (CS) open-path (OPEC) vertical wind with h2o and co2

  #If (SENSOR_FW) Then
  Sample (1, FreqFactor_wFW,       IEEE4)  'Frequency correction factor for covariance of vertical wind with fine thermocouple (FW) Temperature
  #EndIf
  ' *** End of correction related variables ***

  ' *** Output air properties calculated using measurements ***
  Sample (2, rho_d_Avg, IEEE4)                  'density of dry air (kg/m^3) and density of moist air (kg/m^3). Both are calculated using Tc if IRGASON or 107 temperature if CSAT3A+EC150
  Sample (1, Cp,         IEEE4)                 'specific heat of moist air at constant pressure, calculated using measurements from IRGASON [J/(kg K)]
  Sample (1, Lv,         IEEE4)                 'latent heat of vaporization [J/g].
  ' *** End of output atmospheric constants ***

  '*** Beginning of other output data ***
  Average  (1, panel_tmpr, IEEE4, FALSE)
  Average  (1, batt_volt,  IEEE4, slowsequence_disable_flg)
  Totalize (1, n,          IEEE4, slowsequence_disable_flg)
  FieldNames ("slowsequence_Tot")
  '*** End of other output data ***

  Average  (1, process_time, IEEE4, FALSE)
  Maximum  (1, process_time, IEEE4, FALSE, FALSE)
  FieldNames ("process_time_Max")
  Maximum  (1, buff_depth,   IEEE4, FALSE, FALSE)
  FieldNames ("buff_depth_Max")

EndTable

'Diagnostic data.
DataTable (diagnostic, TRUE, 1)
  Sample (6, sonic_amp_l_f,    Boolean)
  Sample (22, irga_bad_data_f, Boolean)
EndTable

'Time series data.
DataTable (Time_Series, TRUE, -1)
  DataInterval (0, SCAN_INTERVAL, mSec, 100)
  TableFile ("CRD:"&Status.SerialNumber(1,1)&".Time_Series_", 64, -1, 0, NMBR_DAY_TIMESERIES_CRD, Day, 0, 0)

  '*** Beginning of sonic time series output ***
  Sample (3, Ux, IEEE4)
  FieldNames ("Ux,Uy,Uz")
  Sample (1, Ts, IEEE4)
  FieldNames ("Ts")
  Sample (1, diag_sonic, IEEE4)
  FieldNames ("diag_sonic")
  '*** End of sonic time series output ***

  '*** Beginning of IRGA time series output ***
  Sample (3, irga(1),IEEE4)
  FieldNames ("CO2,H2O,diag_irga")

  #If (SENSOR_IRGASON) Then
  Sample (1, Tc, IEEE4)
  FieldNames ("Tc")
  #EndIf

  Sample (4, amb_tmpr,IEEE4)
  FieldNames ("amb_tmpr,amb_press, CO2_sig_strgth, H2O_sig_strgth")
  '*** End of IRGA time series output ***

  #If (SENSOR_FW) Then
  '*** Beginning of FW time series output ***
  Sample (1, FW, IEEE4)
  FieldNames ("FW")
  '*** End of FW time series output ***
  #EndIf

EndTable

'*******************'
'*** SUBROUTINEs ***'
'*******************'

'*** Sub-programs for coordinate rotation corrections  ***
' 1. Two sub-programs for Double Rotations
'    a. Rotations for momentum covariance
'    b. Rotations for covariance of momentum variable with scalar variables

' Definition of double rotation: the 1st AND 2nd rotations in Tanner & Thurtell (1969)
'      a. Counterclockwise about the instrument z-axis for Gamma degrees
'      b. Counterclockwise about the intermediate y-axis for Alpha degrees
'         [Originally clockwise. Following Wilczak et al. (2001), counterclockwise rotation is used]

' Sub: Rotation12_Momentum (where "12" indicates the 1st and 2nd rotations)
'      Transform the expression of momentum variables in the instrument coordinate system to the natural wind coordinate system.
Sub Rotation12_Momentum(alph, gamm, _
  U_mean,  V_mean,  W_mean,  UU_cov,  VV_cov,  WW_cov,  UV_cov,  UW_cov,  VW_cov, _
  Umean_R, Vmean_R, Wmean_R, UUcov_R, VVcov_R, WWcov_R, UVcov_R, UWcov_R, VWcov_R )

  ' For effiecient calculations, effiecient use of memory, and shorter expressions in the following equations, the variables of "UWcov_R" and
  ' "VWcov_R" are used first as intermediate variables before both variables are needed for their own roles.
  UWcov_R =  UU_cov*COS(gamm)*COS(gamm) + VV_cov*SIN(gamm)*SIN(gamm)
  VWcov_R =  UW_cov*COS(gamm) + VW_cov*SIN(gamm)

  ' a. ROTATIONS FOR MEAN TERMS
  Umean_R = COS(alph)*(U_mean*COS(gamm) + V_mean*SIN(gamm)) - W_mean*SIN(alph)
  Vmean_R = 0
  Wmean_R = SIN(alph)*(U_mean*COS(gamm) + V_mean*SIN(gamm)) + W_mean*COS(alph)

  ' b. ROTATIONS FOR VARIANCE TERMS
  UUcov_R = COS(alph)*COS(alph)*UWcov_R + _
  WW_cov*SIN(alph)*SIN(alph) + UV_cov*COS(alph)*COS(alph)*SIN(2*gamm) - _
  SIN(2*alph)*VWcov_R

  VVcov_R = UU_cov*SIN(gamm)*SIN(gamm) + VV_cov*COS(gamm)*COS(gamm) - UV_cov*SIN(2*gamm)

  WWcov_R = SIN(alph)*SIN(alph)*UWcov_R  + _
  WW_cov*COS(alph)*COS(alph) + UV_cov*SIN(alph)*SIN(alph)*SIN(2*gamm) + _
  SIN(2*alph)*VWcov_R

  'b. ROTATIONS FOR COVARIANCE TERMS
  UVcov_R = -0.5*(UU_cov - VV_cov)*COS(alph)*SIN(2*gamm) + _
  UV_cov*COS(alph)*COS(2*gamm) + _
  SIN(alph)*(UW_cov*SIN(gamm) - VW_cov*COS(gamm))

  UWcov_R =  0.5*SIN(2*alph)*(UWcov_R - WW_cov + UV_cov*SIN(2*gamm)) + COS(2*alph)*VWcov_R

  VWcov_R = -SIN(alph)*(0.5*(UU_cov - VV_cov)*SIN(2*gamm)-UV_cov*COS(2*gamm))- _
  COS(alph)*(UW_cov*SIN(gamm) - VW_cov*COS(gamm))

EndSub

' Sub: Rotation12_Scalar_Covariance [where "12" indicates the 1st and 2nd rotations in Tanner & Thurtell (1969)]
'      Transform the expression of variance of scalar with momentum variables in the instrument coordinate system
'      to the natural wind coordinate system in x and y.

Sub Rotation12_Scalar_Covariance(alph, gamm, SU_cov,  SV_cov, SW_cov, SUcov_R, SVcov_R, SWcov_R)

  SUcov_R =  COS(alph)*(SU_cov*COS(gamm) + SV_cov*SIN(gamm)) - SW_cov*SIN(alph)

  SVcov_R = -SU_cov*SIN(gamm) + SV_cov*COS(gamm)

  SWcov_R =  SIN(alph)*(SU_cov*COS(gamm) + SV_cov*SIN(gamm)) + SW_cov*COS(alph)

EndSub

' 2. Sub-programs for Planar Fit Rotations [Wilczak et al. (2001)]
'    a. Rotations for momentum covariance
'    b. Rotations for covariance of momentum variable with scalar variables

'    Planar Fit Rotations
'      a. Counterclockwise rotation about the instrument y-axis for Alph degrees  [2nd rotation in Tanner and Thurtell (1969), clockwise]
'      b. Counterclockwise rotation about the intermediate x-axis for Beta degrees [3rd rotation in Tanner and Thurtell (1969)]

' Sub: Rotation23_Momentum [where "23" indicates the 2nd and 3rd rotations in Tanner & Thurtell (1969)]
Sub Rotation23_Momentum(alph, bet, _
  U_mean,  V_mean,  W_mean,  UU_cov,  VV_cov,  WW_cov,  UV_cov,  UW_cov,  VW_cov, _
  Umean_R, Vmean_R, Wmean_R, UUcov_R, VVcov_R, WWcov_R, UVcov_R, UWcov_R, VWcov_R )

  ' For efficient calculations, efficient use of memory, and shorter expressions in the following equations, the four variables of Wmean_R, UVcov_R,
  ' UWcov_R, and VWcov_R are used first as intermediate variables for repeated terms before the four variables are needed for their own roles.
  Wmean_R =  V_mean*SIN(bet) - W_mean*COS(bet)
  UVcov_R =  VV_cov*SIN(bet)*SIN(bet) - VW_cov*SIN(2*bet) + WW_cov*COS(bet)*COS(bet)
  UWcov_R =  UV_cov*SIN(bet) - UW_cov*COS(bet)
  VWcov_R =  UV_cov*COS(bet) + UW_cov*SIN(bet)

  ' a. ROTATIONS FOR MEAN TERMS
  Umean_R = U_mean*COS(alph) +  Wmean_R*SIN(alph)
  Vmean_R = V_mean*COS(bet)  +  W_mean  *SIN(bet)
  Wmean_R = U_mean*SIN(alph) -  Wmean_R*COS(alph)

  ' b. ROTATIONS FOR VARIANCE TERMS
  UUcov_R = UU_cov*COS(alph)*COS(alph) + UVcov_R*SIN(alph)*SIN(alph) + UWcov_R*SIN(2*alph)

  VVcov_R = VV_cov*COS(bet)*COS(bet)   + VW_cov*SIN(2*bet)           + WW_cov*SIN(bet)*SIN(bet)

  WWcov_R = UU_cov*SIN(alph)*SIN(alph) + UVcov_R*COS(alph)*COS(alph) - UWcov_R*SIN(2*alph)

  'b. ROTATIONS FOR COVARIANCE TERMS
  UVcov_R = SIN(alph)*(0.5*(VV_cov - WW_cov)*SIN(2*bet)- VW_cov*COS(2*bet)) + COS(alph)*VWcov_R

  UWcov_R = 0.5*SIN(2*alph)*(UU_cov - VV_cov*SIN(bet)*SIN(bet) -WW_cov*COS(bet)*COS(bet)+ VW_cov*SIN(2*bet))- COS(2*alph)*UWcov_R

  VWcov_R = -COS(alph)*(0.5*(VV_cov - WW_cov)*SIN(2*bet)-VW_cov*COS(2*bet))+SIN(alph)*VWcov_R

EndSub

' Sub: Rotation23_Scalar_Covariance [where "23" indicates the 2nd and 3rd rotations in Tanner & Thurtell (1969)]
'      Transform the expression of covariance of scalar with momentum variables in the instrument coordinate system
'      to the natural wind coordinate system in z.

Sub Rotation23_Scalar_Covariance(alph, bet, _
  SU_cov,   SV_cov,   SW_cov, _
  SU_cov_R, SV_cov_R, SW_cov_R)

  SU_cov_R =  SU_cov*COS(alph) + SIN(alph)*(SV_cov*SIN(bet) - SW_cov*COS(bet))

  SV_cov_R =  SV_cov*COS(bet)  + SW_cov*SIN(bet)

  SW_cov_R =  SU_cov*SIN(alph) - COS(alph)*(SV_cov*SIN(bet) - SW_cov*COS(bet))

EndSub

'*** Sub: calculate displacement height and aerodynamic height

'         Variable Notation
'  SUBROUTINE             MAIN PROGRAM
' S_type                 Surface_type
' d_user                 displacement_user
' z0_user                Roughness_user
' h_canopy               height_canopy
' h_measurement          height_measurement
' displacement           d
' Roughness              z0
' h_aerodynamic          z (sensing height above the ground - d)

'*** Beginning the calculations of displacement height, roughness length, and aerodynamic height  ***
Sub  Displacement_roughness_heights (S_type, d_user, z0_user, h_canopy, h_measurement, displacement, roughness, h_aerodynamic)
  ' Calculate displacement height, roughness length, and aerodynamic height
  If ((S_type = CROP) OR (S_type = GRASS)) Then            'Crop and grass

    Select Case h_canopy
    Case Is = 0
      displacement = 0                                  'Default w/o canopy
      roughness    = 0.01                               'Default w/o canopy
    Case Is >0
      displacement = 10.0^(0.979*LOG10(h_canopy)-0.154)   'Crop or grass canopy, Eq. 4.5, page 138 in Rosenberg et al. (1983)
      roughness    = 10.0^(0.977*LOG10(h_canopy)-0.883)   'Crop or grass canopy, Eq. 4.4, page 137 in Rosenberg et al. (1983)
    EndSelect

  EndIf

  If ((S_type = FOREST) OR (S_type = SHRUB)) Then           'Forest and Shrub
    displacement = 2*h_canopy/3                            'Forest canopy, 2/3 rule, page 116, Oke, 1987
    roughness    = 0.06*h_canopy                           'Forest canopy, Jarvis et al. (1976) ans Raupach et al. (1991)
  EndIf

  If ((S_type = BARELAND) OR (S_type = WATER)) Then         'Bare land and water
    displacement = 0                                       'Default w/o canopy
    roughness    = 0.01                                    'Default w/o canopy
  EndIf

  If (d_user <> 0)  Then displacement = d_user              'User preferred has a priority
  If (z0_user <> 0) Then roughness    = z0_user             'User preferred has a priority

  h_aerodynamic = h_measurement - displacement
EndSub
'*** End the calculations of displacement height, roughness length, and aerodynamic height ***

'*** Beginning subroutines for freq correction factors ***
'         Variable Notation
'  SUBROUTINE              MAIN PROGRAM
' height_aerodynamic     z
' Stability              Stability_zL
' U                      rslt_wnd_spd
' Freq_factor            FreqFactor_uw_vw

' Freq factor for uw and vw
Sub FreqFactorCSAT_uw_vw_BA_LA (height_aerodynamic, Stability, U, Freq_factor)
  'Variables used inside subrotine
  Dim cosp_uw                       'Cospectrum of u or v with w
  Dim tran_func_BA                  'Transfer function of block averaging for covariance
  Dim tran_func_LA_ww               'Transfer function of line averaging for ww
  Dim tran_func_LA_uu               'Transfer function of line averaging for uu or vv

  Dim freq                          'Cyclic frequency
  Dim freq_factor_numerator         'Numerator to calculate the freq correction factor for covariance of u or v with w
  Dim freq_factor_denominator       'Denominator to calculate the freq correction factor for covariance of u or v with w
  Dim weight                        'Weight factor in numerical integration of Composite Simpson's Rule
  Dim J As Long                     'Iteration index. The uppercase letter J is used to keep the editor's auto-correct feature
  'from changing the case of J in units as lowcase (e.g. J/s m^2) throughout the program.

  'Define intermediate variables to reduce the repeat computation inside iteration loops
  Dim zu                            'z/U, ratio of aerodynamic height to total horizontal velocity
  Dim pu_csat                       'PATH_LENGTH_CSAT/U
  Dim PI2_pu_freq_csat              'Intermediate variable 2*PI*pu_csat*freq
  Dim A_uw, B_uw                    'Parameters in the cospectrum of u with w for stable condition

  If ((Stability <> NaN) AND (U <> NaN)) Then
    'Reset variables
    freq_factor_numerator   = 0
    freq_factor_denominator = 0

    'Prepare calculations
    zu      = height_aerodynamic/U
    pu_csat = PATH_LENGTH_CSAT/U

    'Calculate parameters in the cospectrum of u with w for stable condition
    Select Case Stability
    Case Is > 0 AND Is <= 4
      A_uw =  0.124*((1 + 7.9*Stability)^0.75)       'a parameter in eq. 21 in Moore (1986), eq. 2.80 & Table 2.1 in Dijk (2002)
      B_uw = 23.252*((1 + 7.9*Stability)^(-0.825))   'a parameter in eq. 21 in Moore (1986), eq. 2.80 & Table 2.1 in Dijk (2002)

    Case Is > 4   'Similarity functions are defined in a range of z/L from -2 to 2 (pages17, 28, 41~43, Kaimal & Finnigan 1994). Extened to 4 as shown in Fig 5.23 in Stull (1988)
      A_uw =  0.124*((1 + 7.9*4.0)^0.75)             'a parameter in eq. 21 in Moore (1986), eq. 2.80 & Table 2.1 in Dijk (2002)
      B_uw = 23.252*((1 + 7.9*4.0)^(-0.825))         'a parameter in eq. 21 in Moore (1986), eq. 2.80 & Table 2.1 in Dijk (2002)
    EndSelect

    ' Calculate correction factor
    For J = 0 To FREQ_BIN
      freq  = START_FREQ*(STEP_BASE_FREQ^J)

      PI2_pu_freq_csat = 2*PI*pu_csat*freq

      '**Cospectrum
      If Stability > 0 Then
        cosp_uw = freq*zu/(A_uw + B_uw*(freq*zu)^2.1)             'Eq. 21 in Moore (1986), eq. 2.80 & Table 2.1 in Dijk (2002)
      Else
        Select Case (freq*zu)                                     'Eq. 26 in Moore (1986), eqs. 17 & 18 in Moncrieff et al (1997), eq. 2.85 in Dijk (2002)
        Case Is < 0.24
          cosp_uw = 20.78*freq*zu/((1 + 31*freq*zu)^1.575)
        Case Is >= 0.24
          cosp_uw = 12.66*freq*zu/((1 + 9.6*freq*zu)^2.4)
        EndSelect
      EndIf

      '** Transfer function
      tran_func_BA    = 1 - (SIN (10800*OUTPUT_INTERVAL*freq)/(PI*60*OUTPUT_INTERVAL*freq))^2   'Eq. 4 in Kaimal et al. (1989), Eq. 3 in Massman (2000). Inside SIN(), angle degrees must be used.
      tran_func_LA_uu = (SIN (180*pu_csat*freq)/(PI*pu_csat*freq))^2                            'Eq. 2.70 in DijK (2002)

      If PI2_pu_freq_csat >= 0.01 Then
        tran_func_LA_ww = (4/PI2_pu_freq_csat)*(1+ (PI2_pu_freq_csat+3)/(2*PI2_pu_freq_csat*EXP(PI2_pu_freq_csat)) -3/(2*PI2_pu_freq_csat))   'Eq. 9 in Moore (1986), page 610 in Moncrieff et al. (1997)
      Else
        tran_func_LA_ww = 1 'Due to single precision in CR3K, this term cannot be calculated when the 2*Pi*dimensiless freq < 0.01. This is an approximation. The error in the approximation < 0.001
      EndIf

      ' Composite Simpson's Rule
      weight = 2 + 2*(J MOD 2) + (J = 0) + (J = FREQ_BIN)  'In Composite Simpson's Rule, weight factor "1" for 1st and last terms, "2" for even, and "4" for odd terms in a sequential order.

      freq_factor_numerator   += weight*cosp_uw

      freq_factor_denominator += weight*cosp_uw*tran_func_BA*SQR(tran_func_LA_uu*tran_func_LA_ww)

    Next J

    '** correction factor
    Freq_factor = freq_factor_numerator/freq_factor_denominator
  Else
    Freq_factor = 1
  EndIf
EndSub

' Frequency factor for wTs
'         Variable Notation
'  SUBROUTINE             MAIN PROGRAM
' height_aerodynamic     z
' Stability              Stability_zL
' U                      rslt_wnd_spd
' tran_func_LA_Dijk()    tran_func_LA_data_Dijk()
' Freq_factor            FreqFactor_wTs

Sub FreqFactorCSAT_wTs_BA_LA (height_aerodynamic, Stability, U, tran_func_LA_Dijk(2,35), Freq_factor)
  'Variables used inside subrotine
  Dim cosp_wTs                 'Copectrum of Ts with w
  Dim tran_func_BA             'Transfer function of block averaging for covariance
  Dim Tran_func_LA_wTs         'Transfer function of line averaging for wTs

  Dim freq                     'Cyclic frequency
  Dim freq_factor_numerator    'Numerator to calculate the freq correction factor for covariance of Ts with w
  Dim freq_factor_denominator  'Denominator to calculate the freq correction factor for covariance of Ts with w
  Dim weight                   'Weight factor in numerical integration of Composite Simpson's Rule
  Dim J  As Long               'Index for the outmost iteration. The upcase letter J is used to keep the editor's auto-correct feature
  'from changing the case of J in units as lowcase (e.g. J/s m^2) throughout the program.
  Dim jj As Long               'Index for the iteration inside the outmost iteration
  Dim Prev_jj As Long

  'Define following variables for saving computation time by calculating these once outside iteration loops or reduce the repeat computations
  Dim zu                       'z/U, ratio of aerodynamic height to total horizontal velocity
  Dim pu_csat                  'PATH_LENGTH_CSAT/U
  Dim PI2_pu_freq_csat         'Intermediate variable 2*PI*pu_csat*freq
  Dim A_wTs, B_wTs             'Parameters in the cospectrum of Ts with w in a stable condition

  If ((Stability <> NaN) AND (U <> NaN)) Then

    'Reset variables
    freq_factor_numerator   = 0
    freq_factor_denominator = 0
    Prev_jj                 = 1

    'Prepair calculations
    zu      = height_aerodynamic/U
    pu_csat = PATH_LENGTH_CSAT/U

    'Calculate parameters in the cospectrum of u with w for stable condition
    Select Case Stability
    Case Is > 0 AND Is <= 4
      A_wTs = 0.2840*((1 + 6.4*Stability)^0.75)         'a parameter in Eq.21 in Moore (1986), eqs.12 & 13 in Moncrieff et al. (1997), eq.2.80 & Table 2.1 in Dijk (2002)
      B_wTs = 9.3447*((1 + 6.4*Stability)^(-0.825))     'a parameter in Eq.21 in Moore (1986), eqs.12 & 13 in Moncrieff et al. (1997), eq.2.80 & Table 2.1 in Dijk (2002)

    Case Is > 4  'Similarity functions are defined in a range of z/L from -2 to 2 (pages 28, 41~43, Kaimal & Finnigan 1994).  Extened to 4 as shown in Fig 5.23 in Stull (1988)
      A_wTs = 0.2840*((1 + 6.4*4.0)^0.75)               'a parameter in Eq.21 in Moore (1986), eqs.12 & 13 in Moncrieff et al. (1997), eq.2.80 & Table 2.1 in Dijk (2002)
      B_wTs = 9.3447*((1 + 6.4*4.0)^(-0.825))           'a parameter in Eq.21 in Moore (1986), eqs.12 & 13 in Moncrieff et al. (1997), eq.2.80 & Table 2.1 in Dijk (2002)
    EndSelect

    'Start calculations for correction factor
    For J = 0 To FREQ_BIN
      freq = START_FREQ*(STEP_BASE_FREQ^J)

      PI2_pu_freq_csat = 2*PI*pu_csat*freq

      '**Cospectrum
      If Stability > 0 Then
        cosp_wTs   = zu*freq/(A_wTs + B_wTs*(zu*freq)^2.1)              'Eq.21 in Moore (1986), eqs.12 & 13 in Moncrieff et al. (1997), eq.2.80 & Table 2.1 in Dijk (2002)
      Else
        Select Case (zu*freq)                                           'Eq.25 in Moore (1986), eqs.15 & 16 in Moncrieff et al. (1997), eq.2.84 in Dijk (2002)
        Case Is < 0.54
          cosp_wTs = 12.92*zu*freq/((1 + 26.7*zu*freq)^1.375)
        Case Is >= 0.54
          cosp_wTs =  4.378*zu*freq/((1 + 3.8*zu*freq)^2.4)     '4.378 from original source Eq.25 in Moore (1986)
        EndSelect
      EndIf

      '**Transfer function
      tran_func_BA = 1 - (SIN (10800*OUTPUT_INTERVAL*freq)/(PI*60*OUTPUT_INTERVAL*freq))^2   'Eq.4 in Kaimal et al (1989), Eq.3 in Massman (2000)

      For jj = Prev_jj To 34
        If  (PI2_pu_freq_csat >= tran_func_LA_Dijk(1,jj)) AND  (PI2_pu_freq_csat < tran_func_LA_Dijk(1, jj+1)) Then

          Tran_func_LA_wTs = tran_func_LA_Dijk(2,jj) + (PI2_pu_freq_csat-tran_func_LA_Dijk(1,jj))*(tran_func_LA_Dijk(2,jj+1) - tran_func_LA_Dijk(2,jj))/(tran_func_LA_Dijk(1,jj+1) - tran_func_LA_Dijk(1,jj))

          Prev_jj = jj

          ExitFor
        EndIf
      Next jj

      If PI2_pu_freq_csat >= tran_func_LA_Dijk(1, 35) Then Tran_func_LA_wTs = tran_func_LA_Dijk(2, 35)

      'Composite Simpson's Rule
      weight = 2 + 2*(J MOD 2) + (J = 0) + (J = FREQ_BIN)  'In Composite Simpson's Rule, weight factor "1" for 1st and last terms, "2" for even, and "4" for odd terms in sequential order.

      freq_factor_numerator   += weight*cosp_wTs
      freq_factor_denominator += weight*cosp_wTs*tran_func_BA*Tran_func_LA_wTs

    Next J

    '**Correction factor
    Freq_factor = freq_factor_numerator/freq_factor_denominator
  Else
    Freq_factor = 1
  EndIf
EndSub

' Freq factor of CSAT + CSI IRGA for wco2 and wh2o
'         Variable Notation
'  SUBROUTINE             MAIN PROGRAM
' height_aerodynamic     z
' Stability              Stability_zL
' U                      rslt_wnd_spd
' separation_lat_dis     separation_lat_dist_IRGA
' Freq_factor            FreqFactor_wco2_wh2o

Sub FreqFactorCSOPEC_wco2_wh2o_BA_LA_SP (height_aerodynamic, Stability, U, separation_lat_dis, Freq_factor)
  'Variables used inside subrotine
  Dim cosp_wco2_wh2o                'Cospectrum of co2 or h2o with w
  Dim tran_func_BA                  'Transfer function of block averaging for covariance
  Dim tran_func_LA_ww               'Transfer function of line averaging for ww
  Dim tran_func_LA_co2_h2o          'Transfer function of line averaging for variance of co2 or h2o
  Dim Tran_func_SP_wco2_wh2o        'Transfer function of lateral separation (normal to the wind direction) between sonic for w and IRGA for co2 or h2o

  Dim freq                          'Cyclic frequency
  Dim freq_factor_numerator         'Numerator to calculate the freq correction factor for covariance of co2 or h2o with w
  Dim freq_factor_denominator       'Denominator to calculate the freq correction factor for covariance of co2 or h2o with w
  Dim weight                        'Weight factor in the numerical integration of Composite Simpson's Rule
  Dim J As Long                     'Iteration index. The upcase letter J is used to keep the editor's auto-correct feature
  'from changing the case of J in units as lowcase (e.g. J/s m^2) throughout the program.

  'Define following variables for saving computation time by calculating these once outside iteration loops or by reducing repeat computations
  Dim zu                            'z/U, ratio of aerodynamic height to total horizontal velocity
  Dim pu_csat                       'path_length_CSAT/U
  Dim pu_IRGA                       'path_length_IRGA/U
  Dim du_IRGA                       'Ratio of effective lateral separation distance (normal to wind) to total wind speed
  Dim PI2_pu_csat                   'Intermediate variable 2*Pi*pu_csat
  Dim PI2_pu_IRGA                   'Intermediate variable 2*Pi*pu_IRGA
  Dim PI2_pu_freq_csat              'Intermediate variable 2*Pi*pu_csat*freq
  Dim PI2_pu_freq_IRGA              'Intermediate variable 2*Pi*pu_IRGA*freq
  Dim A_wco2_wh2o, B_wco2_wh2o      'Parameters in the cospectrum of scalar (e.g. co2 or h2o) with w

  If ((Stability <> NaN) AND (U <> NaN) AND (separation_lat_dis <> NaN)) Then

    'Reset variables
    freq_factor_numerator   = 0
    freq_factor_denominator = 0

    'Prepair calculations
    zu       = height_aerodynamic/U
    pu_csat  = PATH_LENGTH_CSAT/U
    pu_IRGA  = PATH_LENGTH_IRGA/U
    du_IRGA  = ABS(separation_lat_dis)/U
    PI2_pu_csat  = 2*PI*pu_csat
    PI2_pu_IRGA  = 2*PI*pu_IRGA

    'Calculate parameters in the cospectrum of u with w for stable condition
    Select Case Stability
    Case Is > 0 AND Is <= 4
      A_wco2_wh2o = 0.2840*((1 + 6.4*Stability)^0.75)         'Parameter in Eq. 21 in Moore (1986), eqs. 12 & 13 in Moncrieff et al (1997), eq. 2.80 & Table 2.1 in Dijk (2002)
      B_wco2_wh2o = 9.3447*((1 + 6.4*Stability)^(-0.825))     'Parameter in Eq. 21 in Moore (1986), eqs. 12 & 13 in Moncrieff et al (1997), eq. 2.80 & Table 2.1 in Dijk (2002)

    Case Is > 4   'Similarity functions are defined in a range of z/L from -2 to 2 (pages 28, 41~43, Kaimal & Finnigan 1994). Extened to 4 as shown in Fig 5.23 in Stull (1988)
      A_wco2_wh2o = 0.2840*((1 + 6.4*4.0)^0.75)               'Parameter in Eq. 21 in Moore (1986), eqs. 12 & 13 in Moncrieff et al (1997), eq. 2.80 & Table 2.1 in Dijk (2002)
      B_wco2_wh2o = 9.3447*((1 + 6.4*4.0)^(-0.825))           'Parameter in Eq. 21 in Moore (1986), eqs. 12 & 13 in Moncrieff et al (1997), eq. 2.80 & Table 2.1 in Dijk (2002)
    EndSelect

    'Start calculations for correction factors
    For J = 0 To FREQ_BIN
      freq = START_FREQ*(STEP_BASE_FREQ^J)

      PI2_pu_freq_csat  = PI2_pu_csat*freq
      PI2_pu_freq_IRGA  = PI2_pu_IRGA*freq

      '**Cospectrum
      If Stability > 0 Then
        cosp_wco2_wh2o = zu*freq/(A_wco2_wh2o + B_wco2_wh2o*(zu*freq)^2.1)    'Eq. 21 in Moore (1986), eqs. 12 & 13 in Moncrieff et al (1997), eq. 2.80 & Table 2.1 in Dijk (2002)
      Else
        Select Case (freq*zu)                                                 'Eq. 25 in Moore (1986), eqs. 15 & 16 in Moncrieff et al (1997), eq. 2.84 in Dijk (2002)
        Case Is < 0.54
          cosp_wco2_wh2o = 12.92*zu*freq/((1 + 26.7*zu*freq)^1.375)
        Case Is >= 0.54
          cosp_wco2_wh2o =  4.378*zu*freq/((1 + 3.8*zu*freq)^2.4)    '4.378 from original source of Eq.25 in Moore (1986)
        EndSelect
      EndIf

      '** Transfer functions
      tran_func_BA = 1 - (SIN (10800*OUTPUT_INTERVAL*freq)/(PI*60*OUTPUT_INTERVAL*freq))^2   'Block averaging: Eq. 4 in Kaimal et al. (1989), Eq. 3 in Massman (2000). Angle degree must be used insoide SIN().

      Tran_func_SP_wco2_wh2o = EXP(-9.9*(du_IRGA*freq)^1.5)                                  'Spatial separation: Eq. 4.8 in Foken et al. (2012)

      If PI2_pu_freq_csat >= 0.01 Then                                                       'Line averaging
        tran_func_LA_ww  = (4/PI2_pu_freq_csat)*(1+ (PI2_pu_freq_csat+3)/(2*PI2_pu_freq_csat*EXP(PI2_pu_freq_csat)) -3/(2*PI2_pu_freq_csat))   'Eq. 9 in Moore (1986), page 610 in Moncrieff et al (1997)
      Else
        tran_func_LA_ww  = 1       'Due to sigle precision in CR3K, this term cannot be calculated when the 2PI*dimensionless frequency < 0.01. This is an approximation with an error < 0.001.
      EndIf

      If PI2_pu_freq_IRGA >= 0.01 Then
        tran_func_LA_co2_h2o = (1/PI2_pu_freq_IRGA)*(3+ (PI2_pu_freq_IRGA+4)/(PI2_pu_freq_IRGA*EXP(PI2_pu_freq_IRGA)) -4/PI2_pu_freq_IRGA) 'Eq. 9 in Moore (1986), page 610 in Moncrieff et al (1997)
      Else
        tran_func_LA_co2_h2o  = 1   'Due to sigle precision in CR3K, this term cannot be calculated when the normalized frequency < 0.01 Hz. This is an approximation with an error < 0.001
      EndIf

      'Composite Simpson's Rule
      weight = 2 + 2*(J MOD 2) + (J = 0) + (J = FREQ_BIN)  'In Composite Simpson's Rule, weight factor "1" for 1st and last terms, "2" for even, and "4" for odd terms in a sequential order.

      freq_factor_numerator    += weight*cosp_wco2_wh2o

      freq_factor_denominator  += weight*cosp_wco2_wh2o*tran_func_BA*SQR(tran_func_LA_ww*tran_func_LA_co2_h2o)*Tran_func_SP_wco2_wh2o

    Next J

    '** Correction factor
    Freq_factor = freq_factor_numerator/freq_factor_denominator
  Else
    Freq_factor = 1
  EndIf

EndSub

#If (SENSOR_FW) Then
' Frequency factor of CSAT + FW for wT
'         Variable Notation
'  SUBROUTINE             MAIN PROGRAM
' height_aerodynamic     z
' Stability              Stability_zL
' U                      rslt_wnd_spd
' separation_lat_dis     separation_lat_dist_FW
' time_const             time_const_FW
' Freq_factor            FreqFactor_wFW

Sub FreqFactorCSATFW_wT_BA_LA_TC_SP (height_aerodynamic, Stability, U, separation_lat_dis, time_const, Freq_factor)
  'Variables used inside subroutine
  Dim cosp_wT                       'Cospectrum of T with w
  Dim tran_func_BA                  'Transfer function of block averaging for covariance
  Dim tran_func_LA_ww               'Transfer function of line averaging for ww
  Dim tran_func_TC_TT               'Transfer function of time constant for TT
  Dim Tran_func_SP_wT               'Transfer function of lateral separation between CSAT3 w and FW T
  Dim A_wT, B_wT                    'Parameters in the cospectrum of scalar (e.g. co2 or h2o) with w in the stable condition

  Dim freq                          'Cyclic frequency
  Dim freq_factor_numerator         'Numerator to calculate the freq correction factor for covariance of T with w
  Dim freq_factor_denominator       'Denominator to calculate the freq correction factor for covariance of T with w
  Dim weight                        'Weight factor in the numerical integration of Composite Simpson's Rule.
  Dim J As Long                     'Iteration index. The upcase letter J is used to keep the editor's auto-correct feature
  'from changing the case of J in units as lowcase (e.g. J/s m^2) throughout the program.

  'Define following variables for saving computation time by calculating these once outside iteration loops or by reducing repeat computation
  Dim zu                            'z/U, ratio of aerodynamic height to total horizontal velocity
  Dim du_FW                         'The ratio of effective lateral separation distance to total wind speed
  Dim PI2_pu_csat                   'Intermediate variable 2*Pi*path_length_csat/U
  Dim PI2_pu_freq_csat              'Intermediate variable 2*Pi*(path_length_csat/U)*freq

  If ((Stability <> NaN) AND (U <> NaN) AND (separation_lat_dis <> NaN)) Then
    'Reset variables
    freq_factor_numerator   = 0
    freq_factor_denominator = 0

    'Prepair calculations
    zu           = height_aerodynamic/U
    PI2_pu_csat  = 2*PI*PATH_LENGTH_CSAT/U
    du_FW        = ABS(separation_lat_dis)/U

    'Calculate the parameters in the cospectrum of scalar with w for a stable surface-layer condition
    Select Case Stability
    Case Is > 0 AND Is <= 4.0
      A_wT = 0.2840*((1 + 6.4*Stability)^0.75)        'a parameter in eq. 21 in Moore (1986), eqs. 12 & 13 in Moncrieff et al. (1997), eq. 2.80 & Table 2.1 in Dijk (2002)
      B_wT = 9.3447*((1 + 6.4*Stability)^(-0.825))    'a parameter in eq. 21 in Moore (1986), eqs. 12 & 13 in Moncrieff et al. (1997), eq. 2.80 & Table 2.1 in Dijk (2002)

    Case Is > 4  'Similarity functions are defined in a range of z/L from -2 to 2 (pages 28, 41~43, Kaimal & Finnigan 1994). Extened to 4 as shown in Fig 5.23 in Stull (1988)
      A_wT = 0.2840*((1 + 6.4*4.0)^0.75)              'a parameter in eq. 21 in Moore (1986), eqs. 12 & 13 in Moncrieff et al. (1997), eq. 2.80 & Table 2.1 in Dijk (2002)
      B_wT = 9.3447*((1 + 6.4*4.0)^(-0.825))          'a parameter in eq. 21 in Moore (1986), eqs. 12 & 13 in Moncrieff et al. (1997), eq. 2.80 & Table 2.1 in Dijk (2002)
    EndSelect

    'Calculate correction factor
    For J = 0 To FREQ_BIN
      freq = START_FREQ*(STEP_BASE_FREQ^J)

      PI2_pu_freq_csat = PI2_pu_csat*freq

      '** Cospectrum
      If (Stability > 0) Then
        cosp_wT   = zu*freq/(A_wT + B_wT*(zu*freq)^2.1)          'Eq. 21 in Moore (1986), eqs. 12 & 13 in Moncrieff et al. (1997), eq. 2.80 & Table 2.1 in Dijk (2002)
      Else
        Select Case (freq*zu)                                    'Eq. 25 in Moore (1986), eqs. 15 & 16 in Moncrieff et al. (1997), eq. 2.84 in Dijk (2002)
        Case Is < 0.54
          cosp_wT = 12.92*zu*freq/((1 + 26.7*zu*freq)^1.375)
        Case Is >= 0.54
          cosp_wT =  4.378*zu*freq/((1 + 3.8*zu*freq)^2.4)    '4.378 from original source of Eq.25 in Moore (1986)
        EndSelect
      EndIf

      '** Transfer function
      tran_func_BA    = 1 - (SIN (10800*OUTPUT_INTERVAL*freq)/(PI*60*OUTPUT_INTERVAL*freq))^2     'Block averaging: Eq. 4 in Kaimal et al. (1989), Eq. 3 in Massman (2000). Angle degree must be sued inside SIN().
      Tran_func_SP_wT = EXP(-9.9*(du_FW*freq)^1.5)                                                'Spatial separation: Eq. 4.8 in Foken et al. (2012)
      tran_func_TC_TT = 1/(1+(2*PI*time_const*freq)^2)                                            'Time constant: Eq. 5 Horst (1997)

      If PI2_pu_freq_csat >= 0.01 Then
        tran_func_LA_ww  = (4/PI2_pu_freq_csat)*(1+ (PI2_pu_freq_csat+3)/(2*PI2_pu_freq_csat*EXP(PI2_pu_freq_csat)) -3/(2*PI2_pu_freq_csat))   'Eq. 9 in Moore (1986), page 610 in Moncrieff et al. (1997)
      Else
        tran_func_LA_ww  = 1   'Due to sigle precision in CR3K, this term cannot be calculated when 2PI*dimensionless_frequency < 0.01. This is an approximation with an error < 0.001.
      EndIf

      'Composite Simpson's Rule
      weight = 2 + 2*(J MOD 2) + (J = 0) + (J = FREQ_BIN)  'In Composite Simpson's Rule, weight factor "1" for 1st and last terms, "2" for even, and "4" for odd terms in a sequential order.

      freq_factor_numerator   += weight*cosp_wT
      freq_factor_denominator += weight*cosp_wT*tran_func_BA*SQR(tran_func_LA_ww*tran_func_TC_TT) *Tran_func_SP_wT

    Next J

    '**Correction factor
    Freq_factor = freq_factor_numerator/freq_factor_denominator

  Else
    Freq_factor = 1
  EndIf
EndSub
#EndIf
'*** End of subroutines for freq correction factors ***

'*** Beginning of subroutines for data quality classification ***
'a. Momentum flux
'         Variable Notation
'  SUBROUTINE             MAIN PROGRAM
'  Planar_fit            Planar_Fit_flg
'  Stability             Stability_zL
'  Sigma_u               u_std_R
'  Sigma_w               w_std_R
'  Ustar                 u_star
'  Lat                   latitude
'  wnd_dir               wnd_dir_sonic
'  RNS                   RN_uw_vw_cov_R          RNS: Relative Non-Stationarity
'  QC                    tau_qc_grade            quality classes 1 to 9.

Sub Data_Quality_Grading_Momentum (Planar_Fit, Stability, Sigma_u, Sigma_w, Ustar, Lat, wnd_dir, RNS, QC)
  ' Test on turbulence conditions in development
  Dim    ITC_uw(2)                              'ITC: Integral Turbulence Chracteristic. This array is used in instruction MaxSpa to select max
  Alias  ITC_uw(1) = ITCuu                      'Integral Turbulence Chracteristic for variance of horizontal velocity
  Alias  ITC_uw(2) = ITCww                      'Integral Turbulence Chracteristic for variance of vertical velocity

  Dim    ITC_uw_max(2)                          'for use of instruction MaxSpa. Hold the max and the index of max location
  Alias  ITC_uw_max(1) = ITC_uu_ww              'Integral turbulence characteristic for momentum flux
  Alias  ITC_uw_max(2) = ITC_uu_ww_max_seq      'the index of max location

  Dim Coriolis_parameter

  Dim RNS_category(8) As Boolean                'Categorize the relative non-stationarity into possible grade categories in the overall grade system
  Dim ITC_category(8) As Boolean                'Categorize the integral turbulence characteristic into possible grade categories in the overall grade system

  Dim   Lowest_Seq_1st_Occurrence(3)
  Alias Lowest_Seq_1st_Occurrence(1) = RNS_Momentum_1st_Occurrence   'The lowest possible grade of relative non-stationarity in the overall grade system
  Alias Lowest_Seq_1st_Occurrence(2) = ITC_Momentum_1st_Occurrence   'The lowest possible grade of integral turbulence characteristics in the overall grade system
  Alias Lowest_Seq_1st_Occurrence(3) = Wnd_Momentum_1st_Occurrence   'The lowest possible grade of wind direction in the overall grade system

  Dim Lowest_Seq_Max(2)                                              'for use of instruction MaxSpa. Hold the max in "Lowest_Seq_1st_Occurrence()"

  Dim J As Long                                                      'Used for index of iteration. The upcase letter J is used to keep the editor's auto-correct feature
  'from changing the case of J in units as lowcase (e.g. J/s m^2) throughout the program.
  'Reset
  QC = 0

  '1. Relative Non-Stationarity
  'Possible Grade for relative non-Stationarity (Steady state test)
  RNS_category(1) = (RNS  < 0.15)
  RNS_category(2) = ((RNS >= 0.15) AND (RNS < 0.30))
  RNS_category(3) = (RNS  < 0.30)
  RNS_category(4) = ((RNS >= 0.30) AND (RNS < 0.75))
  RNS_category(5) = (RNS  < 0.75)
  RNS_category(6) = ((RNS >= 0.75) AND (RNS < 1.00))
  RNS_category(7) = ((RNS >= 1.00) AND (RNS  < 2.50))
  RNS_category(8) = ((RNS >= 2.50) AND (RNS  < 10.0))

  For J = 1 To 8
    RNS_Momentum_1st_Occurrence = -J *RNS_category(J)
    If (RNS_Momentum_1st_Occurrence = J) Then
      ExitFor
    EndIf
  Next J

  '2. Integral Turbulence Chracteristic
  Coriolis_parameter = 2*Omega*SIN(Lat)                       'Omega: earth anglular velocity

  Select Case Stability
  Case Is <= -0.032
    ITCuu = 4.15*ABS(Stability)^0.125                     'Table 4.2 (Foken et al. 2012)
    ITCww = 2.00*ABS(Stability)^0.125                     'Table 4.2 (Foken et al. 2012)

  Case Is > -0.032 AND Is <= 0
    ITCuu = 2.7                                           'Table 4.2 (Foken et al. 2012)
    ITCww = 1.3                                           'Table 4.2 (Foken et al. 2012)

  Case Is < 0.4 AND Is > 0
    ITCuu = 0.44*LN(ABS(Coriolis_parameter)/Ustar) + 6.3  'Table 4.3 (Foken et al. 2012)
    ITCww = 0.21*LN(ABS(Coriolis_parameter)/Ustar) + 3.1  'Table 4.3 (Foken et al. 2012)

  Case Is >= 0.4
    ITCuu = -(Sigma_u/Ustar)/9.1                    'Model unavailiable in this stability (z/L) range. Assume relative integral turbulence characteristic to be 10.1 for grade 9 due to a very stable condition
    ITCww = -(Sigma_w/Ustar)/9.1                    'Model unavailiable in this stability (z/L) range. Assume relative integral turbulence characteristic to be 10.1 for grade 9 due to a very stable condition
  EndSelect

  ITCuu = ABS((ITCuu - (Sigma_u/Ustar))/ITCuu)     'In fraction
  ITCww = ABS((ITCww - (Sigma_w/Ustar))/ITCww)     'In fraction

  If (NOT (Planar_Fit)) Then
    'If double rotation, both the max of ITC_uu and ITC_ww is used as ITC_uu_ww.
    MaxSpa(ITC_uu_ww, 2, ITCuu)                       'Max is used for momentum flux related to uw and vw
  Else
    'If planar fit, only ITC_ww is used as ITC_uu_ww.
    ITC_uu_ww = ITCww
  EndIf

  'Possible grade for the integral turbulence characteristics
  ITC_category(1) = (ITC_uu_ww < 0.30)
  ITC_category(2) = (ITC_uu_ww < 0.30)
  ITC_category(3) = ((ITC_uu_ww >= 0.30) AND (ITC_uu_ww < 0.75))
  ITC_category(4) = (ITC_uu_ww < 0.30)
  ITC_category(5) = ((ITC_uu_ww >= 0.30) AND (ITC_uu_ww < 1.00))
  ITC_category(6) = ((ITC_uu_ww >= 0.75) AND (ITC_uu_ww < 1.00))
  ITC_category(7) = ((ITC_uu_ww >= 1.00) AND (ITC_uu_ww < 2.50))
  ITC_category(8) = ((ITC_uu_ww >= 2.50) AND (ITC_uu_ww < 10.00))

  For J = 1 To 8
    ITC_Momentum_1st_Occurrence = -J *ITC_category(J)
    If (ITC_Momentum_1st_Occurrence = J) Then
      ExitFor
    EndIf
  Next J

  '3. Wind Direction
  'The lowest possible grade of wind direction in the overall grade system
  If ((wnd_dir <= 151) OR (wnd_dir >= 209)) Then
    Wnd_Momentum_1st_Occurrence = 1
  ElseIf (((wnd_dir > 151) AND (wnd_dir <= 170)) OR ((wnd_dir >= 190) AND (wnd_dir < 209)))
    Wnd_Momentum_1st_Occurrence = 7
  ElseIf ((wnd_dir > 170) AND (wnd_dir < 190))
    Wnd_Momentum_1st_Occurrence = 0
  EndIf

  '1st case
  If  (RNS_Momentum_1st_Occurrence = 0) OR (ITC_Momentum_1st_Occurrence =0) OR (Wnd_Momentum_1st_Occurrence = 0) Then        'Any in category 9 (0 used for 9)
    QC = 9

    '2nd case
  Else
    MaxSpa (Lowest_Seq_Max(1), 3, RNS_Momentum_1st_Occurrence)
    QC = Lowest_Seq_Max(1)
  EndIf

  '3rd case
  If (((RNS = NaN) OR (ITC_uu_ww = NaN) OR (wnd_dir = NaN)) AND (QC = 9)) Then  QC = NaN

EndSub

'b. Scalar flux
'         Variable Notation
'  SUBROUTINE             MAIN PROGRAM
'  Stability             stability_zL
'  Sigma_w               w_std_R
'  Ustar                 u_star
'  Sigma_Ts              Ts_std
'  Tstar                 T_star
'  Lat                   latitude
'  wnd_dir               wnd_dir_sonic
'  RNS                   RN_wTs_cov_R, RN_wCO2_Cov_R, or RN_wH2O_Cov_R     Relative Non-Stationarity
'  QC                    Fc_qc_grade, LE_qc_grade, or H_qc_grade           quality classes 1 to 9.

Sub Data_Quality_Grading_Scalar (Stability, Sigma_w, Ustar, Sigma_Ts, Tstar, Lat, wnd_dir, RNS, QC)
  ' Test on developed turbulence conditions
  Dim ITC_TsTs                             'ITC: Integral Turbulence Chracteristics
  Dim ITC_wTs
  Dim ITC_ww

  Dim Coriolis_parameter

  Dim RNS_category(8) As Boolean           'Categorize the relative non-stationarity into possible grade categories in the overall grade system
  Dim ITC_category(8) As Boolean           'Categorize the integral turbulence characteristic into possible grade categories in the overall grade system

  Dim   Lowest_Seq_1st_Occurrence(3)
  Alias Lowest_Seq_1st_Occurrence(1) = RNS_Scalar_1st_Occurrence     'The lowest possible grade of relative non-stationarity in the overall grade system
  Alias Lowest_Seq_1st_Occurrence(2) = ITC_Scalar_1st_Occurrence     'The lowest possible grade of integral turbulence characteristi in the overall grade system
  Alias Lowest_Seq_1st_Occurrence(3) = Wnd_Scalar_1st_Occurrence     'The lowest possible grade of wind direction in the overall grade system

  Dim Lowest_Seq_Max(2)                     'For use of instruction MaxSpa. Hold the max in "Lowest_Seq_1st_Occurrence()"

  Dim J As Long                             'Used for index of iteration. The upcase letter J is used to keep the editor's auto-correct feature
  'From changing the case of J in units as lowcase (e.g. J/s m^2) throughout the program.
  'Reset
  QC = 0

  '1. Relative Non-Stationarity
  'Possible Grade for relative non-stationarity (Steady state test)
  RNS_category(1) = (RNS < 0.15)
  RNS_category(2) = ((RNS >= 0.15) AND (RNS < 0.30))
  RNS_category(3) = (RNS < 0.30)
  RNS_category(4) = ((RNS >= 0.30) AND (RNS < 0.75))
  RNS_category(5) = (RNS < 0.75)
  RNS_category(6) = ((RNS >= 0.75) AND (RNS < 1.00))
  RNS_category(7) = ((RNS >= 1.00) AND (RNS < 2.50))
  RNS_category(8) = ((RNS >= 2.50) AND (RNS  < 10.0))

  For J = 1 To 8
    RNS_Scalar_1st_Occurrence = -J *RNS_category(J)
    If (RNS_Scalar_1st_Occurrence = J) Then
      ExitFor
    EndIf
  Next J

  '2. Integral Turbulence Chracteristic
  Coriolis_parameter = 2*Omega*SIN(Lat)                        'Omega: earth anglular velocity

  'Test on developed turbulence conditions for sensible heat flux using the integral turbulence characteristic
  Select Case Stability
  Case Is <= -0.032
    ITC_ww = 2.00*ABS(Stability)^0.125                     'Table 4.2 (Foken et al. 2012)

  Case Is > -0.032 AND Is <= 0
    ITC_ww = 1.3                                           'Table 4.2 (Foken et al. 2012)

  Case Is < 0.4 AND Is > 0
    ITC_ww = 0.21*LN(ABS(Coriolis_parameter)/Ustar) + 3.1  'Table 4.3 (Foken et al. 2012)

  Case Is >= 0.4
    ITC_ww = -(Sigma_w/Ustar)/9.1                            'Model unavailiable in this z/L range. Assume relative integral turbulence characteristic to be 10.1 for grade 9 due to a very stable condition
  EndSelect
  ITC_ww = ABS((ITC_ww - (Sigma_w/Ustar))/ITC_ww)          'In fraction

  Select Case Stability
  Case Is < -1
    ITC_TsTs = ABS(Stability)^(-1/3)        'Table 4.2 (Foken et al. 2012)

  Case Is <= -0.062 AND Is >= -1
    ITC_TsTs = ABS(Stability)^(-0.25)       'Table 4.2 (Foken et al. 2012)

  Case Is < 0.02 AND Is > -0.062
    ITC_TsTs = 0.5*ABS(Stability)^(-0.50)   'Table 4.2 (Foken et al. 2012)

  Case  Is >= 0.02 AND Is < 1
    ITC_TsTs = 1.4*Stability^(-0.25)        'Table 4.2 (Foken et al. 2012)

  Case Is >=1
    ITC_TsTs = -(Sigma_Ts/ABS(Tstar))/9.1   'Classify it into grade 9 when z/L >= 1
  EndSelect

  ITC_TsTs = ABS((ITC_TsTs - Sigma_Ts/ABS(Tstar))/ITC_TsTs)   'in fraction

  ITC_wTs = IIF ( (ITC_TsTs > ITC_ww), ITC_TsTs, ITC_ww)

  'Possible grade for the integral turbulence characteristics
  ITC_category(1) = (ITC_wTs < 0.30)
  ITC_category(2) = (ITC_wTs < 0.30)
  ITC_category(3) = ((ITC_wTs >= 0.30) AND (ITC_wTs < 0.75))
  ITC_category(4) = (ITC_wTs < 0.30)
  ITC_category(5) = ((ITC_wTs >= 0.30) AND (ITC_wTs < 1.00))
  ITC_category(6) = ((ITC_wTs >= 0.75) AND (ITC_wTs < 1.00))
  ITC_category(7) = ((ITC_wTs >= 1.00) AND (ITC_wTs < 2.50))
  ITC_category(8) = ((ITC_wTs >= 2.50) AND (ITC_wTs < 10.00))

  For J = 1 To 8
    ITC_Scalar_1st_Occurrence = -J *ITC_category(J)
    If (ITC_Scalar_1st_Occurrence = J) Then
      ExitFor
    EndIf
  Next J

  '3. wind direction
  'The lowest possible grade of wind direction in the overall grade system
  If ((wnd_dir <= 151) OR (wnd_dir >= 209)) Then
    Wnd_Scalar_1st_Occurrence = 1
  ElseIf (((wnd_dir > 151) AND (wnd_dir <= 170)) OR ((wnd_dir >= 190) AND (wnd_dir < 209)))
    Wnd_Scalar_1st_Occurrence = 7
  ElseIf ((wnd_dir > 170) AND (wnd_dir < 190))
    Wnd_Scalar_1st_Occurrence = 0
  EndIf

  '1st case
  If  (RNS_Scalar_1st_Occurrence = 0) OR (ITC_Scalar_1st_Occurrence =0) OR (Wnd_Scalar_1st_Occurrence = 0) Then        'Any in category 9 (0 used for 9)
    QC = 9

    '2nd case
  Else
    MaxSpa (Lowest_Seq_Max(1), 3, RNS_Scalar_1st_Occurrence)
    QC = Lowest_Seq_Max(1)
  EndIf

  '3rd case
  If (((RNS = NaN) OR (ITC_wTs = NaN) OR (wnd_dir = NaN)) AND (QC = 9)) Then  QC = NaN
EndSub
'*** End of subroutines for data quality classification ***

'*** Beginning of subroutines for footprint characteristics ***
' 1. Footprint of Kljun et al. (2004): Footprint characteristics
'  SUBROUTINE             MAIN PROGRAM
'  Ustar                  u_star
'  Sigma_w                w_std_R
'  height_aerodynamic     z
'  Obukhov                L
'  roughness              z0
'  upwnd_dist             upwnd_dist_intrst             Upwind range of interest (measurement targeted range)
'  FP_win_range           FP_dist_intrst                Percentage of measured scalar flux from upwind range of interest
'  x_max                  FP_max                        Upwind location of source/sink that contributes most to the measured flux
'  FP_40pct_range         FP_40                         Upwind range within which the source/sink contributes 40% to the measured flux
'  FP_55pct_range         FP_55                         Upwind range within which the source/sink contributes 55% to the measured flux
'  FP_90pct_range         FP_90                         Upwind range within which the source/sink contributes 90% to the measured flux

Sub FootprintCharacteristics_Kljun(Ustar, Sigma_w, height_aerodynamic, Obukhov, roughness, upwnd_dist, FP_win_range, x_max, FP_40pct_range, FP_55pct_range,FP_90pct_range)
  '*** Variables used inside subroutine
  'Model parameters
  Dim k1, k2, k3, k4           'Parameters in the model of Kljun et al (2004)
  Dim h_PBL                    'Planetary Boudary-Layer height

  'Composit variables repeatedly used in iterational computation
  Dim zh_ratio                 'Ratio of aerodynamic height to planetary boundary-layer height (height_aerodynamic/h_PBL)
  Dim suz                      'for repeately used variable of ((Sigma_w/Ustar)^0.8)/height_aerodynamic
  Dim k1_suz_zh                'for repeately used variable of k1*[((Sigma_w/Ustar)^0.8)*(1-height_aerodynamic/h_PBL)/height_aerodynamic]

  'Working variables
  Dim FP_cumulative            'Cumulative_footprint
  Dim FP_cumulative_prev       'Cumulative_footprint in a previous iteration
  Dim x_inflection_L           'x at the left inflection point of footprint (i.e. x_inflection_L  < x_max) where x is the upwind distance to measurement station
  Dim x_inflection_R           'x at the right inflection point of footprint (i.e. x_inflection_R > x_max) where x is the upwind distance to measurement station
  Dim x_L                      'x at the left boundary of an integration interval where x is the upwind distance to measurement station
  Dim x_R                      'x at the right boundary of an integration interval where x is the upwind distance to measurement station
  Dim Integration_interval     'Interval for numerical integration (i.e. x_R - x_L)

  'Variables for use of Boole's Rule for numerical integration
  Dim FP_L                     'footprint at x = x_L
  Dim FP_M1                    'footprint at x = x_L + 0.25*(x_R - x_L)
  Dim FP_M2                    'footprint at x = x_L + 0.50*(x_R - x_L)
  Dim FP_M3                    'footprint at x = x_L + 0.75*(x_R - x_L)
  Dim FP_R                     'footprint at x = x_R

  Dim Interval_count           'Used to calculate the number of intervals needed for numerical integration after FP_90pct_range was calculated, but before upwnd_dist is reached
  Dim J As Long                'Used for index of iteration. The upcase letter J is used to keep the editor's auto-correct feature
  'From changing the case of J in units as lowcase (e.g. J/s m^2) throughout the program.

  'Calculate paramerters in Kljun et al (2004)].
  k1 = 0.175/(3.418 - LN(roughness))     'page 515 & 516, left top panel in Fig. 7 and eq. (13). Email from Dr. Kljun on Feb 10, 2015
  k2 = 3.68254                           'page 515 & 516, right top panel in Fig. 7 and eq.(14). Calculated from eq.(10) using k1 and k3
  k3 = 4.277*(3.418 - LN(roughness))     'page 515 & 516, left bottom panel in Fig. 7 and eq.(15). Email from Dr. Kljun on Feb 10, 2015
  k4 = 1.685*(3.418 - LN(roughness))     'page 515 & 516, right bottom panel in Fig. 7 and eq.(16). Email from Dr. Kljun on Feb 10, 2015

  If ((Ustar <> NaN) AND (Sigma_w <> NaN) AND (Obukhov <> NaN)) Then 
  'Estimate planetary boudary-layer (PBL) height using data in the L and h colums in Table I in Kljun et al (2004)
  Select Case Obukhov
  Case Is <= 0
    'h_PBL = 1000 m when Obukhov is -infinity. h_PBL = 1200 m at Obukhov = -650. Assume when Obukhov is <-650, h_PBL will decreases at the same rate
    'as h_PBL decreases when -650 < Obukhov <-30. Thus h_PBL reaches the limit of 1000 m at Obukhov = -1013.3; therefore, h_PBL = 1000 m if Obukhov <= -1013.3.
    If (Obukhov < -1013.3) Then
      h_PBL = 1000                                      'Set h_PBL = 1000 m as long as Obukhov < -1013.3 m.
    ElseIf (Obukhov <= -650) Then
      h_PBL = 1200 - 200*((Obukhov + 650)/(-1013.3+650))
    ElseIf (Obukhov <= -30) Then
      h_PBL = 1500 - 300*((Obukhov + 30)/(-650+30))
    ElseIf (Obukhov <= -5) Then
      h_PBL = 2000 - 500*((Obukhov + 5)/(-30+5))
    ElseIf (Obukhov <= 0) Then
      h_PBL = 2000 + 20* (Obukhov + 5)                    'Extrapolation to Obukhov --> -0.
    EndIf

  Case Is > 0
    'h_PBL = 1000 m when Obukhov is +infinity, and h_PBL = 800 m at Obukhov = 1000. Assume that h_PBL becomes higher with Obukhov at the same rate
    'as in the Obukhov range of 130 to 1000. Thus h_PBL reaches the limit of 1000 m at Obukhov = 1316.4; therefore, h_PBL = 1000 m if Obukhov > 1316.4
    If (Obukhov > 1316.4) Then
      h_PBL = 1000                                      'Set h_PBL = 1000 m as long as Obukhov > 1316.4 m.
    ElseIf (Obukhov >= 1000) Then
      h_PBL = 800 + 200*((Obukhov - 1000)/(1316.4-1000))
    ElseIf (Obukhov >= 130) Then
      h_PBL = 250 + 550*((Obukhov -130)/(1000 - 130))
    ElseIf (Obukhov >= 84) Then
      h_PBL = 200 + 50*((Obukhov - 84)/(130 -84))
    ElseIf (Obukhov > 0) Then
      h_PBL = 200 - (84 - Obukhov)*(50/46)               'Extrapolation to Obukhov --> +0
    EndIf
  EndSelect

  'Calculate variables repeatedly used inside iteration loops
  zh_ratio  = height_aerodynamic/h_PBL
  suz       = ((Sigma_w/Ustar)^0.8)/height_aerodynamic
  k1_suz_zh = k1*suz*(1-zh_ratio)

  'Upwind location of source/sink that contributes most to the measured flux
  x_max = (k3 - k4)/suz
  x_inflection_L = x_max*(k3*((SQR(k2) - 1)/SQR(k2))-k4)/(k3-k4)     'x at the left inflection point of footprint (i.e. < x_max)
  x_inflection_R = x_max*(k3*((SQR(k2) + 1)/SQR(k2))-k4)/(k3-k4)     'x at the right inflection point of footprint (i.e. > x_max)

  'reset variables
  FP_cumulative  = 0
  FP_win_range   = 0
  FP_40pct_range = 0
  FP_55pct_range = 0
  FP_90pct_range = 0

  '***Calculate footprint characteristics: FP_win_range, FP_40pct_range, FP_55pct_range, and FP_90pct_range
  ' Use five numerical integration segments to calculate the footprint characteristics
  ' 1st: starting point of footprint defined (-k4/suz) to the left footprint inflection point (x_inflection_L)
  ' 2nd: the left footprint inflection point to the footprint maximum (x_max)
  ' 3rd: the footprint maximum to the right footptint inflection point (x_inflection_R) then further to [x_inflection_R + (x_inflection_R - x_max)]
  ' 4th: from x > [x_inflection_R + (x_inflection_R - x_max)] or x at culumutive footprint > 90% and then until the distance of interest is reached
  '      but limited x_max + 200*height_aerodynamic (x_200z).
  ' 5th: If upwind range of interest has not been reached, this segment is integrated from x at FP_90 = 90% (x_90)
  '      oR x_max + 200*height_aerodynamic (x_200z) to upwind distance of interest, but limited to x_90 (or x_200z) + 100*height_aerodynamic. 

  ' Use a high resolution of integration intervals for the first three segments 
  '     a lower resolution for the 4th and 5th segments, but high precision numerical method of Boole's Rule

    '1st numerical integration segment: Upwind range until x reaches left inflection point
    'Preparation for use of x_L and x_R inside an iteration
    x_R  = - k4/suz                                                        'Initialization. This value will be used for the starting point of integration
    Integration_interval = (x_inflection_L - x_R)/NMBR_INT_INTERV_SEGMENT  'Use x at the left inflection point as a ending boundary of the 1st numerical integration segment
    FP_R = 0                                                               'Pre-calculation

    For J = 1 To NMBR_INT_INTERV_SEGMENT
      x_L = x_R
      x_R = x_R + Integration_interval
      FP_cumulative_prev = FP_cumulative

      'Footprint value at the left boundary of integration interval
      FP_L = FP_R

      'Footprint value at the right boundary of integration interval
      FP_R = (suz*x_R + k4)/k3                       'Pre-calculation
      FP_R = k1_suz_zh*(FP_R^k2)*EXP(k2*(1 - FP_R))

      'The trapezoidal rule used for an individual interval to cumulate the footprint
      FP_cumulative += Integration_interval*(FP_L + FP_R)/2

      'Find the footprint w/in the range of interest
      If ((x_L < upwnd_dist) AND (x_R >= upwnd_dist)) Then
        FP_win_range = 100*(FP_cumulative_prev + (FP_cumulative - FP_cumulative_prev)*(upwnd_dist - x_L)/Integration_interval)
      EndIf

      'Find the 40% footprint distance
      If (FP_cumulative >= 0.4) AND (FP_40pct_range = 0) Then
        FP_40pct_range = x_R - Integration_interval*(FP_cumulative - 0.4)/(FP_cumulative - FP_cumulative_prev)
      EndIf

    Next J

    '2nd numerical integration segment: Upwind range from the left footprint inflection point to the maxmum footprint
    Integration_interval = (x_max - x_inflection_L)/NMBR_INT_INTERV_SEGMENT   'For numerical integration, use x at the left inflection point as the starting boundary and x_max as the ending boundary

    'Upwind range within x_max
    For J = 1 To NMBR_INT_INTERV_SEGMENT
      x_L = x_R
      x_R = x_R + Integration_interval
      FP_cumulative_prev = FP_cumulative

      'Footprint value at the left boundary of integration interval
      FP_L = FP_R

      'Footprint value at the right boundary of integration interval
      FP_R = (suz*x_R + k4)/k3                       'Pre-calculation
      FP_R = k1_suz_zh*(FP_R^k2)*EXP(k2*(1 - FP_R))

      'The trapezoidal rule used for an individual interval to cumulate footprint
      FP_cumulative += Integration_interval*(FP_L + FP_R)/2

      'Find the footprint w/in the range of interest
      If ((x_L < upwnd_dist) AND (x_R >= upwnd_dist)) Then
        FP_win_range = 100*(FP_cumulative_prev + (FP_cumulative - FP_cumulative_prev)*(upwnd_dist - x_L)/Integration_interval)
      EndIf

      'Find the 40% footprint distance
      If (FP_cumulative >= 0.4) AND (FP_40pct_range = 0) Then
        FP_40pct_range = x_R - Integration_interval*(FP_cumulative - 0.4)/(FP_cumulative - FP_cumulative_prev)
      EndIf

      'Find the 55% footprint distance
      If (FP_cumulative >= 0.55) AND (FP_55pct_range = 0) Then
        FP_55pct_range = x_R - Integration_interval*(FP_cumulative - 0.55)/(FP_cumulative - FP_cumulative_prev)
      EndIf

    Next J

    '3rd numerical integration segment: Upwind range from the maximum footprint to the right footprint inflection point and then further
    'to [x_inflection_R + (x_inflection_R -x_max)] or until 90% of footprint is found
    Integration_interval = (x_inflection_R - x_max)/NMBR_INT_INTERV_SEGMENT    'For numerical integration, use x_max as the starting boundary and x at the right inflection point as the middle boundary

    For J = 1 To 2*NMBR_INT_INTERV_SEGMENT                                      'Using the fine resolution for integration even beyong x_inflection_R to to [x_inflection_R + (x_inflection_R -x_max)]
      x_L = x_R
      x_R = x_R + Integration_interval
      FP_cumulative_prev = FP_cumulative

      'Footprint value at the left boundary of integration interval
      FP_L = FP_R

      'Footprint value at the right boundary of an integration interval
      FP_R = (suz*x_R + k4)/k3                                                  'Pre-calculation
      FP_R = k1_suz_zh*(FP_R^k2)*EXP(k2*(1 - FP_R))

      'The trapezoidal rule used for an individual interval to cumulate footprint
      FP_cumulative += Integration_interval*(FP_L + FP_R)/2

      'Find the footprint w/in the range of interest
      If ((x_L < upwnd_dist) AND (x_R >= upwnd_dist)) Then
        FP_win_range = 100*(FP_cumulative_prev + (FP_cumulative - FP_cumulative_prev)*(upwnd_dist - x_L)/Integration_interval)
      EndIf

      'Find the 40% footprint distance
      If (FP_cumulative >= 0.4) AND (FP_40pct_range = 0) Then
        FP_40pct_range = x_R - Integration_interval*(FP_cumulative - 0.4)/(FP_cumulative - FP_cumulative_prev)
      EndIf

      'Find the 55% footprint distance
      If (FP_cumulative >= 0.55) AND (FP_55pct_range = 0) Then
        FP_55pct_range = x_R - Integration_interval*(FP_cumulative - 0.55)/(FP_cumulative - FP_cumulative_prev)
      EndIf

      'Find the 90% footprint distance
      If (FP_cumulative >= 0.9) AND (FP_90pct_range = 0) Then
        FP_90pct_range = x_R - Integration_interval*(FP_cumulative - 0.9)/(FP_cumulative - FP_cumulative_prev)
        Exit For
      EndIf
    Next J

    '4th numerical integration segment: x > [x_inflection_R + (x_inflection_R - x_max)] or culumutive footprint > 90%
    'Use lower integration resolution, but more accurate numerical integration method of Boole's Rule
    Integration_interval = 4*height_aerodynamic

    'If upwind range of 90% footprint is not reached. Continue to calculate
    While ((FP_cumulative < 0.9) AND (x_R - x_max < 200*height_aerodynamic))
      x_L = x_R
      x_R = x_R + Integration_interval
      FP_cumulative_prev = FP_cumulative

      '*** Boole's Rule for numerical integration ***
      'Footprint value at the left boundary of an integration interval
      FP_L = FP_R

      FP_M1 = (suz*(x_L + 0.25*Integration_interval) + k4)/k3             'Pre-calculation
      FP_M1 = k1_suz_zh*(FP_M1^k2)*EXP(k2*(1 - FP_M1))

      FP_M2 = (suz*(x_L + 0.50*Integration_interval) + k4)/k3             'Pre-calculation
      FP_M2 = k1_suz_zh*(FP_M2^k2)*EXP(k2*(1 - FP_M2))

      FP_M3 = (suz*(x_L + 0.75*Integration_interval) + k4)/k3             'Pre-calculation
      FP_M3 = k1_suz_zh*(FP_M3^k2)*EXP(k2*(1 - FP_M3))

      'Footprint value at the right boundary of an integration interval
      FP_R = (suz*x_R + k4)/k3                                            'Pre-calculation
      FP_R = k1_suz_zh*(FP_R^k2)*EXP(k2*(1 - FP_R))

      'Boole's Rule used for an individual interval to cumulate the footprint
      FP_cumulative += Integration_interval*(7*FP_L + 32*FP_M1 + 12*FP_M2+ 32*FP_M3+ 7*FP_R)/90

      'Find the footprint w/in the range of interest
      If ((x_L < upwnd_dist) AND (x_R >= upwnd_dist)) Then
        FP_win_range = 100*(FP_cumulative_prev + (FP_cumulative - FP_cumulative_prev)*(upwnd_dist - x_L)/Integration_interval)
      EndIf

      'Find the 40% footprint distance
      If ((FP_cumulative >= 0.4) AND (FP_40pct_range = 0)) Then
        FP_40pct_range = x_R - Integration_interval*(FP_cumulative - 0.4)/(FP_cumulative - FP_cumulative_prev)
      EndIf

     'Find the 55% footprint distance
      If ((FP_cumulative >= 0.55) AND (FP_55pct_range = 0)) Then
        FP_55pct_range = x_R - Integration_interval*(FP_cumulative - 0.55)/(FP_cumulative - FP_cumulative_prev)
      EndIf

    Wend

    'Find the 90% footprint distance
    If ((FP_cumulative >= 0.90) AND (FP_90pct_range = 0)) Then
      FP_90pct_range = x_R - Integration_interval*(FP_cumulative - 0.9)/(FP_cumulative - FP_cumulative_prev)
    EndIf 
    
    'Assign FP_90pct_range as NaN if culmulative footprint can not reach 0.9 within x_max + 200*height_aerodynamic
    If ((FP_cumulative < 0.90) AND (FP_90pct_range = 0)) Then
      FP_90pct_range = NaN
    EndIf

    '5th numerical integration segment.
    'If upwind range of interest has not been reached, this segment is integrated from x at FP_90 = 90% (x_90)
    'or x_max + 200*height_aerodynamic (x_200z) to upwind distance of interest, but limited to x_90 (or x_200z) + 100*height_aerodynamic. 
    
    If (x_R < upwnd_dist) Then

      ' Control the integration w/in 25 iterations after above integrations
      If ((upwnd_dist - x_R) < (100*height_aerodynamic)) Then

        Interval_count       = INT((upwnd_dist - x_R)/Integration_interval)
        Integration_interval = (upwnd_dist - x_R)/Interval_count           'Rescale the intergration interval

        For J = 1 To Interval_count                                       'To Upwnd_dist, the cumulative footprint is enough
          x_L = x_R
          x_R = x_R + Integration_interval
          FP_cumulative_prev = FP_cumulative

          '*** Boole's Rule for numerical integration *****
          'Footprint value in the left boundary of integration interval
          FP_L = FP_R

          FP_M1 = (suz*(x_L + 0.25*Integration_interval) + k4)/k3          'Pre-calculation
          FP_M1 = k1_suz_zh*(FP_M1^k2)*EXP(k2*(1 - FP_M1))

          FP_M2 = (suz*(x_L + 0.50*Integration_interval) + k4)/k3          'Pre-calculation
          FP_M2 = k1_suz_zh*(FP_M2^k2)*EXP(k2*(1 - FP_M2))

          FP_M3 = (suz*(x_L + 0.75*Integration_interval) + k4)/k3          'Pre-calculation
          FP_M3 = k1_suz_zh*(FP_M3^k2)*EXP(k2*(1 - FP_M3))

          'Footprint value in the right boundary of integration interval
          FP_R = (suz*x_R + k4)/k3                                         'Pre-calculation
          FP_R = k1_suz_zh*(FP_R^k2)*EXP(k2*(1 - FP_R))

          'Boole's Rule used for an individual interval to cumulate the footprint
          FP_cumulative += Integration_interval*(7*FP_L + 32*FP_M1 + 12*FP_M2+ 32*FP_M3+ 7*FP_R)/90

          'Try to find the 90% footprint distance again
          If ((FP_cumulative >= 0.9) AND (FP_90pct_range = NaN)) Then
            FP_90pct_range = x_R - Integration_interval*(FP_cumulative - 0.9)/(FP_cumulative - FP_cumulative_prev)
          EndIf
        Next J

        Select Case FP_cumulative
        Case Is < 1.00
          FP_win_range = 100*FP_cumulative
        Case Is >=1
          FP_win_range = 99
        EndSelect

      Else
        FP_win_range = 99
      EndIf

    EndIf

  Else
    x_max          = NaN
    FP_win_range   = NaN
    FP_40pct_range = NaN
    FP_55pct_range = NaN
    FP_90pct_range = NaN
  EndIf
EndSub

' 2. Footprint of Kormann and Meixner (2001)
'  SUBROUTINE             MAIN PROGRAM
'  Ustar                  u_star
'  height_aerodynamic     z
'  Stability              stability_zL
'  U                      rslt_wnd_spd
'  upwnd_dist             upwnd_dist_intrst            Upwind range of interest (measurement target)
'  FP_win_range           FP_dist_intrst               Percentage of measured scalar flux from upwind range of interest
'  x_max                  FP_max                       Upwind location of source/sink that contributes most to the measured flux
'  FP_40pct_range         FP_40                        Upwind range within which the source/sink contributes 40% to the measured flux
'  FP_55pct_range         FP_55                        Upwind range within which the source/sink contributes 55% to the measured flux
'  FP_90pct_range         FP_90                        Upwind range within which the source/sink contributes 90% to the measured flux

Sub FootprintCharacteristics_KormannMeixner (Ustar, height_aerodynamic, Stability, U, upwnd_dist, FP_win_range, x_max, FP_40pct_range, FP_55pct_range, FP_90pct_range)
  'Parameters in the vertical profiles of horizontal wind and eddy diffusivity
  Dim m_KM                     'Exponent of vertical profile of horizontal wind in footprint of Kormann and Meixner (2001)
  Dim n_KM                     'Exponent of vertical profile of eddy diffusivity in footprint of Kormann and Meixner (2001)
  Dim wnd_const                'Wind constant in the vertical profile of horizontal wind

  'Composite variables
  Dim r_KM                     'Shape factor (r_KM =2 + m_KM - n_KM) in footprint of Kormann and Meixner (2001)
  Dim Xi                       'wnd_const/(k*r_KM^2) where k is von Kerman constant (0.41)
  Dim Mu                       '(m_KM + 1)/r_KM
  Dim Gamma_Mu                 'Gamma function of Mu
  Dim xgz                      '((Xi^Mu)*(height_aerodynamic^(m_KM +1)))/Gamma_Mu
  Dim xz                       'Xi*height_aerodynamic^r_KM

  'Working variables
  Dim FP_cumulative            'Cumulative_footprint
  Dim FP_cumulative_prev       'Cumulative_footprint in a previous iteration
  Dim x_inflection_L           'x at the left inflection point of footprint (i.e. x_inflection_L < x_max) where x is upwind distance to measurement station
  Dim x_inflection_R           'x at the right inflection point of footprint (i.e. x_inflection_R > x_max) where x is upwind distance to measurement station
  Dim x_L                      'x at the left boundary of integration interval where x is upwind distance to measurement station
  Dim x_R                      'x at the right boundary of integration interval where x is upwind distance to measurement station
  Dim Integration_interval     'Interval for numerical integration (i.e. x_R - x_L)

  'Variables for use of Boole's rule
  Dim FP_L                     'footprint at x = x_L
  Dim FP_M1                    'footprint at x = x_L + 0.25*(x_R - x_L)
  Dim FP_M2                    'footprint at x = x_L + 0.50*(x_R - x_L)
  Dim FP_M3                    'footprint at x = x_L + 0.75*(x_R - x_L)
  Dim FP_R                     'footprint at x = x_R

  Dim Interval_count           'Used to calculate interval number after FP_90pct_range calculated, but before Upwnd_dist reaches
  Dim J As Long                'Used for index of iteration. The upcase letter J is used to keep the editor's auto-correct feature
  'From changing the case of J in units as lowcase (e.g. J/s m^2) throughout the program.
  

   If ((Ustar <> NaN) AND (Stability <> NaN) AND (U <> NaN)) Then
  'Calculate the exponent of vertical profile of horizontal wind and the exponent of vertical profile of eddy diffusivity
  
  If (Stability > 0) Then
    'Similarity functions are defined in a range of z/L from -2 to 2 (pages 28, 41~43, Kaimal & Finnigan 1994). Extened to +/-4 as shown in Fig 5.23 in Stull (1988)
   Select Case Stability 
     Case Is <= 4.0    
       m_KM = (Ustar/(k*U))*(1 + 5*Stability)         'Exponent of vertical profile of horizontal wind
       n_KM = 1/(1 + 5*Stability)                     'Exponent of vertical profile of eddy diffusivity
     
     Case Is > 4
       m_KM = (Ustar/(k*U))*(1 + 5*4)                 'Exponent of vertical profile of horizontal wind
       n_KM = 1/(1 + 5*4)                             'Exponent of vertical profile of eddy diffusivity
   EndSelect
  Else
    Select Case Stability
     Case Is >= -4.0  
       m_KM = (Ustar/(k*U))/((1 - 16*Stability)^0.25) 'Exponent of vertical profile of horizontal wind
       n_KM = (1-24*Stability)/(1 - 16*Stability)     'Exponent of vertical profile of eddy diffusivity
   
     Case Is < -4.0
       m_KM = (Ustar/(k*U))/((1 - 16*(-4))^0.25)      'Exponent of vertical profile of horizontal wind
       n_KM = (1-24*(-4))/(1 - 16*(-4))               'Exponent of vertical profile of eddy diffusivity
    EndSelect
  EndIf

  'Calculate the wind constant in the vertical profile of horizontal wind
  wnd_const = U/(height_aerodynamic^m_KM)        'Wind constant

  'Calculate the composite variables
  r_KM = 2 + m_KM - n_KM                        'Shape factor

  Xi = wnd_const/(k*r_KM*r_KM)
  Mu = (m_KM + 1)/r_KM

  Gamma_Mu = SQR(2*PI/Mu)*(((Mu + 1/(12*Mu - 0.1/Mu))/EXP(1))^Mu)    'Nemes (2007)

  xgz = ((Xi^Mu)*(height_aerodynamic^(m_KM +1)))/Gamma_Mu
  xz  = Xi*(height_aerodynamic^r_KM)

  'Turnning and inflection points
  x_max          = xz/(Mu + 1)                   'Upwind location of source/sink that contributes most to the measured flux
  x_inflection_L = x_max*(1 - 1/SQR(Mu + 2))     'x at the left footprint inflection point
  x_inflection_R = x_max*(1 + 1/SQR(Mu + 2))     'x at the right footprint inflection point

  'Reset variables
  FP_cumulative  = 0
  FP_win_range   = 0
  FP_40pct_range = 0
  FP_55pct_range = 0
  FP_90pct_range = 0

  '***Calculate footprint characteristics: FP_win_range, FP_40pct_range, FP_55pct_range, and FP_90pct_range
  ' Use five numerical integration segments to calculate the footprint characteristics
  ' 1st: starting segment from 0 (+ Delt-->0)  to the left footprint inflection point (x_inflection_L)
  ' 2nd: the left footprint inflection point to the footprint maximum (x_max)
  ' 3rd: the footprint maximum to the right footptint inflection point (x_inflection_R) then further to [x_inflection_R + (x_inflection_R - x_max)] or until cumulative footprint reaches 90%
  ' 4th: from x > [x_inflection_R + (x_inflection_R - x_max)] or x at culumutive footprint > 90% and then until the distance of interest is reached, 
  '      but limited x_max + 200*height_aerodynamic (x_200z).
  ' 5th: If upwind range of interest has not been reached, this segment is integrated from x at FP_90 = 90% (x_90)
  '      or x_max + 200*height_aerodynamic (x_200z) to upwind distance of interest, but limited to x_90 (or x_200z) + 100*height_aerodynamic.  

  ' Use a high resolution of integration intervals for the first three segments 
  '     a lower resolution for the 4th and 5th segments, but high precision numerical method of Boole's rule

   '1st numerical integration segment: Upwind range within the left inflection point
    x_R  = 0                                                        'Reset
    Integration_interval = x_inflection_L/NMBR_INT_INTERV_SEGMENT   'In numerical integration, use x at the left footprint inflection point as the ending boundary of this segment
    FP_R = 0                                                        'Reset

    'Upwind range within the left inflection point
    For J = 1 To NMBR_INT_INTERV_SEGMENT
      x_L = x_R
      x_R = x_R + Integration_interval
      FP_cumulative_prev = FP_cumulative

      'Footprint value at the left boundary of integral interval
      FP_L = FP_R

      'Footprint value at the right boundary of integral interval
      FP_R = xgz*EXP(-xz/x_R)/(x_R^(Mu + 1))

      'The trapezoidal rule used for an individual interval to cumulate the footprint
      FP_cumulative += Integration_interval*(FP_L + FP_R)/2

      'Find the footprint w/in the range of interest
      If ((x_L < upwnd_dist) AND (x_R >= upwnd_dist)) Then
        FP_win_range = 100*(FP_cumulative_prev + (FP_cumulative - FP_cumulative_prev)*(upwnd_dist - x_L)/Integration_interval)
      EndIf

      'Find the 40% footprint distance
      If (FP_cumulative >= 0.4) AND (FP_40pct_range = 0) Then
        FP_40pct_range = x_R - Integration_interval*(FP_cumulative - 0.4)/(FP_cumulative - FP_cumulative_prev)
      EndIf

    Next J

    '2nd numerical integration segment: Upwind range from the left footprint inflection point to the maximum footprint
    Integration_interval = (x_max - x_inflection_L)/NMBR_INT_INTERV_SEGMENT   'In this segment, use x at the left inflection point as the starting boundary and x_max as the ending boundary

    For J = 1 To NMBR_INT_INTERV_SEGMENT
      x_L = x_R
      x_R = x_R + Integration_interval
      FP_cumulative_prev = FP_cumulative

      'Footprint value at the left boundary of integral interval
      FP_L = FP_R

      'Footprint value at the right boundary of integral interval
      FP_R = xgz*EXP(-xz/x_R)/(x_R^(Mu + 1))

      'The trapezoidal rule used for an individual interval to cumulate the footprint
      FP_cumulative += Integration_interval*(FP_L + FP_R)/2

      'Find the footprint w/in the range of interest
      If ((x_L < upwnd_dist) AND (x_R >= upwnd_dist)) Then
        FP_win_range = 100*(FP_cumulative_prev + (FP_cumulative - FP_cumulative_prev)*(upwnd_dist - x_L)/Integration_interval)
      EndIf

      'Find the 40% footprint distance
      If (FP_cumulative >= 0.4) AND (FP_40pct_range = 0) Then
        FP_40pct_range = x_R - Integration_interval*(FP_cumulative - 0.4)/(FP_cumulative - FP_cumulative_prev)
      EndIf

      'Find the 55% footprint distance
      If (FP_cumulative >= 0.55) AND (FP_55pct_range = 0) Then
        FP_55pct_range = x_R - Integration_interval*(FP_cumulative - 0.55)/(FP_cumulative - FP_cumulative_prev)
      EndIf

    Next J

    '3rd numerical integration segment: Upwind range from the maximum footprint to the right footprint inflection point and further to [x_inflection_R + (x_inflection_R -x_max)] or until 90% footprint is reached
    Integration_interval = (x_inflection_R - x_max)/NMBR_INT_INTERV_SEGMENT   'In this segment, use x_max as the starting boundary and x at the right inflection point as the boundary of middle interval

    'Upwind range within two times of range from x_max to the right inflection point
    For J = 1 To 2*NMBR_INT_INTERV_SEGMENT                                    'The fine resolution of integration is used even beyong x_inflection_R to [x_inflection_R + (x_inflection_R -x_max)] or until 90% footprint is reached
      x_L = x_R
      x_R = x_R + Integration_interval
      FP_cumulative_prev = FP_cumulative

      'Footprint value at the left boundary of integration interval
      FP_L = FP_R

      'Footprint value at the right boundary of integration interval
      FP_R = xgz*EXP(-xz/x_R)/(x_R^(Mu + 1))

      'The trapezoidal rule used for an individual interval to cumulate footprint
      FP_cumulative += Integration_interval*(FP_L + FP_R)/2

      'Find the footprint w/in the range of interest
      If ((x_L < upwnd_dist) AND (x_R >= upwnd_dist)) Then
        FP_win_range = 100*(FP_cumulative_prev + (FP_cumulative - FP_cumulative_prev)*(upwnd_dist - x_L)/Integration_interval)
      EndIf

      'Find the 40% footprint distance
      If (FP_cumulative >= 0.4) AND (FP_40pct_range = 0) Then
        FP_40pct_range = x_R - Integration_interval*(FP_cumulative - 0.4)/(FP_cumulative - FP_cumulative_prev)
      EndIf

      'Find the 55% footprint distance
      If (FP_cumulative >= 0.55) AND (FP_55pct_range = 0) Then
        FP_55pct_range = x_R - Integration_interval*(FP_cumulative - 0.55)/(FP_cumulative - FP_cumulative_prev)
      EndIf

      'Find the 90% footprint distance
      If (FP_cumulative >= 0.9) AND (FP_90pct_range = 0) Then
        FP_90pct_range = x_R - Integration_interval*(FP_cumulative - 0.9)/(FP_cumulative - FP_cumulative_prev)
        Exit For
      EndIf

    Next J

    '4th numerical integration segment: x > [x_inflection_R + (x_inflection_R - x_max)] or culumutive footprint > 90%
    ' Use lower intergration resolution, but the more accurate numerical integration method of Boole's rule
    Integration_interval = 4*height_aerodynamic

    'If upwind range of 90% footprint is not reached. Continue, but limited to x_max + 200*height_aerodynamic
    While ((FP_cumulative < 0.9) AND (x_R - x_max < 200*height_aerodynamic))
      x_L = x_R
      x_R = x_R + Integration_interval
      FP_cumulative_prev = FP_cumulative

      '*** Boole's rule *****
      'Footprint value at the left boundary of an integration interval
      FP_L = FP_R

      'Footprint value at the 1st, 2nd, and 3rd quarter integration interval
      FP_M1 = xgz*EXP(-xz/(x_L + 0.25*Integration_interval))/((x_L + 0.25*Integration_interval)^(Mu + 1))
      FP_M2 = xgz*EXP(-xz/(x_L + 0.50*Integration_interval))/((x_L + 0.50*Integration_interval)^(Mu + 1))
      FP_M3 = xgz*EXP(-xz/(x_L + 0.75*Integration_interval))/((x_L + 0.75*Integration_interval)^(Mu + 1))

      'Footprint value at the right boundary of an integration interval
      FP_R = xgz*EXP(-xz/x_R)/(x_R^(Mu + 1))

      'The Boole's rule used for an individual interval to cumulate the footprint
      FP_cumulative += Integration_interval*(7*FP_L + 32*FP_M1 + 12*FP_M2 + 32*FP_M3 +7*FP_R)/90

      'Find the footprint w/in the range of interest
      If ((x_L < upwnd_dist) AND (x_R >= upwnd_dist)) Then
        FP_win_range = 100*(FP_cumulative_prev + (FP_cumulative - FP_cumulative_prev)*(upwnd_dist - x_L)/Integration_interval)
      EndIf

      'Find the 40% footprint distance
      If ((FP_cumulative >= 0.4) AND (FP_40pct_range = 0)) Then
        FP_40pct_range = x_R - Integration_interval*(FP_cumulative - 0.4)/(FP_cumulative - FP_cumulative_prev)
      EndIf

      'Find the 55% footprint distance
      If ((FP_cumulative >= 0.55) AND (FP_55pct_range = 0)) Then
        FP_55pct_range = x_R - Integration_interval*(FP_cumulative - 0.55)/(FP_cumulative - FP_cumulative_prev)
      EndIf

    Wend

    'Find the 90% footprint distance
    If ((FP_cumulative >= 0.90) AND (FP_90pct_range = 0)) Then
      FP_90pct_range = x_R - Integration_interval*(FP_cumulative - 0.9)/(FP_cumulative - FP_cumulative_prev)
    EndIf

    ' Assign FP_90pct_range as NaN if culmulative footprint can not reach 0.9 within x_max + 200*height_aerodynamic
    If ((FP_cumulative < 0.90) AND (FP_90pct_range = 0)) Then
      FP_90pct_range = NaN
    EndIf

    ' 5th numerical integration segment:
    ' If upwind range of interest has not been reached, this segment is integrated
    ' from x at FP_90 = 90% (x_90) or x_max + 200*height_aerodynamic (x_200z)(if FP_90 is not reached) to upwind distance of interest, 
    ' but limited to x_90 (or x_200z) + 100*height_aerodynamic. 
    
    If (x_R < upwnd_dist) Then

      'Control the integration w/in 25 iterations after above integrations
      If ((upwnd_dist - x_R) < (100*height_aerodynamic)) Then

        Interval_count       = INT((upwnd_dist - x_R)/Integration_interval)
        Integration_interval = (upwnd_dist - x_R)/Interval_count              'Rescale integration interval

        For J = 1 To  Interval_count                                           '100*height_aerodynamic after above integration, the cumulative footprint is enough
          x_L = x_R
          x_R = x_R + Integration_interval
          FP_cumulative_prev = FP_cumulative

          '*** Boole's rule *****
          'Footprint value at the left boundary of integration interval
          FP_L = FP_R

          'Footprint value at the right boudary of the 1st, 2nd, and 3rd quarter integration interval
          FP_M1 = xgz*EXP(-xz/(x_L + 0.25*Integration_interval))/((x_L + 0.25*Integration_interval)^(Mu + 1))
          FP_M2 = xgz*EXP(-xz/(x_L + 0.50*Integration_interval))/((x_L + 0.50*Integration_interval)^(Mu + 1))
          FP_M3 = xgz*EXP(-xz/(x_L + 0.75*Integration_interval))/((x_L + 0.75*Integration_interval)^(Mu + 1))

          'Footprint value at the right boundary of integration interval
          FP_R = xgz*EXP(-xz/x_R)/(x_R^(Mu + 1))

          FP_cumulative += Integration_interval*(7*FP_L + 32*FP_M1 + 12*FP_M2 + 32*FP_M3 +7*FP_R)/90
          
          'Try FP FP_90pct_range again in case that FP_90pct_range is not resolved
          If ((FP_cumulative >= 0.9) AND (FP_90pct_range = NaN)) Then
            FP_90pct_range = x_R - Integration_interval*(FP_cumulative - 0.9)/(FP_cumulative - FP_cumulative_prev)
          EndIf

        Next J

        Select Case FP_cumulative
        Case Is < 1.00
          FP_win_range = 100*FP_cumulative
        Case Is >=1
          FP_win_range = 99
        EndSelect

      Else
        FP_win_range = 99
      EndIf

    EndIf

  Else
    x_max          = NaN
    FP_win_range   = NaN
    FP_40pct_range = NaN
    FP_55pct_range = NaN
    FP_90pct_range = NaN
  EndIf
EndSub
'*** End of subroutines for footprint characteristics ***

#If (SENSOR_FW) Then
'*** Beginning self-defined function for time constant of FW sensor ****
'  SUBROUTINE             MAIN PROGRAM
'  FW_D                   FW_diameter
'  FW_temperature         fw_avg
'  U                      rslt_wnd_spd
'  density_moist_air      rho_a_avg
Function Time_Const_Thermocouple_E(FW_D, FW_temperature, U, density_moist_air)
  Const C_TC_E   =  420.7734       'Specific heat of junction of thermocouple E [J/(kg C)]
  Const rho_TC_E =  8825           'Specific gravity (material density) of junction of thermocouple E [Kg/m^3]

  Dim K_air                        'Thermal conductivity of air [W/(m C)]
  Dim mu_air                       'Viscosity of air [kg/(m s)]
  Dim Re                           'Reynolds number (dimensionless)
  Dim Nu                           'Nusselt number (dimensionless)

  K_air  = 2.42508e-2 + 7.038086e-5*FW_temperature     'Table 1 Montgomery (1947)
  mu_air = 1.716800e-5 + 4.982100e-8*FW_temperature    'Table 1 Montgomery (1947)

  Re = (2*density_moist_air*FW_D*U)/mu_air
  Nu = 2.0 + 0.18*Re^0.67

  Return ((0.250*FW_D*FW_D*rho_TC_E*C_TC_E)/(K_air*Nu))
EndFunction
#EndIf

' Calculate separation of scalar sensor sensing center to CSAT measurement center
'    1. Separation distance normal to wind direction (effective separation distance)
'    2. Separation distance along with wind direction (effective lag distance)
'  SUBROUTINE             MAIN PROGRAM
'  wnd_dir                wnd_dir_sonic
'  separation_x           separation_x_IRGA or separation_x_FW
'  separation_y           separation_y_IRGA or separation_y_FW
'  separation_lat_dis     separation_lat_dist_IRGA or separation_lat_dist_FW
'  separation_lag_dis     separation_lag_dist_IRGA or separation_lag_dist_FW

Sub Separation_Lag_Lateral_Distances (wnd_dir, separation_x, separation_y, separation_lat_dis, separation_lag_dis)
  separation_lag_dis =  separation_x*COS(wnd_dir) + separation_y*SIN(wnd_dir)
  separation_lat_dis = -separation_x*SIN(wnd_dir) + separation_y*COS(wnd_dir)
EndSub

'********************'
'*** MAIN PROGRAM ***'
'*********************'
BeginProg
  #If (SENSOR_HFP) Then

  'Load calibrations of soil heat flux plate.
  For i = 1 To NMBR_SHFP
    Read shf_plate_cal(i)
  Next i

  #EndIf

  ' *** Beginning to store and read station variables in CPU ***
  sys_conf_var_file = FileOpen ("CPU:sys_conf_var.dat", "rb", 0)     'Open file and check if a file exists.
  FileClose (sys_conf_var_file)                                      'Close file after check

  If (sys_conf_var_file = 0) Then
    ' Set default values of station variables (Default values of 0 are listed for code readibilty)
    sonic_azimuth      = 0
    latitude           = 41.766           'Latitude of Campbell Scientific Campus, Logan, UT, USA
    hemisphere_NS      = 1                '"1" for north and "-1" for south. Campbell Scientific Campus is located in Noth Hemisphere
    longitude          = 111.855          'Longitude of Campbell Scientific Campus, Logan, UT, USA
    hemisphere_EW      = -1               '"1" for east and "-1" for west. Campbell Scientific Campus is located in West Hemisphere
    height_measurement = 3
    displacement_user  = 0                '"0" indicates that the user DOES NOT have preferred zero displacement height
    height_canopy      = 0
    surface_type       = BARELAND
    roughness_user     = 0                '"0" indicates that the user DOES NOT have preferred roughness length

    Select Case SENSOR_IRGASON
    Case TRUE
      separation_x_irga = 0              'Coordinate x of IRGASON IRGA measurement center in the sonic coordinate system
      separation_y_irga = 0              'Coordinate y of IRGASON IRGA measurement center in the sonic coordinate system
    Case FALSE
      separation_x_irga = 0.04066        'Range: 0.04066 ~0.09126 m:  Coordinate x of EC150 IRGA measurement center in the sonic coordinate system
      separation_y_irga = 0.02905        'Range: 0.02905 ~0.03348 m:  Coordinate y of EC150 IRGA measurement center in the sonic coordinate system
    EndSelect

    #If (SENSOR_FW) Then
    separation_x_FW = 0.35787-0.35200     'Coordinate x of fine wire thermocouple junction in the sonic coordinate system (0.35200 is the default length of FW sensor) 
    separation_y_FW = 0.03259             'Coordinate y of fine wire thermocouple junction in the sonic coordinate system
    FW_diameter     = FW05DIA             'Diameter of fine wire thermocouple
    #EndIf

    #If ((SENSOR_HFP) AND  (SENSOR_CS6XX) AND ((SENSOR_TCAV) OR (SENSOR_CS65X))) Then
    soil_bulk_density = 1300              'Default soil bulk density (kg/m^3)
    Cds               =  870              'Default specific heat of dry mineral soil [J/(kg K)] [Table 8.2 on page 118 in Campbell & Norman (1998)]
    thick_abv_SHFP    =    0.08           'Default depth of HFP01 or HFP01SC below soil surface (m)
    #EndIf

    Calfile (stn_conf_array(1), NMBR_STN_VAR, "CPU:sys_conf_var.dat", 0)         'Store the default values to the file.

  Else

    Calfile (stn_conf_array(1), NMBR_STN_VAR, "CPU:sys_conf_var.dat", 1)         'Read the stored values from the file.

  EndIf
  
  'IF IRGASON, but previously CSAT3A+EC150, automatically reset
  If (SENSOR_IRGASON) Then
    separation_x_irga = 0              'Coordinate x of IRGASON IRGA measurement center in the sonic coordinate system
    separation_y_irga = 0              'Coordinate y of IRGASON IRGA measurement center in the sonic coordinate system
  EndIf
  
   '*** Beginning to calculate zero displacement height, roughness length, and aerodynamic height for use inside the scan ***
  Call Displacement_Roughness_heights (surface_type, displacement_user, roughness_user, height_canopy, height_measurement, d, z0, z)
  '*** End of calculate zero displacement height, roughness length, and aerodynamic height for use inside the scan ***

  For i = 13 To 16 
    If  (NOT (stn_conf_array(i) > 0)) Then 
      stn_conf_array(i) = 100*z            'Default value of 100*z for all sectors in different directions
    EndIf 
  Next 

  z_prev = z
  Move(stn_conf_array_prev(1), NMBR_STN_VAR , stn_conf_array(1), NMBR_STN_VAR)    'Keep current values of stn_conf_array() in stn_conf_array_prev() for later reference as previou values
  surface_type_text = surface_type_array(surface_type)
 
  ' *** End to store and read station variables in CPU ***

  ' *** Beginning to store and read planar fit angles in CPU ***
  sys_conf_var_file = FileOpen ("CPU:sys_planar_fit_angles.dat","rb",0)         'Open the file and check if a file exists
  FileClose (sys_conf_var_file)                                                 'Close file after check

  If (sys_conf_var_file = 0) Then
    Move (planar_fit_angle_array(1,1), 8 , 0, 1)                                 'Default values of 0 are listed for code reading
    Calfile (planar_fit_angle_array(1, 1), 8, "CPU:sys_planar_fit_angles.dat", 0)'Store the default values to the file
  Else
    Calfile (planar_fit_angle_array(1, 1), 8, "CPU:sys_planar_fit_angles.dat", 1)'Read the values from the file
    For i =1 To 4
      If (planar_fit_angle_array (i, 1) <> 0) OR (planar_fit_angle_array (i, 2) <> 0) Then
        Planar_Fit_flg = TRUE
        ExitFor
      EndIf
    Next i
  EndIf

  Move (planar_fit_angle_array_prev(1,1), 8, planar_fit_angle_array(1,1), 8)   'Keep current values PF planar_fit_angle_array() in planar_fit_angle_prev_array() for later reference as previou values
  ' *** End of storing and reading Planar Fit Angles in CPU ***

  ' *** Beginning of loading transfer function values of Dijk (2002) ***
  For i=1 To 35
    Read tran_func_LA_data_Dijk(1,i)       'Load transfer kl values in Dijk (2002)
    Read tran_func_LA_data_Dijk(2,i)       'Load transfer function values of Dijk (2002)
  Next i
  ' *** End of loading transfer function values of Dijk (2002) ***

  #If ((SENSOR_HFP) AND  (SENSOR_CS6XX) AND ((SENSOR_TCAV) OR (SENSOR_CS65X))) Then
  ' Variables used to calculate the number of seconds from the beginning of the program to the end of the first averaging interval (time interval offset)
  RealTime(realtime_array(1))
  Offset_intv_Delta_ht_storage = ((3600*realtime_array(4) + 60*realtime_array(5) + realtime_array(6)) MOD (60*OUTPUT_INTERVAL))
  #EndIf

  'Set the SDM clock speed.
  SDMSpeed (SDM_PER)

  '*************************** SCAN LOOP  **************************************************
  Scan (SCAN_INTERVAL, mSec, SCAN_BUFFER_SIZE, 0)
    'Datalogger panel temperature
    PanelTemp (panel_tmpr, 250)

    #If (SENSOR_TE525x) Then 'This is placed at beginning of scan because PulseCount() is not allowed in any conditional statements.
    '*** Beginning of Precipitation measurements ***
    PulseCount (Precipitation, 1, TE525_PULSE_INPUT, 2, 0, TE525_MULT, 0)
    '*** End of Precipitation measurements ***
    #EndIf

    #If (SENSOR_FW) Then
    '*** Beginning of FW measurements ***
    diag_FW_raw = 0
    TCDiff (FW_raw, 1, mV20, FW_ANALOG_INPUT, TypeE, panel_tmpr, TRUE, 450, 250, 1, 0)
    If (FW_raw = NaN) OR (FW_raw > 80) OR (FW_raw < -50) Then diag_FW_raw = -1

    CallTable delay_fw
    '*** End of FW measurements ***
    #EndIf

    '*** Beginning of CSI IRGA + sonic measurements ***
    'Get EC100 data.
    EC100 (sonic_irga_raw(1), EC100_SDM_ADDR, 1)                                 '1st to 5th elements: Sonic data and 6th to 12rd elements: IRGA, air temperature, and pressure data
    CallTable delay_3d                                                           'Sonic data
    CallTable delay_cs                                                           'IRGA, air temperature, and pressure data

    If (sonic_irga_raw(8) = NAN) Then                                            'The EC150 diagnostic word (diag_irga) is sonic_irga_raw(8).
      NAN_cnt += 1
    Else
      If (NAN_cnt > 4) Then configure_ec100_flg = TRUE
      NAN_cnt = 0
    EndIf

    If (sonic_irga_raw(8) <> NAN) Then

      If (configure_ec100_flg) Then
        Call Config (config_array(1,1), 4, configure_ec100_flg)

      ElseIf (set_press_source_flg) Then
        press_source_array(1,2) = press_source
        Call Config (press_source_array(1,1), 1, set_press_source_flg)

      ElseIf (do_zero_flg) Then
        Call Config (zero_array(1,1), 1, do_zero_flg)

      ElseIf (do_CO2_span_flg) Then
        span_CO2_array(1,2) = CO2_span_gas
        Call Config (span_CO2_array(1,1), 2, do_CO2_span_flg)

      ElseIf (do_H2O_span_flg)
        span_H2O_array(1,2) = Td_span_gas
        Call Config (span_H2O_array(1,1), 2, do_H2O_span_flg)

      ElseIf (set_heater_flg)  Then
        Call Config (heater_option_array(1,1), 1, set_heater_flg)

      ElseIf (EC150_power_flg) Then
        Call Config (EC150_power_array(1,1), 1, EC150_power_flg)
      EndIf

    EndIf
    '*** End of CSI IRGA + sonic measurements ***

    If (scan_count >= (OFFSET + MAX_LAG)) Then

      '*** Beginning of sonic head processing ***
      'Load in sonic head data that has been lagged by EC100_REC_BCK scans
      GetRecord (dly_data_out(1),delay_3d, EC100_REC_BCK)

      Ts = dly_data_out(4)                               'sonic(1): Ts
      Move (Ux, 3, dly_data_out(1), 3)                   'sonic(2), sonic(3), sonic(4) : Ux, Uy, Uz
      diag_sonic = dly_data_out(5)                       'sonic(5): diag_sonic

      'Extract the six warning flags from the sonic diagnostic word
      diag_sonic_tmp = IIF ((diag_sonic <> NAN) AND (diag_sonic <> -1), diag_sonic, &h3f)
      mask = &h1
      For i = 1 To 6
        diag_bits_sonic(i) = diag_sonic_tmp AND mask
        mask = mask*2
      Next i

      'Turn on the intermediate processing disable flag when any sonic head warning flag is high.
      sonic_disable_f = diag_sonic_tmp AND &h3f

      Ts_K = Ts + T_0C_K

      ' Call Table for 5-minute and 30-minute table
      CallTable comp_cov_3d_5min                   'for Steady State Test
      CallTable comp_cov_3d

      ' The data for Steady State Test (SST)
      If (comp_cov_3d_5min.Output(1, 1)) Then
        GetRecord (u_Avg_SST, comp_cov_3d_5min, 1)

        If (NOT (Planar_Fit_flg)) Then
          'Double coordinate rotations
          gamma_5min = wnd_dir_sonic_SST                                                'Rotation angle about z-axis
          alpha_5min = -ATN2(w_Avg_SST, SQR(u_Avg_SST*u_Avg_SST+v_Avg_SST*v_Avg_SST))   'Rotation angle about intermediate y-axis (range of -90 to 90 degrees)

          ' Rotation for momentum variables
          Call Rotation12_Momentum(alpha_5min, gamma_5min, _
          u_Avg_SST,   v_Avg_SST,   w_Avg_SST,   uu_Cov_SST,   vv_Cov_SST,   ww_Cov_SST,  uv_Cov_SST,   uw_Cov_SST,   vw_Cov_SST, _
          u_Avg_SST_R, v_Avg_SST_R, w_Avg_SST_R, uu_Cov_SST_R, vv_Cov_SST_R, ww_Cov_SST_R,uv_Cov_SST_R, uw_Cov_SST_R, vw_Cov_SST_R)

          'Rotation for the covariance of sonic temperature with velocities
          Call Rotation12_Scalar_Covariance(alpha_5min, gamma_5min, _
          uTs_Cov_SST,   vTs_Cov_SST,   wTs_Cov_SST, _
          uTs_Cov_SST_R, vTs_Cov_SST_R, wTs_Cov_SST_R)
        Else
          'Planar Fit Rotation
          If (wnd_dir_sonic_SST <= 60)      Then
            alpha_5min = alpha_PF_60_300
            beta_5min  = beta_PF_60_300
          ElseIf (wnd_dir_sonic_SST <= 170) Then
            alpha_5min = alpha_PF_60_170
            beta_5min  = beta_PF_60_170
          ElseIf (wnd_dir_sonic_SST < 190)  Then
            alpha_5min = alpha_PF_170_190
            beta_5min  = beta_PF_170_190
          ElseIf (wnd_dir_sonic_SST < 300)  Then
            alpha_5min = alpha_PF_190_300
            beta_5min  = beta_PF_190_300
          Else
            alpha_5min = alpha_PF_60_300
            beta_5min  = beta_PF_60_300
          EndIf

          ' Rotations for momentum variables
          Call Rotation23_Momentum(alpha_5min, beta_5min, _
          u_Avg_SST,   v_Avg_SST,   w_Avg_SST,   uu_Cov_SST,   vv_Cov_SST,   ww_Cov_SST,   uv_Cov_SST,   uw_Cov_SST,   vw_Cov_SST, _
          u_Avg_SST_R, v_Avg_SST_R, w_Avg_SST_R, uu_Cov_SST_R, vv_Cov_SST_R, ww_Cov_SST_R, uv_Cov_SST_R, uw_Cov_SST_R, vw_Cov_SST_R)

          ' Rotations for the covariance of sonic temperature with velocities
          Call Rotation23_Scalar_Covariance(alpha_5min, beta_5min, _
          uTs_Cov_SST,   vTs_Cov_SST,    wTs_Cov_SST, _
          uTs_Cov_SST_R, vTs_Cov_SST_R,  wTs_Cov_SST_R)
        EndIf

        If (uw_Cov_SST_R <> NaN) AND (vw_Cov_SST_R <> NaN) AND (wTs_Cov_SST_R <> NaN) Then
          RN_uw_cov_R  += uw_Cov_SST_R
          RN_vw_cov_R  += vw_Cov_SST_R
          RN_wTs_cov_R += wTs_Cov_SST_R

          nmbr_interval_qc_csat += 1
        EndIf

      EndIf

      If (comp_cov_3d.Output(1, 1) AND comp_cov_3d_5min.Output(1, 1))Then
        GetRecord (Ux_Avg, comp_cov_3d, 1)                             'Ux_avg is the 1st element of cov_out_sonic
        Ts_Std = SQR(Ts_Std)

        '*** Coordinate rotations ***
        If (NOT (Planar_Fit_flg)) Then
          'Double coordinate rotations
          gamma = wnd_dir_sonic                                          'Rotation angle about z-axis
          alpha = -ATN2(Uz_Avg, SQR(Ux_Avg*Ux_Avg + Uy_Avg*Uy_Avg))      'Rotation angle about intermediate y-axis (range of -90 to 90 degrees)

          ' Rotation for momentum variables
          Call Rotation12_Momentum(alpha, gamma, _
          Ux_Avg,  Uy_Avg,  Uz_Avg,  Ux_Std,  Uy_Std,  Uz_Std,  UxUy_Cov, UxUz_Cov, UyUz_Cov, _
          u_Avg_R, v_Avg_R, w_Avg_R, u_Std_R, v_Std_R, w_Std_R, uv_Cov_R, uw_Cov_R, vw_Cov_R)
          'Here, u_std_R, v_std_R, and w_std_R are uu_cov_R, vv_cov_R, and wv_cov_R. The three variables
          'are converted into standard deviation as indicated by "std" in subsequent calculations
          Ux_Std = SQR(Ux_Std)
          Uy_Std = SQR(Uy_Std)
          Uz_Std = SQR(Uz_Std)
          'Rotation for the covariance of sonic temperature with velocities
          Call Rotation12_Scalar_Covariance(alpha, gamma, _
          TsUx_Cov,  TsUy_Cov,  TsUz_Cov, _
          uTs_Cov_R, vTs_Cov_R, wTs_Cov_R)
        Else
          'Planar Fit Rotation
          If (wnd_dir_sonic <= 60)       Then
            alpha = alpha_PF_60_300
            beta  = beta_PF_60_300
          ElseIf (wnd_dir_sonic <= 170)  Then
            alpha = alpha_PF_60_170
            beta  = beta_PF_60_170
          ElseIf (wnd_dir_sonic < 190)   Then
            alpha = alpha_PF_170_190
            beta  = beta_PF_170_190
          ElseIf (wnd_dir_sonic < 300)   Then
            alpha = alpha_PF_190_300
            beta  = beta_PF_190_300
          Else
            alpha = alpha_PF_60_300
            beta  = beta_PF_60_300
          EndIf

          ' Rotations for momentum variables
          Call Rotation23_Momentum(alpha, beta, _
          Ux_Avg,  Uy_Avg,  Uz_Avg,  Ux_Std,  Uy_Std,  Uz_Std,  UxUy_Cov, UxUz_Cov, UyUz_Cov, _
          u_Avg_R, v_Avg_R, w_Avg_R, u_Std_R, v_Std_R, w_Std_R, uv_Cov_R, uw_Cov_R, vw_Cov_R)
          'Here, u_std_R, v_std_R, and w_std_R are uu_cov_R, vv_cov_R, and ww_cov_R. The three variables
          'are converted into standard deviation as indicated by "std" in subsequent calculations
          Ux_Std = SQR(Ux_Std)
          Uy_Std = SQR(Uy_Std)
          Uz_Std = SQR(Uz_Std)
          ' Rotations for the covariance of sonic temperature with velocities
          Call Rotation23_Scalar_Covariance(alpha, beta, _
          TsUx_Cov, TsUy_Cov,  TsUz_Cov, _
          uTs_Cov_R,vTs_Cov_R, wTs_Cov_R)
        EndIf
        '*** End of coordinate rotations ***

        'Rotate the sonic head RHC system so the negative x-axis points north
        wnd_dir_compass = (360 + sonic_azimuth - wnd_dir_sonic) MOD 360

        'Compute specific turbulence kinetic energy
        TKE = 0.5*(u_Std_R + v_Std_R + w_Std_R)

        'Compute the standard deviation from the variance after rotation
        u_Std_R = SQR (u_Std_R)
        v_Std_R = SQR (v_Std_R)
        w_Std_R = SQR (w_Std_R)

        '*** Freq corrections for uw_cov_R, vw_cov_R, and wTs_cov_R ***
        'Compute online fluxes after rotations.
        u_star_R =  SQR(SQR((uw_Cov_R*uw_Cov_R) + (vw_Cov_R*vw_Cov_R)))

        ' Preparation for freq corection to uw_cov_R, vw_cov_R, and wTs_cov_R
        ' Obukhov length
        L = -u_star_R*u_star_R*u_star_R*(Ts_Avg + T_0C_K)/(k*g0*wTs_Cov_R)

        ' Atmospheric boundary-layer stability
        stability_zL = z/L

        FreqFactor_uw_vw_Prev  = 0
        Call  FreqFactorCSAT_uw_vw_BA_LA(z, stability_zL, rslt_wnd_spd, FreqFactor_uw_vw)

        uw_Cov_R_F = FreqFactor_uw_vw * uw_Cov_R
        vw_Cov_R_F = FreqFactor_uw_vw * vw_Cov_R
        u_star = SQR(SQR ((uw_Cov_R_F*uw_Cov_R_F) + (vw_Cov_R_F*vw_Cov_R_F)))

        FreqFactor_wTs_Prev = 0
        Call  FreqFactorCSAT_wTs_BA_LA (z, stability_zL, rslt_wnd_spd, tran_func_LA_data_Dijk(1,1), FreqFactor_wTs)

        wTs_Cov_R_F = FreqFactor_wTs * wTs_Cov_R

        ' Recalculate Obukhov length
        L = -u_star*u_star*u_star*(Ts_Avg+T_0C_K)/(k*g0*wTs_Cov_R_F)

        ' Recalculate atmospheric boundary-layer stability
        stability_zL_prev = stability_zL
        stability_zL      = z/L

        iteration_FreqFactor = 1
        While (((ABS (FreqFactor_uw_vw_Prev -FreqFactor_uw_vw) >= ACCURACY_FREQ_FACTOR) OR _
          (ABS (FreqFactor_wTs_Prev - FreqFactor_wTs) >= ACCURACY_FREQ_FACTOR)) AND ((stability_zL > 0) AND (iteration_FreqFactor <= 10)))

          stability_zL_prev     = stability_zL
          FreqFactor_uw_vw_Prev = FreqFactor_uw_vw
          FreqFactor_wTs_Prev   = FreqFactor_wTs

          Call  FreqFactorCSAT_uw_vw_BA_LA (z, stability_zL, rslt_wnd_spd, FreqFactor_uw_vw)
          uw_Cov_R_F = FreqFactor_uw_vw * uw_Cov_R
          vw_Cov_R_F = FreqFactor_uw_vw * vw_Cov_R
          u_star = SQR(SQR (uw_Cov_R_F*uw_Cov_R_F + vw_Cov_R_F*vw_Cov_R_F))

          Call  FreqFactorCSAT_wTs_BA_LA (z, stability_zL, rslt_wnd_spd, tran_func_LA_data_Dijk(1,1), FreqFactor_wTs)
          wTs_Cov_R_F = FreqFactor_wTs * wTs_Cov_R

          ' Obukhov length
          L = -u_star*u_star*u_star*(Ts_Avg+T_0C_K)/(k*g0*wTs_Cov_R_F)

          ' Atmospheric boundary-layer stability
          stability_zL = z/L

          iteration_FreqFactor += 1
        Wend
        '*** End of freq corrections for uw_cov_R, vw_cov_R, and wTs_cov_R ***

        '*** Beginning of data quality classification for momentum flux ***
        'Calculate the measures of relative non-stationarity (Steady State Test)
        RN_uw_vw_cov_R = ABS(((RN_uw_cov_R + RN_vw_cov_R)/nmbr_interval_qc_csat - uw_Cov_R - vw_Cov_R)/(uw_Cov_R + vw_Cov_R))  'in fraction
        Call Data_Quality_Grading_Momentum (Planar_Fit_flg, stability_zL, u_Std_R, w_Std_R, u_star, latitude, wnd_dir_sonic, RN_uw_vw_cov_R, tau_qc_grade)
        RN_uw_cov_R = 0
        RN_vw_cov_R = 0
        '*** End of data quality classification for momentum flux ***

        '*** Footprint characteristics of measured fluxes ***
        'Update roughness length when a user does not specify z0 and wind is sufficiently strong during a neutral condition
        If ((ABS(stability_zL) < 0.02) AND (roughness_user = 0) AND (rslt_wnd_spd > 3) AND (tau_qc_grade <= 6)) Then z0 = z*EXP(-k*rslt_wnd_spd/u_star)

        'Determining upwind distance of interest
        If (wnd_dir_sonic <= 60) Then
          upwnd_dist_intrst = dist_intrst_60_300
        ElseIf (wnd_dir_sonic <= 170) Then
          upwnd_dist_intrst = dist_intrst_60_170
        ElseIf (wnd_dir_sonic < 190)  Then
          upwnd_dist_intrst = dist_intrst_170_190
        ElseIf (wnd_dir_sonic < 300)  Then
          upwnd_dist_intrst = dist_intrst_190_300
        Else
          upwnd_dist_intrst = dist_intrst_60_300
        EndIf

        'Footprint selection
        If ((stability_zL >= -200) AND (stability_zL <= 1) AND (u_star >= 0.2) AND (z >= 1)) Then
          'Kljun et al (2004)
          FP_Equation = "Kljun et al"
          'Calculate footprint charactetistics
          Call FootprintCharacteristics_Kljun(u_star, w_Std_R, z, L, z0, upwnd_dist_intrst, FP_dist_intrst, FP_max, FP_40, FP_55, FP_90)
        Else
          'Kormann and Meixner (2001)
          FP_Equation = "KormannMeixner"
          'Calculate footprint charactetistics
          Call FootprintCharacteristics_KormannMeixner(u_star, z, stability_zL, rslt_wnd_spd, upwnd_dist_intrst, FP_dist_intrst, FP_max, FP_40, FP_55, FP_90)
        EndIf
        '*** End of footprint characteristics of measured fluxes ***
      EndIf
      '*** End of sonic head processing ***

      '*** Beginning of IRGA processing ***
      'Load in the IRGA data that has been lagged by EC100_REC_BCK scans.
      mask = &h1
      For i = MAX_LAG To - MAX_LAG Step -1
        array_index = MAX_LAG + 1 - i                                'Convert i = 2, 1, 0, -1, -2 to array_index = 1, 2, 3, 4, 5

        GetRecord (dly_data_out(1), delay_CS, (EC100_REC_BCK + i))
        If (i = 0) Then Move (CO2, 7, dly_data_out(1), 7)            'CO2, H2O, diag_irga, amb_tmpr, amb_press, CO2_sig_strgth, H2O_sig_strgth

        'Load the arrays that hold the input data for the covariance instructions.
        Move (cov_array_CO2(array_index, 1), 1, dly_data_out(1),1)   'CO2
        Move (cov_array_CO2(array_index, 2), 3, Ux, 3)
        CO2_bad_rng_sig_array (array_index) = ((dly_data_out(6) < CO2_SIG_STRGTH_THRESHOULD) OR (dly_data_out(1) <0) OR (dly_data_out(1) > CO2_RNG_TOP_LIMIT))

        Move (cov_array_H2O(array_index, 1), 1, dly_data_out(2),1)   'H2O
        Move (cov_array_H2O(array_index, 2), 3, Ux, 3)
        H2O_bad_rng_sig_array (array_index) = ((dly_data_out(7) < H2O_SIG_STRGTH_THRESHOULD) OR (dly_data_out(2) <0) OR (dly_data_out(2) > H2O_RNG_TOP_LIMIT))

        'Extract the diagnostic word from each record of lagged data, used to exclude data from covariance calculation in Tables: comp_cov_CO2, comp_cov_H2O, and comp_cov_cs_5min.
        irga_bad_data_flg_array(array_index) = mask AND IIF ((dly_data_out(3) <> NAN) AND (dly_data_out(3) <> -1),dly_data_out(3), &h3fffff)

      Next i

      'Call tables for lag maximuzation
      CallTable comp_cov_CO2
      CallTable comp_cov_H2O

      'Extract the twenty two flags from the IRGA diagnostic word
      diag_irga_tmp = IIF ((diag_irga <> NAN) AND (diag_irga <> -1),diag_irga, &h3fffff)
      For i = 1 To 22
        diag_bits_irga(i) = diag_irga_tmp AND mask
        mask = mask*2
      Next i

      'Filter data in the covariance instruction if the IRGA reports bad data.
      irga_disable_f = irga_bad_data_f

      'Call table for data used for data quality grading
      CallTable Comp_cov_CS_5min

      If ((SENSOR_IRGASON) AND (Ts_K <> NaN)) Then
        'Compute fast response air temperature from sonic temperature and IRGASON vapor density.
        Tc_K = Ts_K/(1+0.32*Rv*H2O*Ts_K/amb_press)       'eq 20 in Swiatek (2007)
      
      ElseIf ((SENSOR_CSAT3AEC150) OR (Ts_K = NaN)) Then
        Tc_K = amb_tmpr + T_0C_K                         'Tc_K in K
      EndIf

      'Calculate water vapor pressure using IRGASON measurements
      e     = H2O*Rv*Tc_K                                'Ideal gas equation (kPa)
      rho_d = (amb_press-e)/(Tc_K*Rd)                    'g/m^3
      rho_a = (rho_d + H2O)/1000                         'kg/m^3

      'Convert Tc in K to Tc in C
      Tc = Tc_K - T_0C_K                                 'Tc in C

      'Saturation water pressure at current temperature
      Enhance_Factor1 = 1.00041 + amb_press*(3.48e-5 + 7.4e-9*(Tc + 30.6 - 0.38*amb_press)^2)   'Eq. 6 from Appendix A of flux program manual

      Select Case Tc                                                                            'Eq. 5 from Appendix A of flux program manual
      Case Is >= 0
        e_sat = 0.61121*Enhance_Factor1*EXP(17.368*Tc/(Tc + 238.88))
      Case Is < 0
        e_sat = 0.61121*Enhance_Factor1*EXP(17.966*Tc/(Tc + 247.15))
      EndSelect

      'Relative humidity
      RH = 100 * e/e_sat

      'Dew point temperature for general use for accurately computing the final dew point temperature
      Enhance_Factor2 = 1.00072 + 3.46e-5*amb_press                                              'Eq. 9 from Appendix A of flux program manual

      x_tmp           = LN(e/(0.61121*Enhance_Factor2))                                          'For dew point temperature, assume that e is saturation water vapor pressure
      Td_gu           = 240.97*x_tmp/(17.502-x_tmp)

      'Accurate dew point temperature
      Enhance_Factor1 = 1.00041 + amb_press*(3.48e-5 + 7.4e-9*(Td_gu + 30.6 - 0.38*amb_press)^2) 'Eq. 6 from Appendix A of flux program manual

      x_tmp           = LN(e/(0.61121*Enhance_Factor1))                                          'For dew point temperature, assume that e is saturation water vapor pressure

      Select Case Td_gu                                                                           'Eq. 11 from Appendix A of flux program manual
      Case Is >= 0
        Td = 238.88*x_tmp/(17.368 - x_tmp)
      Case Is < 0
        Td = 247.15*x_tmp/(17.966 - x_tmp)
      EndSelect

      'Compute the molar mixing ratio of CO2 and H2O.
      divisor = (amb_press/(R*Tc_K))-(H2O/18)
      CO2_mixratio = CO2/(0.04401*divisor)
      H2O_mixratio = H2O/(0.01802*divisor)

      CallTable comp_mean

      If (comp_cov_cs_5min.Output(1, 1)) Then
        GetRecord (CO2CO2_Cov_SST, comp_cov_cs_5min, 1)

        If (NOT (Planar_Fit_flg)) Then
          'Rotation for the covariance of CO2 with velocities
          Call Rotation12_Scalar_Covariance(alpha_5min, gamma_5min, _
          uCO2_Cov_SST,   vCO2_Cov_SST,   wCO2_Cov_SST, _
          uCO2_Cov_SST_R, vCO2_Cov_SST_R, wCO2_Cov_SST_R)
          'Rotation for the covariance of H2O with velocities
          Call Rotation12_Scalar_Covariance(alpha_5min, gamma_5min, _
          uH2O_Cov_SST,   vH2O_Cov_SST,   wH2O_Cov_SST, _
          uH2O_Cov_SST_R, vH2O_Cov_SST_R, wH2O_Cov_SST_R)
        Else
          'Rotations for the covariance of CO2 with velocities
          Call Rotation23_Scalar_Covariance(alpha_5min, beta_5min, _
          uCO2_Cov_SST,   vCO2_Cov_SST,    wCO2_Cov_SST, _
          uCO2_Cov_SST_R, vCO2_Cov_SST_R,  wCO2_Cov_SST_R)
          'Rotations for the covariance of H2O with velocities
          Call Rotation23_Scalar_Covariance(alpha_5min, beta_5min, _
          uH2O_Cov_SST,   vH2O_Cov_SST,    wH2O_Cov_SST, _
          uH2O_Cov_SST_R, vH2O_Cov_SST_R,  wH2O_Cov_SST_R)
        EndIf

        If ((wCO2_Cov_SST_R <> NaN) AND (wH2O_Cov_SST_R <> NaN)) Then
          RN_wCO2_Cov_R += wCO2_Cov_SST_R
          RN_wH2O_Cov_R += wH2O_Cov_SST_R
          nmbr_interval_qc_irga += 1
        EndIf

      EndIf

      If (comp_cov_CO2.Output(1,1) AND comp_cov_H2O.Output(1,1) AND comp_mean.Output(1,1) AND comp_cov_cs_5min.Output(1, 1))  Then
        GetRecord (CO2_Avg_b2,   comp_cov_CO2, 1)
        GetRecord (H2O_Avg_b2,   comp_cov_H2O, 1)
        GetRecord (amb_tmpr_Avg, comp_mean,    1)

        VPD_air = e_sat_Avg - e_Avg                   'Water vapor pressue deficit

        'Rotate CO2-related covariance
        wCO2_Cov_major_sign = 0                       'Variable indicating the major direction (sign) of CO2 flux

        For i = 1 To (2* MAX_LAG + 1)
          array_index = 5*(i-1) +3
          If (NOT (Planar_Fit_flg)) Then
            'Double rotations
            ' Rotation for the covariance of CO2 with velocities
            Call Rotation12_Scalar_Covariance(alpha, gamma, _
            Cov_out_CO2(array_index),  Cov_out_CO2(array_index + 1),  Cov_out_CO2(array_index + 2), _
            uCO2_vCO2_Cov_lag_R(i, 1), uCO2_vCO2_Cov_lag_R(i, 2),     wCO2_Cov_lag_R (i))
          Else
            ' Planar Fit rotations
            ' Rotation for the covariance of CO2 with velocities
            Call Rotation23_Scalar_Covariance(alpha, beta, _
            Cov_out_CO2(array_index),  Cov_out_CO2(array_index + 1), Cov_out_CO2(array_index + 2), _
            uCO2_vCO2_Cov_lag_R(i, 1), uCO2_vCO2_Cov_lag_R(i, 2),    wCO2_Cov_lag_R (i))
          EndIf

          wCO2_Cov_major_sign += wCO2_Cov_lag_R (i)

        Next i

        ' Calculate the separation distance normal (lateral) to wind and separation distance along wind
        Call Separation_Lag_Lateral_Distances (wnd_dir_sonic, separation_x_irga, separation_y_irga, separation_lat_dist_irga, separation_lag_dist_irga)
        separation_lag_scan_irga = 1000*(separation_lag_dist_irga/rslt_wnd_spd)/SCAN_INTERVAL   'in scan

        wCO2_Cov_R = NaN
        Select Case wCO2_Cov_major_sign
        Case Is >=0

          If separation_lag_scan_irga <= -2    Then             'Find max of wCO2_cov_R
            MaxSpa (wCO2_Cov_R, 3, wCO2_Cov_lag_R (1))

          ElseIf separation_lag_scan_irga < 0  Then             'Search three elements in the array to ensure maximization.
            MaxSpa (wCO2_Cov_R, 3, wCO2_Cov_lag_R (1))

          ElseIf separation_lag_scan_irga = 0  Then
            wCO2_Cov_R = wCO2_Cov_lag_R (3)
            lag_irga = MAX_LAG + 1

          ElseIf separation_lag_scan_irga < 2  Then
            MaxSpa (wCO2_Cov_R, 3, wCO2_Cov_lag_R (3))
            lag_irga = lag_irga + 2

          Else
            MaxSpa (wCO2_Cov_R, 3, wCO2_Cov_lag_R (3))          'Search three elements in the array to ensure maximization.
            lag_irga = lag_irga + 2
          EndIf

        Case Is < 0

          If separation_lag_scan_irga <= -2     Then            'Find min of wCO2_cov_R
            MinSpa (wCO2_Cov_R, 3, wCO2_Cov_lag_R (1))

          ElseIf separation_lag_scan_irga < 0   Then            'Search three elements in the array to ensure maximization in terms of absolute value.
            MinSpa (wCO2_Cov_R, 3, wCO2_Cov_lag_R (1))

          ElseIf separation_lag_scan_irga = 0   Then
            wCO2_Cov_R = wCO2_Cov_lag_R (3)
            lag_irga = MAX_LAG + 1

          ElseIf separation_lag_scan_irga < 2   Then            'Search three elements in the array to ensure maximization in terms of absolute value.
            MinSpa (wCO2_Cov_R, 3, wCO2_Cov_lag_R (3))
            lag_irga = lag_irga + 2

          Else
            MinSpa (wCO2_Cov_R, 3, wCO2_Cov_lag_R (3))
            lag_irga = lag_irga + 2
          EndIf
        EndSelect

        If (wCO2_Cov_R = NaN) Then lag_irga = MAX_LAG + 1       'Lag_IRGA is not evaluated inside SELECT CASE if wCO2_Cov_R = NaN. In this case, data w/o lag delay in cov_out_CO2 are kept.

        'For final storage in flux file
        'Covariance values related to CO2 and H2O before coordinate rotation can be found using lag-IRGA
        array_index =  5*(lag_irga - 1) + 1
        Move (CO2_Avg, 5, Cov_out_CO2(array_index), 5)
        CO2_Std         = SQR (CO2_Std)
        CO2_molfrac_Avg = (CO2_Avg/0.04401) *R*(Tc_Avg + T_0C_K)/amb_press_Avg       'umol/mol

        Move (H2O_Avg, 5, Cov_out_H2O(array_index), 5)
        H2O_Std         = SQR (H2O_Std)
        H2O_molfrac_Avg = (H2O_Avg/0.01802)*R*(Tc_Avg + T_0C_K)/amb_press_Avg        'mmol/mol

        'Covariance of horizontal wind (after coordinate rotations) and CO2 using lag-IRGA
        uCO2_Cov_R = uCO2_vCO2_Cov_lag_R(lag_irga, 1)
        vCO2_Cov_R = uCO2_vCO2_Cov_lag_R(lag_irga, 2)

        'Rotate covariance related to H2O
        If (NOT (Planar_Fit_flg)) Then
          'Double rotations
          ' Rotation for the covariance of H2O with velocities
          Call Rotation12_Scalar_Covariance(alpha, gamma, _
          UxH2O_Cov,  UyH2O_Cov,  UzH2O_Cov, _
          uH2O_Cov_R, vH2O_Cov_R, wH2O_Cov_R)
        ElseIf (Planar_Fit_flg) Then
          ' Planar Fit rotations
          ' Rotation for the covariance of H2O with velocities
          Call Rotation23_Scalar_Covariance(alpha, beta, _
          UxH2O_Cov,  UyH2O_Cov,  UzH2O_Cov, _
          uH2O_Cov_R, vH2O_Cov_R, wH2O_Cov_R)
        EndIf

        'Convert lag_IRGA as an array index in sequential number as a lag number in scan (compare to sonic data, negative: backward and positive: forward)
        lag_irga  = lag_irga  - (MAX_LAG + 1)

        ' Calculate the frequency correction factor for wCO2_cov_R and wH2O_cov_R
        Call FreqFactorCSOPEC_wco2_wh2o_BA_LA_SP (z, stability_zL, rslt_wnd_spd, separation_lat_dist_irga, FreqFactor_wCO2_wH2O)
        wCO2_Cov_R_F = FreqFactor_wCO2_wH2O*wCO2_Cov_R
        wH2O_Cov_R_F = FreqFactor_wCO2_wH2O*wH2O_Cov_R

        'Momentum flux after coordinater rotation and frequency corrections
        tau = rho_a_Avg*u_star^2

        'Correct sonic temperature flux for humidity and calculate sensible heat flux
        wTs_Cov_R_F_SND = wTs_Cov_R_F*(1- 0.51*(H2O_Avg/(1e3*rho_a_Avg)))-0.51*(Ts_Avg+ T_0C_K)*wH2O_Cov_R_F/(1e3*rho_a_Avg)     'eq. 2.53 in van Dijk (2002)

        Cp     = (Cpd*rho_d_Avg + Cpw*H2O_Avg)/(rho_d_Avg + H2O_Avg)                                                             'Specific heat of moist air
        H      = Cp*rho_a_Avg*wTs_Cov_R_F_SND

        T_star = - wTs_Cov_R_F_SND/u_star

        'Apply WPL correction after coordinate rotation and freq corrections
        'IRGA Webb et al. (1980) term for carbon dioxide Eq. (24).
        sigma_wpl     = H2O_Avg/rho_d_Avg
        CO2_E_WPL_R_F = MU_WPL*(CO2_Avg/rho_d_Avg)*wH2O_Cov_R_F
        CO2_T_WPL_R_F = (1 + (MU_WPL*sigma_wpl))*(CO2_Avg/(Tc_Avg+T_0C_K))*wTs_Cov_R_F_SND
        rho_d_Avg     = 0.001*rho_d_Avg                                             'Convert g/m^3 to kg/m^3 for output

        Fc_mass  = wCO2_Cov_R_F + CO2_E_WPL_R_F + CO2_T_WPL_R_F                     'in mg/(m^2 s)
        Fc_molar = 22.72237*Fc_mass                                                 '"22.72237" converts mg/(m^2 s) to umol/(m^2 s)

        'IRGA Webb et al. (1980) term for water vapor Eq. (25).
        H2O_E_WPL_R_F  = MU_WPL*sigma_wpl*wH2O_Cov_R_F
        H2O_T_WPL_R_F  = (1 + (MU_WPL*sigma_wpl))*(H2O_Avg/(Tc_Avg+T_0C_K))*wTs_Cov_R_F_SND

        Lv  = 2501 - 2.365*Tc_Avg                                                   'Stull (1989)
        LE  = Lv* (wH2O_Cov_R_F + H2O_E_WPL_R_F + H2O_T_WPL_R_F)

        Bowen_ratio = H/LE

        '*** Data quality classification for scalar fluxes ***
        'Sensible heat flux
        'Calculate the measures of relative non-stationarity (Steady State Test)
        RN_wTs_cov_R  = ABS((RN_wTs_cov_R/nmbr_interval_qc_csat - wTs_Cov_R)/wTs_Cov_R)     'in fraction
        Call Data_Quality_Grading_Scalar (stability_zL, w_Std_R, u_star, Ts_Std, T_star, latitude, wnd_dir_sonic, RN_wTs_cov_R, H_qc_grade)   'Quality classification for sensible heat flux
        RN_wTs_cov_R = 0
        nmbr_interval_qc_csat = 0

        'CO2 flux
        'Calculate measures of relative non-stationarity (Steady State Test)
        RN_wCO2_Cov_R = ABS((RN_wCO2_Cov_R/nmbr_interval_qc_irga - wCO2_Cov_R)/wCO2_Cov_R)  'in fraction
        Call Data_Quality_Grading_Scalar (stability_zL, w_Std_R, u_star, Ts_Std, T_star, latitude, wnd_dir_sonic, RN_wCO2_Cov_R, Fc_qc_grade)   'Quality classification for CO2 flux
        RN_wCO2_Cov_R = 0

        'H2O flux
        'Calculate measures of relative non-stationarity (Steady State Test)
        RN_wH2O_Cov_R = ABS((RN_wH2O_Cov_R/nmbr_interval_qc_irga - wH2O_Cov_R)/wH2O_Cov_R)  'in fraction
        Call Data_Quality_Grading_Scalar (stability_zL, w_Std_R, u_star, Ts_Std, T_star, latitude, wnd_dir_sonic, RN_wH2O_Cov_R, LE_qc_grade)   'Quality classification for latent heat flux
        RN_wH2O_Cov_R         = 0
        nmbr_interval_qc_irga = 0
        '*** End of data quality classification for scalar fluxes ***

      EndIf
      '*** End of IRGA processing ***
      #If (SENSOR_TMPR_RH) Then

      '*** Beginning of temperature and humidity processing ***
      CallTable stats_tmpr_rh
      If (stats_tmpr_rh.Output(1,1)) Then
        GetRecord (T_probe_Avg,stats_tmpr_rh,1)

        H2O_probe_Avg   = e_probe_Avg/((T_probe_Avg + T_0C_K)*Rv)                            'g/m^3
        rho_d_probe_Avg = 0.001*(amb_press_Avg - e_probe_Avg)/((T_probe_Avg + T_0C_K)*Rd)    'kg/m^3
        rho_a_probe_Avg = rho_d_probe_Avg + H2O_probe_Avg/1000                               'kg/m^3
        RH_probe_Avg    = 100*e_probe_Avg/e_sat_probe_Avg                                    '%
      EndIf
      '*** End of temperature and humidity probe processing ***
      #EndIf

      #If (SENSOR_FW) Then
      '*** Beginning of FW processing ***
      'Load in the FW data that has been lagged by OFFSET scans.
      For i = MAX_LAG To - MAX_LAG Step -1
        array_index = MAX_LAG + 1 - i                                           'Convert i = 2, 1, 0 -1, -2 to array_index = 1, 2, 3, 4, 5

        GetRecord (dly_data_out(1), delay_fw, (OFFSET +i))

        'Load the arrays that hold the input data for the covariance instructions.
        Cov_array_fw(array_index, 1) = dly_data_out(1)                          'fw
        Move (Cov_array_fw(array_index, 2), 3, Ux, 3)

        FW_bad_data_flg(array_index) = (dly_data_out(2) = -1)

      Next i

      FW = Cov_array_fw(MAX_LAG + 1, 1)  'FW with no lag will be stored to Time_Series table

      CallTable comp_cov_fw

      If (comp_cov_fw.Output(1,1)) Then
        GetRecord (FW_Avg_b2, comp_cov_fw, 1)

        wFW_cov_major_sign =0

        For i = 1 To (2* MAX_LAG + 1)
          array_index = 5*(i -1) + 3
          If (NOT (Planar_Fit_flg)) Then
            ' Double rotations
            ' Rotation for the covariance of FW temperature with wind velocities
            Call Rotation12_Scalar_Covariance(alpha, gamma, _
            Cov_out_fw(array_index), Cov_out_fw(array_index + 1), Cov_out_fw(array_index + 2), _
            uFW_vFW_Cov_lag_R(i, 1), uFW_vFW_Cov_lag_R(i, 2),     wFW_Cov_lag_R (i))
          Else
            ' Planar fit rotations
            ' Rotation for the covariance of FW temperature with velocities
            Call Rotation23_Scalar_Covariance(alpha, beta, _
            Cov_out_fw(array_index), Cov_out_fw(array_index + 1), Cov_out_fw(array_index + 2), _
            uFW_vFW_Cov_lag_R(i, 1), uFW_vFW_Cov_lag_R(i, 2),     wFW_Cov_lag_R (i))
          EndIf

          wFW_cov_major_sign += wFW_Cov_lag_R(i)
        Next i

        'Calculate the separation distances normal (lateral) to wind and separation distances along wind
        Call Separation_Lag_Lateral_Distances (wnd_dir_sonic, separation_x_FW, separation_y_FW, separation_lat_dist_FW, separation_lag_dist_FW)
        separation_lag_scan_FW = 1000*(separation_lag_dist_FW/rslt_wnd_spd)/SCAN_INTERVAL   ' in scan

        wFW_Cov_R = NaN
        Select Case wFW_cov_major_sign
        Case Is >=0
          If (separation_lag_scan_FW <= -2)     Then      'Find max of wFW_cov_R
            MaxSpa (wFW_Cov_R, 3, wFW_Cov_lag_R(1))

          ElseIf (separation_lag_scan_FW <= 0)  Then      'Search two elements in the array to ensure maximization.
            MaxSpa (wFW_Cov_R, 2, wFW_Cov_lag_R(1))

          ElseIf (separation_lag_scan_FW < 2)   Then
            MaxSpa (wFW_Cov_R, 2, wFW_Cov_lag_R(3))
            lag_FW = lag_FW + 2

          Else
            MaxSpa (wFW_Cov_R, 3, wFW_Cov_lag_R(3))        'Search three elements in the array to ensure maximization.
            lag_FW = lag_FW + 2
          EndIf

        Case Is < 0
          If (separation_lag_scan_FW <= -2)      Then      'Find min of wFW_cov_R
            MinSpa (wFW_Cov_R, 3, wFW_Cov_lag_R(1))

          ElseIf (separation_lag_scan_FW <= 0)   Then      'Search two elements in the array to ensure maximization in terms of absolute value.
            MinSpa (wFW_Cov_R, 2, wFW_Cov_lag_R(1))

          ElseIf (separation_lag_scan_FW < 2)    Then
            MinSpa (wFW_Cov_R, 2, wFW_Cov_lag_R(3))
            lag_FW = lag_FW + 2

          Else
            MinSpa (wFW_Cov_R, 3, wFW_Cov_lag_R (3))         'Search three elements in the array to ensure maximization in terms of absolute value.
            lag_FW = lag_FW + 2
          EndIf

        EndSelect

        If (wFW_Cov_R = NaN) Then lag_FW = MAX_LAG + 1       'Lag_FW is not evaluated inside SELECT CASE if FW_Uz_Cov_R = NaN. In this case, data w/o lag delay in cov_out_fw are kept.

        ' For final storage in flux table
        ' FW Covariance before coordinate rotation can be found using lag-variable
        array_index = 5*(lag_FW - 1)
        FW_Avg   = Cov_out_fw(array_index + 1)
        FW_Std   = SQR(Cov_out_fw(array_index + 2))
        UxFW_Cov  = Cov_out_fw(array_index + 3)
        UyFW_Cov  = Cov_out_fw(array_index + 4)
        UzFW_Cov  = Cov_out_fw(array_index + 5)

        ' FW Covariance after coordinate rotation also can be found using lag-variable
        uFW_Cov_R = uFW_vFW_Cov_lag_R(lag_FW, 1)
        vFW_Cov_R = uFW_vFW_Cov_lag_R(lag_FW, 2)

        'Convert lag_FW in sequential number for array index to that in scan number. Compare to sonic data, negative: backward and positive: forward.
        lag_FW  = lag_FW  - (MAX_LAG + 1)

        'Calculate FW time constant
        time_const_FW =  Time_Const_Thermocouple_E(FW_diameter, FW_Avg, rslt_wnd_spd, rho_a_Avg)

        Call FreqFactorCSATFW_wT_BA_LA_TC_SP (z, stability_zL, rslt_wnd_spd, separation_lat_dist_FW, time_const_FW, FreqFactor_wFW)
        wFW_Cov_R_F = FreqFactor_wFW*wFW_Cov_R

        'Calculate sensible heat flux
        ' Using the specific heat and density of moist air that are caluated using IRGASON data
        H_FW = Cp*rho_a_Avg*wFW_Cov_R_F

      EndIf
      '*** End of FW processing ***
      #EndIf
      #If (SENSOR_NR_LITE) Then

      '*** Beginning of NR Lite processing ***
      hor_wind_raw = SQR (sonic_irga_raw(1)*sonic_irga_raw(1) + sonic_irga_raw(2)*sonic_irga_raw(2))
      AvgRun (hor_wind, 1 , hor_wind_raw, NMBR_WND_SAMPLES)                        'Maintain a three second running mean of horizontal wind.
      AvgRun (hor_wind_diag, 1, sonic_irga_raw(5), NMBR_WND_SAMPLES)               'Only correct for wind when hor_wind_diag has been non-zero for past 3 minutes.
      '*** End of NR Lite processing ***

      #EndIf
      #If (SENSOR_Rn) Then
      CallTable stats_net_radiation

      'Get Rn for the current averaging interval ***
      If (stats_net_radiation.Output(1,1)) Then

        GetRecord (Rn, stats_net_radiation, 1)

      EndIf
      #EndIf

      #If (SENSOR_HFP) Then

      '*** Beginning of table for soil heat flux plate ***
      CallTable stats_SHF
      '*** End of table for soil heat flux plate ***

      '*** Beginning of calculating the change in heat storage of soil above soil heat flux plate ***
      If (stats_SHF.Output(1,1)) Then

        GetRecord (shf_plate_avg(1), stats_SHF, 1)

        #If (((SENSOR_TCAV) OR (SENSOR_CS65X)) AND (SENSOR_CS6XX)) Then
        AvgSpa(G_surface, NMBR_SHFP, shf_plate_avg(1))                           'G_surface is used as a temporary variable

        #If (SENSOR_TCAV) Then
        AvgSpa(Tsoil_current_Avg, NMBR_TCAV, Tsoil_current (1))
        #EndIf
        #If ((NOT SENSOR_TCAV) AND (SENSOR_CS65X)) Then
        AvgSpa(Tsoil_current_Avg, NMBR_CS6xx, Tsoil_current (1))
        #EndIf

        AvgSpa(soil_wtr_current_Avg, NMBR_CS6xx, soil_wtr_current (1))

        Delta_soil_ht_storage = ((Tsoil_current_Avg - Tsoil_prev_Avg)*Cds*soil_bulk_density + _
        (Tsoil_current_Avg*soil_wtr_current_Avg - Tsoil_prev_Avg*soil_wtr_prev_Avg)*1000*Cw)*thick_abv_SHFP/(60*OUTPUT_INTERVAL-Offset_intv_Delta_ht_storage)

        Offset_intv_Delta_ht_storage = 0   'Reset time interval offset

        G_surface = G_surface + Delta_soil_ht_storage

        Tsoil_prev_Avg    = Tsoil_current_Avg
        soil_wtr_prev_Avg = soil_wtr_current_Avg

        #If (SENSOR_Rn) Then
        'CNR1, NR01, CNR4: smallest sensitivity is 10 uV/(W/m^2), CR3K resolution at the measurement range (+/-50 mV) is 0.83 uV.
        'Radiation < 0.083 W/m^2 can not be resolved by CR3K. The value of 0.083 is used for this threshould although this is approximation.
        If  (ABS(Rn - G_surface) > 0.083) Then
          energy_closure = (LE + H)/(Rn - G_surface)
        Else
          energy_closure = 1
        EndIf
        #EndIf
        #EndIf

      EndIf
      #EndIf

      process_time = (Status.ProcessTime(1,1))/1000                              'in ms 
      buff_depth   = Status.BuffDepth(1,1)

      'Save time series data.
      CallTable Time_Series

      'Save averaged and calculated data.
      CallTable Flux

      #If (NOT ONE_FULL_TABLE) Then
      CallTable Flux_Notes
      #EndIf

      slowsequence_disable_flg = TRUE
      If (slowsequence_finished_flg) Then
        slowsequence_finished_flg = FALSE
        slowsequence_disable_flg  = FALSE
      EndIf

    Else
      scan_count += 1
    EndIf
    CallTable diagnostic

  NextScan

  SlowSequence

  Scan (SLOWSEQUENCE_SCAN_INTERVAL, mSec, 3, 0)

    'Measure battery voltage.
    Battery (batt_volt)

    #If (SENSOR_TMPR_RH) Then

    '*** Beginning of temperature and humidity probe measurements ***
    VoltSe (T_probe, 2, mV1000, TMPR_RH_ANALOG_INPUT, TRUE, 0, ANALOG_INTEGRATION, 1, 0)
    T_probe  = T_probe*TMPR_RH_T_MULT + TMPR_RH_T_OFFSET
    RH_probe = RH_probe*TMPR_RH_MULT + TMPR_RH_OFFSET
    VaporPressure (e_probe, T_probe, RH_probe)

    'Saturation water pressure at current temperature
    Enhance_factor1_probe = 1.00041 + amb_press*(3.48e-5 + 7.4e-9*(T_probe + 30.6 - 0.38*amb_press)^2)     'Eq. 6 from Appendix A of flux program manual

    Select Case T_probe                                                                                    'Eq. 5 from Appendix A of flux program manual
    Case Is >= 0
      e_sat_probe = 0.61121*Enhance_factor1_probe*EXP(17.368*T_probe/(T_probe + 238.88))
    Case Is < 0
      e_sat_probe = 0.61121*Enhance_factor1_probe*EXP(17.966*T_probe/(T_probe + 247.15))
    EndSelect

    'Dew point temperature for general use for accurately computing the final dew point temperature
    Enhance_factor2_probe = 1.00072 + 3.46e-5*amb_press                                                     'Eq. 9 from Appendix A of flux program manual

    x_tmp_probe           = LN(e_probe/(0.61121*Enhance_factor2_probe))                                     'For dew point temperature, assume that e is saturation water vapor pressure
    Td_gu_probe           = 240.97*x_tmp_probe/(17.502-x_tmp_probe)

    'Accurate dew point temperature
    Enhance_factor1_probe  = 1.00041 + amb_press*(3.48e-5 + 7.4e-9*(Td_gu_probe + 30.6 - 0.38*amb_press)^2)  'Eq. 6 from Appendix A of flux program manual

    x_tmp_probe            = LN(e_probe/(0.61121*Enhance_factor1_probe))                                     'For dew point temperature, assume that e is saturation water vapor pressure

    Select Case Td_gu_probe                                                                                  'Eq. 11 from Appendix A of flux program manual
    Case Is >= 0
      Td_probe = 238.88*x_tmp_probe/(17.368 - x_tmp_probe)
    Case Is < 0
      Td_probe = 247.15*x_tmp_probe/(17.966 - x_tmp_probe)
    EndSelect

    '*** End of temperature and humidity probe measurements ***
    #EndIf
    #If (SENSOR_Rn) Then
    '*** Beginning of net radiation measurements ***

    #If (SENSOR_NR_LITE) Then

    '*** Beginning of NR Lite measurements ***
    VoltDiff (Rn_meas, 1, AutoRange, NR_ANALOG_INPUT, TRUE, 0, ANALOG_INTEGRATION, NRLITE_CAL, 0)

    'Apply calibration and wind correction to net radiometer measurement.
    If ((hor_wind_diag = 0) AND (hor_wind > 5)) Then
      Rn_raw = Rn_meas*(1 + (0.021286*(hor_wind - 5)))
    Else
      Rn_raw = Rn_meas
    EndIf
    '*** End of NR Lite measurements ***
    #EndIf

    #If (SENSOR_NR01) OR (SENSOR_CNR4) Then

    '*** Beginning of a 4-way radiometer measurements ***
    VoltDiff (R_SW_in, 4, AutoRange, NR_ANALOG_INPUT, TRUE, 0, ANALOG_INTEGRATION, 1, 0)

    #EndIf
    #If (SENSOR_NR01) Then

    'Compute net radiation, albedo, downwelling and upwelling long-wave radiation.
    R_SW_in       = R_SW_in*NR01_SW_IN_CAL
    R_SW_out      = R_SW_out*NR01_SW_OUT_CAL
    R_LW_in_meas  = R_LW_in*NR01_LW_IN_CAL
    R_LW_out_meas = R_LW_out*NR01_LW_OUT_CAL

    Rn_raw = R_SW_in - R_SW_out + R_LW_in_meas - R_LW_out_meas


    If (R_SW_in >0) AND (R_SW_in >= R_SW_out) Then
      albedo = R_SW_out/R_SW_in
    Else
      albedo = 0
    EndIf

    'Correct long-wave radiation.
    Resistance (T_nr, 1, mV200, T_NR_ANALOG_INPUT, T_NR_CURRENT_EXCITATION, 1, 1675, TRUE, TRUE, 0, ANALOG_INTEGRATION, 1, 0)
    T_nr = T_nr/100
    PRT (T_nr, 1, T_nr, 1, T_0C_K)

    'Compute net radiation, albedo, downwelling and upwelling longwave radiation.
    R_LW_in  = R_LW_in_meas  + (5.67e-8*T_nr*T_nr*T_nr*T_nr)
    R_LW_out = R_LW_out_meas + (5.67e-8*T_nr*T_nr*T_nr*T_nr)

    '*** End of a 4-way radiometer measurements ***

    #EndIf
    #If (SENSOR_CNR4) Then

    'Compute net radiation, albedo, downwelling and upwelling long-wave radiation.
    R_SW_in       = R_SW_in*CNR4_SW_IN_CAL
    R_SW_out      = R_SW_out*CNR4_SW_OUT_CAL
    R_LW_in_meas  = R_LW_in*CNR4_LW_IN_CAL
    R_LW_out_meas = R_LW_out*CNR4_LW_OUT_CAL

    Rn_raw = R_SW_in - R_SW_out + R_LW_in_meas - R_LW_out_meas

    If (R_SW_in >0) AND (R_SW_in >= R_SW_out) Then
      albedo = R_SW_out/R_SW_in
    Else
      albedo = 0
    EndIf

    'Correct longwave radiation.
    BrHalf (X_cnr4, 1, mV1000, (2*T_NR_ANALOG_INPUT -1), T_NR_VOLTAGE_EXCITATION, 1, 1000, TRUE, 0, ANALOG_INTEGRATION, 1, 0)
    ln_R = LOG (1000*X_cnr4/(1-X_cnr4))
    T_nr = (1/(A_SHH+B_SHH*ln_R+C_SHH*ln_R*ln_R*ln_R))

    R_LW_in  = R_LW_in_meas  + (5.67e-8*T_nr*T_nr*T_nr*T_nr)
    R_LW_out = R_LW_out_meas + (5.67e-8*T_nr*T_nr*T_nr*T_nr)
    '*** End of a 4-way radiometer measurements ***
    #EndIf

    '*** End of net radiation measurements ***

    #EndIf
    #If (SENSOR_HFP01) Then

    '*** Beginning of HFP01 measurements ***
    VoltDiff (shf_plate(1), NMBR_SHFP, AutoRange, SHF_ANALOG_INPUT, TRUE, 0, ANALOG_INTEGRATION, shf_plate_cal(),0)
    '*** End of HFP01 measurements ***

    #EndIf
    #If ( SENSOR_HFP01SC ) Then

    '*** Beginning of HFP01SC measurements ***
    VoltSe (shf_mV(1), NMBR_SHFP, mV50C, SHF_ANALOG_INPUT, TRUE, 0, ANALOG_INTEGRATION, 1, 0)

    'Apply HFP01SC soil heat flux plate calibration.
    For i_slow = 1 To NMBR_SHFP
      shf_plate(i_slow) = shf_mV(i_slow)*shf_plate_cal(i_slow)
    Next i_slow

    'Power the HFP01SC heaters.
    PortSet (9, sw12_1_state)

    'Measure voltage across the heater (V_Rf).
    VoltSe (V_Rf(1), NMBR_SHFP, mV5000, SHF_HEATER_ANALOG_INPUT , TRUE, 0, ANALOG_INTEGRATION, 0.001, 0)

    'SHF_HEATER_ANALOG_INPUT + NMBR_SHFP
    'Maintain filtered values for calibration.
    AvgRun (shf_mV_run(1), NMBR_SHFP, shf_mV(1), 10)
    AvgRun (V_Rf_run(1),   NMBR_SHFP, V_Rf(1),   10)

    'Begin HFP01SC calibration one minute into very CAL_INTERVAL minutes.
    If (IfTime (1, CAL_INTERVAL, Min)) Then
      shf_cal_on_f = TRUE
      Move (shf_mV_0(1), NMBR_SHFP, shf_mV_run(1), NMBR_SHFP)
      sw12_1_state = TRUE
    EndIf

    If (IfTime (4, CAL_INTERVAL, Min)) Then
      Move (shf_mV_180(1), NMBR_SHFP, shf_mV_run(1), NMBR_SHFP)
      Move (V_Rf_180(1), NMBR_SHFP, V_Rf_run(1), NMBR_SHFP)
      sw12_1_state = FALSE
    EndIf

    'End HFP01SC calibration sequence.
    If (IfTime(END_CAL, CAL_INTERVAL, Min)) Then
      Move (shf_mV_end(1), NMBR_SHFP, shf_mV_run(1), NMBR_SHFP)
      'Compute new HFP01SC calibration factors.
      For i_slow = 1 To NMBR_SHFP
        If ((V_Rf_180(i_slow) <> NaN) AND (shf_mV_0(i_slow) <> NaN) AND (shf_mV_180(i_slow)<> NaN)) Then
        shf_plate_cal(i_slow) = V_Rf_180(i_slow)*V_Rf_180(i_slow)*128.7/ABS (((shf_mV_0(i_slow)+shf_mV_end(i_slow))/2)-shf_mV_180(i_slow))
        EndIf
      Next i_slow
      shf_cal_on_f = FALSE
    EndIf
    '*** End of HFP01SC measurements ***
    #EndIf
    #If ( SENSOR_TCAV ) Then

    '*** Beginning of TCAV measurements ***
    TCDiff (Tsoil(1), NMBR_TCAV, AutoRange, TCAV_ANALOG_INPUT, TypeE, panel_tmpr, TRUE, 0, ANALOG_INTEGRATION, 1, 0)

    #If ((SENSOR_HFP) AND  (SENSOR_CS6XX) AND ((SENSOR_TCAV) OR (SENSOR_CS65X))) Then
    AvgRun (Tsoil_current(1), NMBR_TCAV, Tsoil(1), NMBR_SOIL_T_WTR_DEL_SAMPLES)

    If (Tsoil_prev_Avg = NaN) Then                         'As soon as program starts
      AvgSpa (Tsoil_prev_Avg, NMBR_TCAV, Tsoil(1))
    EndIf
    #EndIf
    '*** End of TCAV measurements ***

    #EndIf
    #If (SENSOR_CS616) Then

    '*** Beginning of CS616 measurements ***
    CS616 (cs616_wcr(1), NMBR_CS6xx, CS616_ANALOG_INPUT, CS616_POWER_CTRL, NMBR_CS6xx, 1, 0)

    #If ((SENSOR_CS616) AND (SENSOR_TCAV)) Then
    If (NMBR_CS6xx >= NMBR_TCAV) Then
      Move(Tsoil_for_CS616_correct(1), NMBR_CS6xx, Tsoil(1), NMBR_TCAV)
    Else
      Move(Tsoil_for_CS616_correct(1), NMBR_CS6xx, Tsoil(1), 1)
    EndIf
    #EndIf

    'Apply temperature correction to CS616 period and find volumetric water content.
    For i_slow = 1 To NMBR_CS6xx

      #If ((SENSOR_CS616) AND (SENSOR_TCAV)) Then
      If ( (10 <= Tsoil_for_CS616_correct(i_slow)) AND (Tsoil_for_CS616_correct(i_slow) <= 40) ) Then
        cs616_T(i_slow) = cs616_wcr(i_slow)+(20-Tsoil_for_CS616_correct(i_slow))*(0.526+cs616_wcr(i_slow)*(-0.052+cs616_wcr(i_slow)*0.00136))
      Else
        cs616_T(i_slow) = cs616_wcr(i_slow)
      EndIf
      soil_wtr_T(i_slow) = -0.0663+cs616_T(i_slow)*(-0.0063+cs616_T(i_slow)*0.0007)
      #EndIf

      #If ((SENSOR_CS616) AND (NOT SENSOR_TCAV)) Then
      soil_wtr(i_slow) = -0.0663+cs616_wcr(i_slow)*(-0.0063+cs616_wcr(i_slow)*0.0007)
      #EndIf

    Next i_slow

    #If ((SENSOR_HFP) AND  (SENSOR_CS616) AND (SENSOR_TCAV)) Then
    AvgRun (soil_wtr_current(1), NMBR_CS6xx, soil_wtr_T(1), NMBR_SOIL_T_WTR_DEL_SAMPLES)

    If soil_wtr_prev_Avg = NaN Then                              'As soon as program started
      AvgSpa (soil_wtr_prev_Avg, NMBR_CS6xx, soil_wtr_T(1))
    EndIf
    #EndIf
    '*** End of CS616 measurements ***
    #EndIf
    #If (SENSOR_CS65X) Then

    '*** Beginning of CS65X measurements ***
    SDI12Recorder (cs65x_raw(1), CS65X_SDI12_PORT, CS65X_SDI12_Address_1, "M!", 1, 0)
    cs65x_wc(1)   = cs65x_raw(1)
    cs65x_ec(1)   = cs65x_raw(2)
    cs65x_tmpr(1) = cs65x_raw(3)

    #If (NMBR_CS6xx = 2) Then
    SDI12Recorder (cs65x_raw(1), CS65X_SDI12_PORT, CS65X_SDI12_Address_2, "M!", 1, 0)
    cs65x_wc(2)   = cs65x_raw(1)
    cs65x_ec(2)   = cs65x_raw(2)
    cs65x_tmpr(2) = cs65x_raw(3)
    #EndIf

    #If ((SENSOR_HFP) AND  (SENSOR_CS6XX) AND ((SENSOR_TCAV) OR (SENSOR_CS65X))) Then

    AvgRun (soil_wtr_current(1), NMBR_CS6xx, cs65x_wc(1), NMBR_SOIL_T_WTR_DEL_SAMPLES)

    If (soil_wtr_prev_Avg = NaN) Then
      AvgSpa (soil_wtr_prev_Avg, NMBR_CS6xx, cs65x_wc(1))
    EndIf

    #If ((SENSOR_CS65X) AND ( NOT SENSOR_TCAV)) Then
    AvgRun (Tsoil_current(1), NMBR_CS6xx, cs65x_tmpr(1), NMBR_SOIL_T_WTR_DEL_SAMPLES)

    If (Tsoil_prev_Avg = NaN) Then                         'As soon as program starts
      AvgSpa (Tsoil_prev_Avg, NMBR_CS6xx, cs65x_tmpr(1))
    EndIf
    #EndIf
    #EndIf
    '*** End of CS65X measurements ***
    #EndIf

    #If (SENSOR_LI200X) OR (SENSOR_CS300) Then

    '*** Beginning of pyranometer measurements ***
    VoltDiff (R_pyran, 1, PYRAN_VOLTAGE_RANG, PYRAN_ANALOG_INPUT, True, 0, ANALOG_INTEGRATION, 1, 0)
    If R_pyran <=0 Then
      R_pyran = 0
    Else
      R_pyran =PYRAN_MULT*R_pyran + PYRAN_OFFSET
    EndIf
    '*** End of pyranometer measurements ***
    #EndIf
    #If (SENSOR_LI190SB) Then

    '*** Beginning of LI190SB measurements ***
    VoltDiff (PAR_density, 1, QUANTUM_VOLTAGE_RANGE, QUANTUM_ANALOG_INPUT, True, 0, ANALOG_INTEGRATION, 1, 0)
    If (PAR_density <= 0) Then
      PAR_density = 0
    Else
      PAR_density = QUANTUM_MULT*PAR_density + QUANTUM_OFFSET
    EndIf
    '*** End of LI190SB measurements ***
    #EndIf

    #If (SENSOR_SI111) Then

    '*** Beginning of SI111 measurements ***
    'Measure SI111 body temperature

    Therm109 (T_SI111_body, 1, 2*SI111_ANALOG_INPUT+1, SI111_EXCITATION, 0, ANALOG_INTEGRATION, 1.0, 0)     'T_SI111_body in C
    m_SI111 = m0_SI111 + m1_SI111*T_SI111_body + m2_SI111*T_SI111_body*T_SI111_body                         'T_SI111_body in C
    b_SI111 = b0_SI111 + b1_SI111*T_SI111_body + b2_SI111*T_SI111_body*T_SI111_body                         'T_SI111_body in C

    VoltDiff (T_SI111_targeted, 1, mV20, SI111_ANALOG_INPUT, True, 0, ANALOG_INTEGRATION, 1, 0)
    T_SI111_targeted = ((T_SI111_body + T_0C_K)^4 + m_SI111*T_SI111_targeted + b_SI111)^0.25 - T_0C_K       'T_SI111_targeted in C
    '*** End of SI111 measurements ***
    #EndIf

    '*** Beginning of updating files of station variables and planar fit angles ***
    'Determing whether or not the planar fit is used. It is used as long as one planar fit angle is not zero.
    stn_var_check_count += 1

    If  (stn_conf_array_prev(stn_var_check_count) <> stn_conf_array(stn_var_check_count)) Then
           
      Select Case stn_var_check_count
        'Update geo-coordinates
      Case 2, 3, 4, 5
        If (hemisphere_NS = Hemisphere_North) Then
          latitude = ABS(latitude)
        Else
          latitude = - ABS(latitude)
        EndIf

        If (hemisphere_EW = Hemisphere_East) Then
          longitude = ABS(longitude)
        Else
          longitude = -ABS(longitude)
        EndIf

        ' Update Aerodynamic height (z)
      Case 6, 7, 8, 9
        Call Displacement_Roughness_heights (surface_type, displacement_user, roughness_user, height_canopy, height_measurement, d, z0, z)
        surface_type_text = surface_type_array(surface_type)
        
        For i = 13 To 16 
          If (stn_conf_array(i) = 100*z_prev) Then 
              stn_conf_array(i) = 100*z            'Default value of 100*z for all sectors in different directions
          EndIf 
        Next 
        
        z_prev = z

      EndSelect

      Calfile (stn_conf_array(1), NMBR_STN_VAR, "CPU:sys_conf_var.dat", 0)          'Store the new values to the file.
      Move(stn_conf_array_prev(1), NMBR_STN_VAR , stn_conf_array(1), NMBR_STN_VAR)  'Update stn_conf_array_prev()

    EndIf

    If stn_var_check_count <= 4 Then

      If (planar_fit_angle_array_prev (stn_var_check_count, 1) <> planar_fit_angle_array (stn_var_check_count, 1)) _
        OR (planar_fit_angle_array_prev (stn_var_check_count, 2) <> planar_fit_angle_array (stn_var_check_count, 2)) Then

        Calfile (planar_fit_angle_array (1,1),8,"CPU:sys_planar_fit_angles.dat",0)  'Store the new values to the file.

        'Keep current values of planar_fit_angle_array() in planar_fit_angle_prev_array() for later use as previous values
        Move (planar_fit_angle_array_prev(stn_var_check_count, 1), 2, planar_fit_angle_array(stn_var_check_count, 1), 2)

        Planar_Fit_flg = FALSE
        For i_slow = 1 To 4
          If (planar_fit_angle_array (i_slow, 1) <> 0) OR (planar_fit_angle_array (i_slow, 2) <> 0) Then
            Planar_Fit_flg = TRUE
            ExitFor
          EndIf
        Next i_slow
      EndIf
    EndIf

    If (stn_var_check_count = NMBR_STN_VAR) Then stn_var_check_count =0
    '*** End of updating files of station variables and planar fit angles ***

    slowsequence_finished_flg = TRUE
  NextScan
EndProg
